<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Date_Structure</title>
    <url>/post/1fe2fe25.html</url>
    <content><![CDATA[<h2 id="链表">链表</h2>
<p>我们让insert操作和delete操作都返回head，可以简化代码实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 定义双向链表节点的结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;          <span class="comment">// 存储数据</span></span><br><span class="line">    Node* prev;        <span class="comment">// 指向前一个节点的指针</span></span><br><span class="line">    Node* next;        <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> val) : <span class="built_in">data</span>(val), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125; <span class="comment">// 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个空链表</span></span><br><span class="line"><span class="function">Node* <span class="title">createLinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表的末尾插入一个新节点</span></span><br><span class="line"><span class="function">Node* <span class="title">insertAtEnd</span><span class="params">(Node* head, <span class="type">int</span> data)</span> </span>&#123;</span><br><span class="line">    Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(data);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> newNode; <span class="comment">// 如果链表为空，新节点成为头节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    current-&gt;next = newNode;</span><br><span class="line">    newNode-&gt;prev = current;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在指定节点后插入一个新节点</span></span><br><span class="line"><span class="function">Node* <span class="title">insertAfter</span><span class="params">(Node* head, Node* nodeToInsertAfter, <span class="type">int</span> newData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || nodeToInsertAfter == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head; <span class="comment">// 空链表或要插入的节点为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node* newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(newData);</span><br><span class="line"></span><br><span class="line">    newNode-&gt;next = nodeToInsertAfter-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (nodeToInsertAfter-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        nodeToInsertAfter-&gt;next-&gt;prev = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nodeToInsertAfter-&gt;next = newNode;</span><br><span class="line">    newNode-&gt;prev = nodeToInsertAfter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除链表中的特定节点</span></span><br><span class="line"><span class="function">Node* <span class="title">deleteNode</span><span class="params">(Node* head, Node* nodeToDelete)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || nodeToDelete == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head; <span class="comment">// 空链表或要删除的节点为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodeToDelete-&gt;prev != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        nodeToDelete-&gt;prev-&gt;next = nodeToDelete-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nodeToDelete-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        nodeToDelete-&gt;next-&gt;prev = nodeToDelete-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (head == nodeToDelete) &#123;</span><br><span class="line">        head = nodeToDelete-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> nodeToDelete;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLinkedList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="string">&quot; &lt;-&gt; &quot;</span>;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* head = <span class="built_in">createLinkedList</span>();</span><br><span class="line">    head = <span class="built_in">insertAtEnd</span>(head, <span class="number">1</span>);</span><br><span class="line">    Node* nodeToInsertAfter = <span class="built_in">insertAtEnd</span>(head, <span class="number">2</span>);</span><br><span class="line">    head = <span class="built_in">insertAtEnd</span>(head, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;原始链表: &quot;</span>;</span><br><span class="line">    <span class="built_in">printLinkedList</span>(head);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> newData = <span class="number">4</span>;</span><br><span class="line">    head = <span class="built_in">insertAfter</span>(head, nodeToInsertAfter, newData);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;在节点 &quot;</span> &lt;&lt; nodeToInsertAfter-&gt;data &lt;&lt; <span class="string">&quot; 后插入节点 &quot;</span> &lt;&lt; newData &lt;&lt; <span class="string">&quot; 后的链表: &quot;</span>;</span><br><span class="line">    <span class="built_in">printLinkedList</span>(head);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;删除节点 &quot;</span> &lt;&lt; nodeToInsertAfter-&gt;data &lt;&lt; <span class="string">&quot; 后的链表: &quot;</span>;</span><br><span class="line">    head = <span class="built_in">deleteNode</span>(head, nodeToInsertAfter);</span><br><span class="line">    <span class="built_in">printLinkedList</span>(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="avl平衡树-无递归无栈version">AVL平衡树（无递归无栈version）</h2>
<p>insert只用转一次，非常好处理，但是delete可能要转很多次，所以对于delete我们第一步转成尾递归，再展开为循环。</p>
<p>delete第一步找到结构上要被删除的点，然后再找到dep最大的不会因为删点导致高度下降的点，从这个点开始从上往下走，不断调整旋转树的结构以维护balance factor。</p>
<p>因为旋转方法可以根据两层内的bf直接确定，所以不需要递归回来的时候改，在从上往下的循环过程中就可以直接先转了再继续循环。</p>
<p>insert和delete的代码，由于没有递归和栈，略显臃肿。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line">    Type data;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    AVLNode&lt;Type&gt; *left,*right;</span><br><span class="line">    <span class="built_in">AVLNode</span>():<span class="built_in">left</span>(<span class="literal">nullptr</span>),<span class="built_in">right</span>(<span class="literal">nullptr</span>),<span class="built_in">height</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">AVLNode</span>(<span class="type">const</span> Type &amp;data,AVLNode *left=<span class="literal">nullptr</span>,AVLNode *right=<span class="literal">nullptr</span>,<span class="type">int</span> height=<span class="number">0</span>):<span class="built_in">data</span>(data),<span class="built_in">left</span>(left),<span class="built_in">right</span>(right),<span class="built_in">height</span>(height)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt; <span class="keyword">class</span> <span class="title class_">AVLTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    AVLNode&lt;Type&gt; *root;</span><br><span class="line">    <span class="comment">//void Release(AVLNode&lt;Type&gt; *Tree);</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Height</span><span class="params">(AVLNode&lt;Type&gt; *Tree)</span></span>&#123;<span class="keyword">return</span> (Tree==<span class="literal">nullptr</span>)?<span class="number">0</span>:Tree-&gt;height;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SingleRotateLeft</span><span class="params">(AVLNode&lt;Type&gt; *&amp;Tree)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SingleRotateRight</span><span class="params">(AVLNode&lt;Type&gt; *&amp;Tree)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoubleRotateLeft</span><span class="params">(AVLNode&lt;Type&gt; *&amp;Tree)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DoubleRotateRight</span><span class="params">(AVLNode&lt;Type&gt; *&amp;Tree)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(AVLNode&lt;Type&gt; *&amp;Tree,<span class="type">const</span> Type &amp;x)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Delete</span><span class="params">(AVLNode&lt;Type&gt; *Tree,<span class="type">const</span> Type &amp;x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AVLNode&lt;Type&gt;* Search(AVLNode&lt;Type&gt; *Tree,Type &amp;x);</span></span><br><span class="line">    <span class="comment">// void PreOrder(AVLNode&lt;Type&gt; *Tree,void );</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> AVLNode&lt;Type&gt; *P,*FA,*Toroot;</span><br><span class="line">    <span class="built_in">AVLTree</span>():<span class="built_in">root</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="comment">//   ~AVLTree()&#123;Release(root);&#125;</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Insert</span><span class="params">(Type x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Insert</span>(root,x);&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Delete</span><span class="params">(Type x)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Delete</span>(root,x);&#125;</span><br><span class="line">    <span class="function">AVLNode&lt;Type&gt;* <span class="title">Root</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> root;&#125;</span><br><span class="line">    <span class="comment">//  bool Search(Type &amp;x)&#123;return !(Search(root,x)==nullptr);&#125;</span></span><br><span class="line">    <span class="comment">//  friend ostream&amp; operator&lt;&lt;(ostream &amp;os,AVLTree&lt;Type&gt; &amp;Tree)&#123;&#125;</span></span><br><span class="line">    <span class="comment">// void PreOrder(void )&#123;PreOrder(root);&#125;</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">bf</span><span class="params">(AVLNode&lt;Type&gt; *Tree)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">Height</span>(Tree-&gt;right)-<span class="built_in">Height</span>(Tree-&gt;left);&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">(AVLNode&lt;Type&gt; *Tree)</span></span>;</span><br><span class="line">    pair&lt;AVLNode&lt;Type&gt;*,AVLNode&lt;Type&gt;*&gt; <span class="built_in">Findnonshorter</span>(AVLNode&lt;Type&gt; *Tree,Type x);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">AVLNode&lt;Type&gt; *AVLTree&lt;Type&gt;::P=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">AVLNode&lt;Type&gt; *AVLTree&lt;Type&gt;::FA=<span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">AVLNode&lt;Type&gt; *AVLTree&lt;Type&gt;::Toroot=<span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;Type&gt;::<span class="built_in">Print</span>(AVLNode&lt;Type&gt; *Tree) &#123;</span><br><span class="line">    <span class="keyword">if</span>(Tree==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;(&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(Tree-&gt;left!=<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">Print</span>(Tree-&gt;left);</span><br><span class="line">    cout&lt;&lt;Tree-&gt;data&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;<span class="built_in">Height</span>(Tree-&gt;right)-<span class="built_in">Height</span>(Tree-&gt;left);<span class="comment">//cout&lt;&lt;&quot;,&quot;&lt;&lt;Tree-&gt;height;</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Height</span>(Tree-&gt;right)-<span class="built_in">Height</span>(Tree-&gt;left)&gt;<span class="number">1</span>||<span class="built_in">Height</span>(Tree-&gt;right)-<span class="built_in">Height</span>(Tree-&gt;left)&lt;<span class="number">-1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;!&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(Tree-&gt;right!=<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">Print</span>(Tree-&gt;right);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;Type&gt;::<span class="built_in">SingleRotateLeft</span>(AVLNode&lt;Type&gt; *&amp;Tree) &#123;</span><br><span class="line">    AVLNode&lt;Type&gt; *t=Tree-&gt;left;</span><br><span class="line">    Tree-&gt;left=t-&gt;right;</span><br><span class="line">    t-&gt;right=Tree;</span><br><span class="line"></span><br><span class="line">    Tree-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(Tree-&gt;left),<span class="built_in">Height</span>(Tree-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    t-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(t-&gt;left),Tree-&gt;height)+<span class="number">1</span>;</span><br><span class="line">    Tree=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;Type&gt;::<span class="built_in">SingleRotateRight</span>(AVLNode&lt;Type&gt; *&amp;Tree) &#123;</span><br><span class="line">    AVLNode&lt;Type&gt; *t=Tree-&gt;right;</span><br><span class="line">    Tree-&gt;right=t-&gt;left;</span><br><span class="line">    t-&gt;left=Tree;</span><br><span class="line"></span><br><span class="line">    Tree-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(Tree-&gt;left),<span class="built_in">Height</span>(Tree-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    t-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(t-&gt;right),Tree-&gt;height)+<span class="number">1</span>;</span><br><span class="line">    Tree=t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;Type&gt;:: <span class="built_in">DoubleRotateLeft</span>(AVLNode&lt;Type&gt; *&amp;Tree) &#123;</span><br><span class="line">    <span class="built_in">SingleRotateRight</span>(Tree-&gt;left);</span><br><span class="line">    <span class="built_in">SingleRotateLeft</span>(Tree);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">void</span> AVLTree&lt;Type&gt;::<span class="built_in">DoubleRotateRight</span>(AVLNode&lt;Type&gt; *&amp;Tree) &#123;</span><br><span class="line">    <span class="built_in">SingleRotateLeft</span>(Tree-&gt;right);</span><br><span class="line">    <span class="built_in">SingleRotateRight</span>(Tree);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">bool</span> AVLTree&lt;Type&gt;::<span class="built_in">Insert</span>(AVLNode&lt;Type&gt;* &amp;tree,<span class="type">const</span> Type &amp;x)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(tree==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        tree=<span class="keyword">new</span> <span class="built_in">AVLNode</span>&lt;Type&gt;(x, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(tree==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Out of space&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tree-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(tree-&gt;left),<span class="built_in">Height</span>(tree-&gt;right))+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    AVLNode&lt;Type&gt; *node=<span class="literal">nullptr</span>,*fanode=<span class="literal">nullptr</span>;</span><br><span class="line">    AVLNode&lt;Type&gt; *t=tree,*fa=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(t!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Height</span>(t-&gt;right)-<span class="built_in">Height</span>(t-&gt;left)!=<span class="number">0</span>)&#123;</span><br><span class="line">            fanode=fa;node=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;t-&gt;data)&#123;</span><br><span class="line">            fa=t;</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;t-&gt;data)&#123;</span><br><span class="line">            fa=t;</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(node==<span class="literal">nullptr</span>) node=tree;</span><br><span class="line">    t=node;fa=fanode;t-&gt;height--;</span><br><span class="line">    <span class="keyword">while</span>(t!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;t-&gt;data)&#123;</span><br><span class="line">            t-&gt;height++;</span><br><span class="line">            fa=t;</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;t-&gt;data)&#123;</span><br><span class="line">            t-&gt;height++;</span><br><span class="line">            fa=t;</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Already exist&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(node-&gt;left),<span class="built_in">Height</span>(node-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;fa-&gt;data) fa-&gt;left=<span class="keyword">new</span> <span class="built_in">AVLNode</span>&lt;Type&gt;(x,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span> fa-&gt;right=<span class="keyword">new</span> <span class="built_in">AVLNode</span>&lt;Type&gt;(x,<span class="literal">nullptr</span>,<span class="literal">nullptr</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bf</span>(node)==<span class="number">2</span>||<span class="built_in">bf</span>(node)==<span class="number">-2</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x&lt;node-&gt;data)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&lt;node-&gt;left-&gt;data)&#123;</span><br><span class="line">                <span class="built_in">SingleRotateLeft</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">DoubleRotateLeft</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;node-&gt;right-&gt;data)&#123;</span><br><span class="line">                <span class="built_in">SingleRotateRight</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">DoubleRotateRight</span>(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(fanode==<span class="literal">nullptr</span>)</span><br><span class="line">        tree=node;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;fanode-&gt;data)</span><br><span class="line">        fanode-&gt;left=node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fanode-&gt;right=node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(fanode!=<span class="literal">nullptr</span>) fanode-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(fanode-&gt;left),<span class="built_in">Height</span>(fanode-&gt;right))+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// nonshorternode + tobedelete</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line">pair&lt;AVLNode&lt;Type&gt; *, AVLNode&lt;Type&gt; *&gt; AVLTree&lt;Type&gt;::<span class="built_in">Findnonshorter</span>(AVLNode&lt;Type&gt; *Tree, Type x) &#123;</span><br><span class="line"></span><br><span class="line">    AVLNode&lt;Type&gt; *t=Tree,*TobeDelete=<span class="literal">nullptr</span>,*nonshorter=<span class="literal">nullptr</span>,*child=<span class="literal">nullptr</span>;</span><br><span class="line">    stack&lt;AVLNode&lt;Type&gt;*&gt; sta;<span class="type">int</span> ok=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(t!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line"></span><br><span class="line">        sta.<span class="built_in">push</span>(t);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;t-&gt;data)&#123;</span><br><span class="line">            t=t-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&gt;t-&gt;data)&#123;</span><br><span class="line">            t=t-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            P=t;ok=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(t-&gt;left==<span class="literal">nullptr</span>&amp;&amp;t-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                TobeDelete=t;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;left==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                TobeDelete=t;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(t-&gt;right==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                TobeDelete=t;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                AVLNode&lt;Type&gt; *t2=t-&gt;left;sta.<span class="built_in">push</span>(t2);</span><br><span class="line">                <span class="keyword">while</span>(t2-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    t2=t2-&gt;right;</span><br><span class="line">                    sta.<span class="built_in">push</span>(t2);</span><br><span class="line">                &#125;</span><br><span class="line">                TobeDelete=t2;<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ok==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="literal">nullptr</span>,<span class="literal">nullptr</span>);</span><br><span class="line">    FA= <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">bool</span> shorter=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span>(!sta.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        AVLNode&lt;Type&gt; *now=sta.<span class="built_in">top</span>();sta.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(now==TobeDelete)&#123;</span><br><span class="line">            child=now;<span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(child==now-&gt;left)&#123;</span><br><span class="line">            <span class="keyword">if</span>(shorter&amp;&amp;((<span class="built_in">Height</span>(now-&gt;left)-<span class="built_in">Height</span>(now-&gt;right)==<span class="number">1</span>)||(<span class="built_in">Height</span>(now-&gt;left)-<span class="built_in">Height</span>(now-&gt;right)==<span class="number">-1</span>&amp;&amp;<span class="built_in">Height</span>(now-&gt;right-&gt;left)-<span class="built_in">Height</span>(now-&gt;right-&gt;right)!=<span class="number">0</span>)))&#123;</span><br><span class="line">                shorter=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                shorter=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!sta.<span class="built_in">empty</span>()) FA=sta.<span class="built_in">top</span>();</span><br><span class="line">                nonshorter=now;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(shorter&amp;&amp;((<span class="built_in">Height</span>(now-&gt;left)-<span class="built_in">Height</span>(now-&gt;right)==<span class="number">-1</span>)||(<span class="built_in">Height</span>(now-&gt;left)-<span class="built_in">Height</span>(now-&gt;right)==<span class="number">1</span>&amp;&amp;<span class="built_in">Height</span>(now-&gt;left-&gt;left)-<span class="built_in">Height</span>(now-&gt;left-&gt;right)!=<span class="number">0</span>)))&#123;</span><br><span class="line">                shorter=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                shorter=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(!sta.<span class="built_in">empty</span>()) FA=sta.<span class="built_in">top</span>();</span><br><span class="line">                nonshorter=now;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        child=now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nonshorter==<span class="literal">nullptr</span>) nonshorter=Tree;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">make_pair</span>(nonshorter,TobeDelete);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="type">bool</span> AVLTree&lt;Type&gt;::<span class="built_in">Delete</span>(AVLNode&lt;Type&gt;* now,<span class="type">const</span> Type &amp;x)&#123;</span><br><span class="line">    pair&lt;AVLNode&lt;Type&gt;*,AVLNode&lt;Type&gt;*&gt; res=<span class="built_in">Findnonshorter</span>(now,x);</span><br><span class="line"></span><br><span class="line">    now=res.first;AVLNode&lt;Type&gt; *ToBeDelNode=res.second;</span><br><span class="line">    <span class="keyword">if</span>(ToBeDelNode==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Type val=ToBeDelNode-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(FA== <span class="literal">nullptr</span>) FA=now;</span><br><span class="line">    AVLNode&lt;Type&gt; **pp=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(FA-&gt;left==now) pp=&amp;FA-&gt;left;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(FA-&gt;right==now) pp=&amp;FA-&gt;right;</span><br><span class="line">    <span class="keyword">else</span> pp=&amp;root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(now==ToBeDelNode)&#123;</span><br><span class="line">            *pp=(now-&gt;right==<span class="literal">nullptr</span>)?now-&gt;left:now-&gt;right;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(val&lt;now-&gt;data)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">bf</span>(now)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">                now-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(now-&gt;left)<span class="number">-1</span>,<span class="built_in">Height</span>(now-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                *pp=now;</span><br><span class="line"></span><br><span class="line">                pp=&amp;now-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">bf</span>(now)==<span class="number">1</span>&amp;&amp;<span class="built_in">bf</span>(now-&gt;right)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                now-&gt;left-&gt;height--;</span><br><span class="line">                AVLNode&lt;Type&gt; *p=now,*q=now-&gt;right,*nLeftRight=q-&gt;left;</span><br><span class="line">                *pp=q;</span><br><span class="line">                q-&gt;left=p;</span><br><span class="line">                p-&gt;right=nLeftRight;</span><br><span class="line">                p-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(p-&gt;left),<span class="built_in">Height</span>(p-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                q-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(q-&gt;left),<span class="built_in">Height</span>(q-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                pp=&amp;p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">bf</span>(now)==<span class="number">1</span>&amp;&amp;<span class="built_in">bf</span>(now-&gt;right)==<span class="number">-1</span>)&#123;</span><br><span class="line">                now-&gt;left-&gt;height--;</span><br><span class="line">                AVLNode&lt;Type&gt; *p,*q,*r,*nLeftRight,*nRightLeft;</span><br><span class="line">                p=now;q=now-&gt;right;r=q-&gt;left;nLeftRight=r-&gt;left;nRightLeft=r-&gt;right;</span><br><span class="line"></span><br><span class="line">                *pp=r;</span><br><span class="line">                r-&gt;left=p;</span><br><span class="line">                r-&gt;right=q;</span><br><span class="line">                p-&gt;right=nLeftRight;</span><br><span class="line">                q-&gt;left=nRightLeft;</span><br><span class="line">                p-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(p-&gt;left),<span class="built_in">Height</span>(p-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                q-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(q-&gt;left),<span class="built_in">Height</span>(q-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                r-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(r-&gt;left),<span class="built_in">Height</span>(r-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                pp=&amp;p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;GG&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            now=*pp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(val&gt;now-&gt;data)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">bf</span>(now)&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                now-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(now-&gt;left),<span class="built_in">Height</span>(now-&gt;right)<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">                *pp=now;</span><br><span class="line">                pp=&amp;now-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">bf</span>(now)==<span class="number">-1</span>&amp;&amp;<span class="built_in">bf</span>(now-&gt;left)&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line">                now-&gt;right-&gt;height--;</span><br><span class="line">                AVLNode&lt;Type&gt; *p=now,*q=now-&gt;left,*nRightLeft=q-&gt;right;</span><br><span class="line">                *pp=q;</span><br><span class="line">                q-&gt;right=p;</span><br><span class="line">                p-&gt;left=nRightLeft;</span><br><span class="line">                p-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(p-&gt;left),<span class="built_in">Height</span>(p-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                q-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(q-&gt;left),<span class="built_in">Height</span>(q-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                pp=&amp;p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">bf</span>(now)==<span class="number">-1</span>&amp;&amp;<span class="built_in">bf</span>(now-&gt;left)==<span class="number">1</span>)&#123;</span><br><span class="line">                now-&gt;right-&gt;height--;</span><br><span class="line">                AVLNode&lt;Type&gt; *p,*q,*r,*nLeftRight,*nRightLeft;</span><br><span class="line">                p=now;q=now-&gt;left;r=q-&gt;right;nLeftRight=r-&gt;left;nRightLeft=r-&gt;right;</span><br><span class="line"></span><br><span class="line">                *pp=r;</span><br><span class="line">                r-&gt;right=p;</span><br><span class="line">                r-&gt;left=q;</span><br><span class="line">                p-&gt;left=nRightLeft;</span><br><span class="line">                q-&gt;right=nLeftRight;</span><br><span class="line">                p-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(p-&gt;left),<span class="built_in">Height</span>(p-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                q-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(q-&gt;left),<span class="built_in">Height</span>(q-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                r-&gt;height=<span class="built_in">max</span>(<span class="built_in">Height</span>(r-&gt;left),<span class="built_in">Height</span>(r-&gt;right))+<span class="number">1</span>;</span><br><span class="line">                pp=&amp;p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;GG&quot;</span>&lt;&lt;endl;</span><br><span class="line">            &#125;</span><br><span class="line">            now=*pp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;Already exist&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    P-&gt;data=val;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    AVLTree&lt;<span class="type">int</span>&gt; Tree;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        cin&gt;&gt;op&gt;&gt;val;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)&#123;</span><br><span class="line">            Tree.<span class="built_in">Insert</span>(val);</span><br><span class="line">            Tree.<span class="built_in">Print</span>(Tree.<span class="built_in">Root</span>());cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Tree.<span class="built_in">Delete</span>(val);</span><br><span class="line">            Tree.<span class="built_in">Print</span>(Tree.<span class="built_in">Root</span>());cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>DS</tag>
      </tags>
  </entry>
  <entry>
    <title>Diffusion入门--inference</title>
    <url>/post/2786a856.html</url>
    <content><![CDATA[<h3 id="本文为diffusion库用于推理的基本介绍-以代码块功能和实现为主">本文为diffusion库用于推理的基本介绍，以代码块功能和实现为主。</h3>
<hr>
<h3 id="三行简化版：">三行简化版：</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DiffusionPipeline</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">pipeline = DiffusionPipeline.from_pretrained(<span class="string">&quot;/data1/sdmodels/stable-diffusion-v1-4&quot;</span>, use_safetensors=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">pipeline.to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line">image = pipeline(<span class="string">&quot;An image of a squirrel in Picasso style&quot;</span>).images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">output_dir = <span class="string">&quot;/data1/sdtest/&quot;</span></span><br><span class="line">output_filename = <span class="string">&quot;2.1.png&quot;</span></span><br><span class="line">output_path = os.path.join(output_dir, output_filename)</span><br><span class="line">image.save(output_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;生成的图像已保存到:&quot;</span>, output_path)</span><br></pre></td></tr></table></figure>
<p>可以看到核心部分只用pipeline调用一个训练好的模型即可</p>
<hr>
<h3 id="当然我们也可以指定model和scheduler-并且自己生成原始噪声并手动实现循环降噪">当然我们也可以指定model和scheduler，并且自己生成原始噪声并手动实现循环降噪</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DDPMScheduler, UNet2DModel, EulerDiscreteScheduler, UNet2DConditionModel</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DDPMScheduler, UNet2DModel</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#分别指定scheduler和model</span></span><br><span class="line">scheduler = DDPMScheduler.from_pretrained(<span class="string">&quot;google/ddpm-cat-256&quot;</span>)</span><br><span class="line">model = UNet2DModel.from_pretrained(<span class="string">&quot;google/ddpm-cat-256&quot;</span>, use_safetensors=<span class="literal">True</span>).to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#设定scheduler步数</span></span><br><span class="line">scheduler.set_timesteps(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#批次大小为1，表示只有一个样本。</span></span><br><span class="line"><span class="comment">#有3个通道，可能表示了一个具有3个颜色通道的图像或者3个特征通道的数据。</span></span><br><span class="line"><span class="comment">#数据的空间维度由sample_size确定，表示了图像的高度和宽度。</span></span><br><span class="line">sample_size = model.config.sample_size</span><br><span class="line">noise = torch.randn((<span class="number">1</span>, <span class="number">3</span>, sample_size, sample_size)).to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = noise</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> scheduler.timesteps:</span><br><span class="line">    <span class="comment">#用model预测残余噪声</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        noisy_residual = model(<span class="built_in">input</span>, t).sample</span><br><span class="line">    <span class="comment">#用scheduler实现diffusion反向传播，参数为预测噪声、步数。当前图像</span></span><br><span class="line">    previous_noisy_sample = scheduler.step(noisy_residual, t, <span class="built_in">input</span>).prev_sample</span><br><span class="line">    <span class="built_in">input</span> = previous_noisy_sample</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">image = (<span class="built_in">input</span> / <span class="number">2</span> + <span class="number">0.5</span>).clamp(<span class="number">0</span>, <span class="number">1</span>).squeeze()</span><br><span class="line">image = (image.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>) * <span class="number">255</span>).<span class="built_in">round</span>().to(torch.uint8).cpu().numpy()</span><br><span class="line">image = Image.fromarray(image)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将图像数据保存为图像文件</span></span><br><span class="line">output_dir = <span class="string">&quot;/data1/sdtest/&quot;</span></span><br><span class="line">output_filename = <span class="string">&quot;2.1.png&quot;</span></span><br><span class="line">output_path = os.path.join(output_dir, output_filename)</span><br><span class="line">image.save(output_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;生成的图像已保存到:&quot;</span>, output_path)</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="关于图像转换的一点补充：">关于图像转换的一点补充：</h4>
<p>将一个PyTorch张量（<code>input</code>）转换为一个NumPy数组，然后再将其转换为PIL（Python Imaging Library）图像对象。让我来解释每一行代码的作用：</p>
<ol>
<li>
<p><code>image = (input / 2 + 0.5).clamp(0, 1).squeeze()</code></p>
<ul>
<li><code>input</code>是一个PyTorch张量，假设其值范围在[-1, 1]之间。</li>
<li><code>(input / 2 + 0.5)</code>：这一步将输入张量的值从范围[-1, 1]线性映射到[0, 1]范围内。</li>
<li><code>.clamp(0, 1)</code>：这一步确保所有的值都在[0, 1]之间，即截断小于0和大于1的值。</li>
<li><code>.squeeze()</code>：如果输入张量的形状中存在大小为1的维度，这一步将其挤压掉，使得输出张量的维度更紧凑。</li>
</ul>
</li>
<li>
<p><code>image = (image.permute(1, 2, 0) * 255).round().to(torch.uint8).cpu().numpy()</code></p>
<ul>
<li><code>image.permute(1, 2, 0)</code>：这一步对<code>image</code>张量的维度进行重排列，将通道维度移到最后一个维度上。这通常是由于PIL图像和NumPy数组的通道顺序不同。</li>
<li><code>* 255</code>：将所有像素值乘以255，将像素值缩放到0-255的整数范围内。</li>
<li><code>.round()</code>：四舍五入将浮点数像素值转换为整数像素值。</li>
<li><code>.to(torch.uint8)</code>：将张量的数据类型转换为无符号8位整数，以确保数值范围在0-255之间。</li>
<li><code>.cpu().numpy()</code>：将PyTorch张量转换为NumPy数组。</li>
</ul>
</li>
<li>
<p><code>image = Image.fromarray(image)</code></p>
<ul>
<li><code>Image.fromarray(image)</code>：这一步将NumPy数组转换为PIL图像对象，使得你可以使用PIL库的功能来处理和显示图像。</li>
</ul>
</li>
</ol>
<p>总之，这段代码的目的是将一个经过处理的PyTorch张量（通常代表图像数据）转换为PIL图像对象，以便进行后续的图像处理或显示。</p>
<hr>
<h3 id="插播sdxl的基本实现">插播sdxl的基本实现</h3>
<p>sdxl因为base&amp;refine机制的引入实现机制相对复杂，这里仅提供基础写法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DiffusionPipeline</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.environ[<span class="string">&quot;CUDA_VISIBLE_DEVICES&quot;</span>] = <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="comment"># load both base &amp; refiner</span></span><br><span class="line">base = DiffusionPipeline.from_pretrained(</span><br><span class="line">    <span class="string">&quot;/data1/sdmodels/stable-diffusion-xl-base-1.0&quot;</span>, torch_dtype=torch.float16, variant=<span class="string">&quot;fp16&quot;</span>, use_safetensors=<span class="literal">True</span></span><br><span class="line">)</span><br><span class="line">base.to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">refiner = DiffusionPipeline.from_pretrained(</span><br><span class="line">    <span class="string">&quot;/data1/sdmodels/stable-diffusion-xl-refiner-1.0&quot;</span>,</span><br><span class="line">    text_encoder_2=base.text_encoder_2,</span><br><span class="line">    vae=base.vae,</span><br><span class="line">    torch_dtype=torch.float16,</span><br><span class="line">    use_safetensors=<span class="literal">True</span>,</span><br><span class="line">    variant=<span class="string">&quot;fp16&quot;</span>,</span><br><span class="line">)</span><br><span class="line">refiner.to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define how many steps and what % of steps to be run on each experts (80/20) here</span></span><br><span class="line">n_steps = <span class="number">40</span></span><br><span class="line">high_noise_frac = <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">prompt = <span class="string">&quot;1girl, aqua eyes, baseball cap, blonde hair, closed mouth, earrings, green background, hat, hoop earrings, jewelry, looking at viewer, shirt, short hair, simple background, solo, upper body, yellow shirt,high quality,masterpiece&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># run both experts</span></span><br><span class="line">image = base(</span><br><span class="line">    prompt=prompt,</span><br><span class="line">    num_inference_steps=n_steps,</span><br><span class="line">    denoising_end=high_noise_frac,</span><br><span class="line">    output_type=<span class="string">&quot;latent&quot;</span>,</span><br><span class="line">).images</span><br><span class="line">image = refiner(</span><br><span class="line">    prompt=prompt,</span><br><span class="line">    num_inference_steps=n_steps,</span><br><span class="line">    denoising_start=high_noise_frac,</span><br><span class="line">    image=image,</span><br><span class="line">).images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">output_dir = <span class="string">&quot;/data1/sdtest/&quot;</span></span><br><span class="line">output_filename = <span class="string">&quot;2.1.png&quot;</span></span><br><span class="line">output_path = os.path.join(output_dir, output_filename)</span><br><span class="line"><span class="comment"># 将图像数据保存为图像文件</span></span><br><span class="line">image.save(output_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;生成的图像已保存到:&quot;</span>, output_path)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="当然有时我们希望能批量出图-并且可以调整整个图模型的各种参数-比如size-step-number等等">当然有时我们希望能批量出图，并且可以调整整个图模型的各种参数，比如size，step_number等等。</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DiffusionPipeline, StableDiffusionPipeline</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> EulerDiscreteScheduler</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> CLIPImageProcessor</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DPMSolverMultistepScheduler</span><br><span class="line"><span class="keyword">from</span> diffusers.utils <span class="keyword">import</span> make_image_grid</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> AutoencoderKL</span><br><span class="line"></span><br><span class="line">model_id = <span class="string">&quot;/data1/sdmodels/stable-diffusion-xl-base-1.0&quot;</span></span><br><span class="line">prompt = <span class="string">&quot;1girl, aqua eyes, baseball cap, blonde hair, closed mouth, earrings, green background, hat, hoop earrings, jewelry, looking at viewer, shirt, short hair, simple background, solo, upper body, yellow shirt,high quality,masterpiece&quot;</span></span><br><span class="line">num_inference_steps = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用fp16降低精度几乎不影响出图质量且可以节省大量显存并提速</span></span><br><span class="line">pipe = DiffusionPipeline.from_pretrained(model_id, torch_dtype=torch.float16, use_safetensors=<span class="literal">True</span>, variant=<span class="string">&quot;fp16&quot;</span>, safety_checker=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">pipe.to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"><span class="comment"># pipe.enable_xformers_memory_efficient_attention()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为模型选定随机种子</span></span><br><span class="line">generator = torch.Generator(<span class="string">&quot;cuda&quot;</span>).manual_seed(np.random.randint(<span class="number">0</span>, <span class="number">114514</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># pipe.scheduler = EulerDiscreteScheduler.from_config(pipe.scheduler.config)</span></span><br><span class="line">pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)</span><br><span class="line"><span class="comment"># pipe.enable_xformers_memory_efficient_attention()</span></span><br><span class="line"><span class="comment"># image = pipe(prompt, generator=generator, height=1024, width=1024,num_inference_steps=num_inference_steps).images[0]</span></span><br><span class="line"><span class="comment"># vae = AutoencoderKL.from_pretrained(</span></span><br><span class="line"><span class="comment">#   &quot;stabilityai/sdxl-vae&quot;, torch_dtype=torch.float16).to(&quot;cuda&quot;)</span></span><br><span class="line"><span class="comment"># pipe.vae = vae</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量出图</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_inputs</span>(<span class="params">batch_size</span>):</span><br><span class="line">    generator = [torch.Generator(<span class="string">&quot;cuda&quot;</span>).manual_seed(np.random.randint(<span class="number">0</span>, <span class="number">114514</span>))</span><br><span class="line">                 <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(batch_size)]</span><br><span class="line">    prompts = batch_size * [prompt]  <span class="comment">#批量prompt</span></span><br><span class="line">    num_inference_steps = <span class="number">20</span>  <span class="comment">#推理步数</span></span><br><span class="line">    height = <span class="number">512</span></span><br><span class="line">    width = <span class="number">512</span> <span class="comment">#size</span></span><br><span class="line">    guidance_scale = <span class="number">7.5</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;prompt&quot;</span>: prompts, <span class="string">&quot;generator&quot;</span>: generator, <span class="string">&quot;num_inference_steps&quot;</span>: num_inference_steps, <span class="string">&quot;height&quot;</span>: height, <span class="string">&quot;width&quot;</span>: width, <span class="string">&quot;guidance_scale&quot;</span>: guidance_scale&#125;</span><br><span class="line"><span class="comment">#提示词（prompt）</span></span><br><span class="line"><span class="comment">#负面词（negative_prompt）</span></span><br><span class="line"><span class="comment">#图片宽高（width, height）</span></span><br><span class="line"><span class="comment">#采样步数（num_inference_steps）</span></span><br><span class="line"><span class="comment">#引导强度（guidance_scale）</span></span><br><span class="line"><span class="comment">#生成张数（num_images_per_prompt）</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pipe.enable_attention_slicing()</span><br><span class="line"></span><br><span class="line"><span class="comment">#一次生成4张图片并且以2*2的方式以网格的形式保存</span></span><br><span class="line">images = pipe(**get_inputs(batch_size=<span class="number">4</span>)).images</span><br><span class="line">grid = make_image_grid(images, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># save the image in the specified directory</span></span><br><span class="line"><span class="comment"># 选择一个文件保存路径</span></span><br><span class="line">output_dir = <span class="string">&quot;/data1/sdtest/&quot;</span></span><br><span class="line">output_filename = <span class="string">&quot;2.1.png&quot;</span></span><br><span class="line">output_path = os.path.join(output_dir, output_filename)</span><br><span class="line"><span class="comment"># 将图像数据保存为图像文件</span></span><br><span class="line">grid.save(output_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;生成的图像已保存到:&quot;</span>, output_path)</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="最后我们希望sd的所有部分都可以自己实现包括encoder-decoder-latent-voe等">最后我们希望sd的所有部分都可以自己实现包括encoder/decoder/latent/voe等</h3>
<p>对各位部件以及每行代码的功能的详细解释可见stablediffusion官网。</p>
<h3 id="较为系统的结合源码的阐释-click-here"><a href="https://huggingface.co/blog/stable_diffusion#writing-your-own-inference-pipeline">较为系统的结合源码的阐释-click here</a></h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> UniPCMultistepScheduler</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> CLIPTextModel, CLIPTokenizer</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> AutoencoderKL, UNet2DConditionModel, PNDMScheduler</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment">#sd几大模块的设定</span></span><br><span class="line">vae = AutoencoderKL.from_pretrained(<span class="string">&quot;CompVis/stable-diffusion-v1-4&quot;</span>, subfolder=<span class="string">&quot;vae&quot;</span>, use_safetensors=<span class="literal">True</span>)</span><br><span class="line">tokenizer = CLIPTokenizer.from_pretrained(<span class="string">&quot;CompVis/stable-diffusion-v1-4&quot;</span>, subfolder=<span class="string">&quot;tokenizer&quot;</span>)</span><br><span class="line">text_encoder = CLIPTextModel.from_pretrained(<span class="string">&quot;CompVis/stable-diffusion-v1-4&quot;</span>, subfolder=<span class="string">&quot;text_encoder&quot;</span>, use_safetensors=<span class="literal">True</span>)</span><br><span class="line">unet = UNet2DConditionModel.from_pretrained(<span class="string">&quot;CompVis/stable-diffusion-v1-4&quot;</span>, subfolder=<span class="string">&quot;unet&quot;</span>, use_safetensors=<span class="literal">True</span>)</span><br><span class="line">scheduler = UniPCMultistepScheduler.from_pretrained(<span class="string">&quot;CompVis/stable-diffusion-v1-4&quot;</span>, subfolder=<span class="string">&quot;scheduler&quot;</span>)</span><br><span class="line"></span><br><span class="line">torch_device = <span class="string">&quot;cuda&quot;</span></span><br><span class="line">vae.to(torch_device)</span><br><span class="line">text_encoder.to(torch_device)</span><br><span class="line">unet.to(torch_device)</span><br><span class="line"></span><br><span class="line">prompt = [<span class="string">&quot;1girl, aqua eyes, baseball cap, blonde hair, closed mouth, earrings, green background, hat, hoop earrings, jewelry, looking at viewer, shirt, short hair, simple background, solo, upper body, yellow shirt,high quality,masterpiece&quot;</span>]</span><br><span class="line">height = <span class="number">512</span>  <span class="comment"># default height of Stable Diffusion</span></span><br><span class="line">width = <span class="number">512</span>  <span class="comment"># default width of Stable Diffusion</span></span><br><span class="line">num_inference_steps = <span class="number">25</span>  <span class="comment"># Number of denoising steps</span></span><br><span class="line">guidance_scale = <span class="number">7.5</span>  <span class="comment"># Scale for classifier-free guidance</span></span><br><span class="line"><span class="comment"># Seed generator to create the inital latent noise</span></span><br><span class="line">generator = torch.manual_seed(<span class="number">0</span>)</span><br><span class="line">batch_size = <span class="built_in">len</span>(prompt)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">text_input = tokenizer(</span><br><span class="line">    prompt, padding=<span class="string">&quot;max_length&quot;</span>, max_length=tokenizer.model_max_length, truncation=<span class="literal">True</span>, return_tensors=<span class="string">&quot;pt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    text_embeddings = text_encoder(text_input.input_ids.to(torch_device))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">max_length = text_input.input_ids.shape[-<span class="number">1</span>]</span><br><span class="line">uncond_input = tokenizer([<span class="string">&quot;&quot;</span>] * batch_size, padding=<span class="string">&quot;max_length&quot;</span>,max_length=max_length, return_tensors=<span class="string">&quot;pt&quot;</span>)</span><br><span class="line">uncond_embeddings = text_encoder(uncond_input.input_ids.to(torch_device))[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">text_embeddings = torch.cat([uncond_embeddings, text_embeddings])</span><br><span class="line"></span><br><span class="line">latents = torch.randn(</span><br><span class="line">    (batch_size, unet.in_channels, height // <span class="number">8</span>, width // <span class="number">8</span>),</span><br><span class="line">    generator=generator,</span><br><span class="line">)</span><br><span class="line">latents = latents.to(torch_device)</span><br><span class="line"></span><br><span class="line">latents = latents * scheduler.init_noise_sigma</span><br><span class="line"></span><br><span class="line">scheduler.set_timesteps(num_inference_steps)</span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> tqdm(scheduler.timesteps):</span><br><span class="line">    <span class="comment"># expand the latents if we are doing classifier-free guidance to avoid doing two forward passes.</span></span><br><span class="line">    latent_model_input = torch.cat([latents] * <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    latent_model_input = scheduler.scale_model_input(</span><br><span class="line">        latent_model_input, timestep=t)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># predict the noise residual</span></span><br><span class="line">    <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">        noise_pred = unet(latent_model_input, t,</span><br><span class="line">                          encoder_hidden_states=text_embeddings).sample</span><br><span class="line"></span><br><span class="line">    <span class="comment"># perform guidance</span></span><br><span class="line">    noise_pred_uncond, noise_pred_text = noise_pred.chunk(<span class="number">2</span>)</span><br><span class="line">    noise_pred = noise_pred_uncond + guidance_scale * \</span><br><span class="line">        (noise_pred_text - noise_pred_uncond)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># compute the previous noisy sample x_t -&gt; x_t-1</span></span><br><span class="line">    latents = scheduler.step(noise_pred, t, latents).prev_sample</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># scale and decode the image latents with vae</span></span><br><span class="line">latents = <span class="number">1</span> / <span class="number">0.18215</span> * latents</span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    image = vae.decode(latents).sample</span><br><span class="line"></span><br><span class="line">image = (image / <span class="number">2</span> + <span class="number">0.5</span>).clamp(<span class="number">0</span>, <span class="number">1</span>).squeeze()</span><br><span class="line">image = (image.permute(<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>) * <span class="number">255</span>).to(torch.uint8).cpu().numpy()</span><br><span class="line">images = (image * <span class="number">255</span>).<span class="built_in">round</span>().astype(<span class="string">&quot;uint8&quot;</span>)</span><br><span class="line">image = Image.fromarray(image)</span><br><span class="line">output_dir = <span class="string">&quot;/data1/sdtest/&quot;</span></span><br><span class="line">output_filename = <span class="string">&quot;2.1.png&quot;</span></span><br><span class="line">output_path = os.path.join(output_dir, output_filename)</span><br><span class="line"><span class="comment"># 将图像数据保存为图像文件</span></span><br><span class="line">image.save(output_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;生成的图像已保存到:&quot;</span>, output_path)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>diffusion</tag>
      </tags>
  </entry>
  <entry>
    <title>Diffusion入门--training</title>
    <url>/post/e5691.html</url>
    <content><![CDATA[<p>本文介绍有关<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>f</mi><mi>f</mi><mi>u</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">diffusion</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">u</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>训练的相关</p>
<hr>
<h3 id="给定数据集进行训练">给定数据集进行训练</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> huggingface_hub <span class="keyword">import</span> HfFolder, Repository, whoami</span><br><span class="line"><span class="keyword">import</span> glob</span><br><span class="line"><span class="keyword">from</span> accelerate <span class="keyword">import</span> notebook_launcher</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> diffusers.utils <span class="keyword">import</span> make_image_grid</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DDPMPipeline</span><br><span class="line"><span class="keyword">from</span> diffusers.optimization <span class="keyword">import</span> get_cosine_schedule_with_warmup</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DDPMScheduler</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> UNet2DModel</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> torchvision <span class="keyword">import</span> transforms</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> datasets <span class="keyword">import</span> load_dataset</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> accelerate <span class="keyword">import</span> Accelerator</span><br><span class="line"><span class="keyword">from</span> huggingface_hub <span class="keyword">import</span> HfFolder, Repository, whoami</span><br><span class="line"><span class="keyword">from</span> tqdm.auto <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TrainingConfig</span>:</span><br><span class="line">    image_size = <span class="number">128</span>  <span class="comment"># the generated image resolution</span></span><br><span class="line">    train_batch_size = <span class="number">16</span></span><br><span class="line">    eval_batch_size = <span class="number">16</span>  <span class="comment"># how many images to sample during evaluation</span></span><br><span class="line">    num_epochs = <span class="number">50</span></span><br><span class="line">    gradient_accumulation_steps = <span class="number">1</span></span><br><span class="line">    learning_rate = <span class="number">1e-4</span></span><br><span class="line">    lr_warmup_steps = <span class="number">500</span></span><br><span class="line">    save_image_epochs = <span class="number">3</span></span><br><span class="line">    save_model_epochs = <span class="number">30</span></span><br><span class="line">    mixed_precision = <span class="string">&quot;fp16&quot;</span>  <span class="comment"># `no` for float32, `fp16` for automatic mixed precision</span></span><br><span class="line">    output_dir = <span class="string">&quot;ddpm-butterflies-128&quot;</span>  <span class="comment"># the model name locally and on the HF Hub</span></span><br><span class="line"></span><br><span class="line">    push_to_hub = <span class="literal">False</span>  <span class="comment"># whether to upload the saved model to the HF Hub</span></span><br><span class="line">    hub_private_repo = <span class="literal">False</span></span><br><span class="line">    overwrite_output_dir = <span class="literal">True</span>  <span class="comment"># overwrite the old model when re-running the notebook</span></span><br><span class="line">    seed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config = TrainingConfig()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">config.dataset_name = <span class="string">&quot;huggan/smithsonian_butterflies_subset&quot;</span></span><br><span class="line">dataset = load_dataset(config.dataset_name, split=<span class="string">&quot;train&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(<span class="number">1</span>, <span class="number">4</span>, figsize=(<span class="number">16</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i, image <span class="keyword">in</span> <span class="built_in">enumerate</span>(dataset[:<span class="number">4</span>][<span class="string">&quot;image&quot;</span>]):</span><br><span class="line">    axs[i].imshow(image)</span><br><span class="line">    axs[i].set_axis_off()</span><br><span class="line">fig.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">preprocess = transforms.Compose(</span><br><span class="line">    [</span><br><span class="line">        transforms.Resize((config.image_size, config.image_size)),</span><br><span class="line">        transforms.RandomHorizontalFlip(),</span><br><span class="line">        transforms.ToTensor(),</span><br><span class="line">        transforms.Normalize([<span class="number">0.5</span>], [<span class="number">0.5</span>]),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">transform</span>(<span class="params">examples</span>):</span><br><span class="line">    images = [preprocess(image.convert(<span class="string">&quot;RGB&quot;</span>)) <span class="keyword">for</span> image <span class="keyword">in</span> examples[<span class="string">&quot;image&quot;</span>]]</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;images&quot;</span>: images&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dataset.set_transform(transform)</span><br><span class="line"></span><br><span class="line"><span class="comment"># fig, axs = plt.subplots(1, 4, figsize=(16, 4))</span></span><br><span class="line"><span class="comment"># for i, image in enumerate(dataset[:4][&quot;image&quot;]):</span></span><br><span class="line"><span class="comment">#    axs[i].imshow(image)</span></span><br><span class="line"><span class="comment">#    axs[i].set_axis_off()</span></span><br><span class="line"><span class="comment"># fig.show()</span></span><br><span class="line"></span><br><span class="line">train_dataloader = torch.utils.data.DataLoader(</span><br><span class="line">    dataset, batch_size=config.train_batch_size, shuffle=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">model = UNet2DModel(</span><br><span class="line">    sample_size=config.image_size,  <span class="comment"># the target image resolution</span></span><br><span class="line">    in_channels=<span class="number">3</span>,  <span class="comment"># the number of input channels, 3 for RGB images</span></span><br><span class="line">    out_channels=<span class="number">3</span>,  <span class="comment"># the number of output channels</span></span><br><span class="line">    layers_per_block=<span class="number">2</span>,  <span class="comment"># how many ResNet layers to use per UNet block</span></span><br><span class="line">    <span class="comment"># the number of output channels for each UNet block</span></span><br><span class="line">    block_out_channels=(<span class="number">128</span>, <span class="number">128</span>, <span class="number">256</span>, <span class="number">256</span>, <span class="number">512</span>, <span class="number">512</span>),</span><br><span class="line">    down_block_types=(</span><br><span class="line">        <span class="string">&quot;DownBlock2D&quot;</span>,  <span class="comment"># a regular ResNet downsampling block</span></span><br><span class="line">        <span class="string">&quot;DownBlock2D&quot;</span>,</span><br><span class="line">        <span class="string">&quot;DownBlock2D&quot;</span>,</span><br><span class="line">        <span class="string">&quot;DownBlock2D&quot;</span>,</span><br><span class="line">        <span class="string">&quot;AttnDownBlock2D&quot;</span>,  <span class="comment"># a ResNet downsampling block with spatial self-attention</span></span><br><span class="line">        <span class="string">&quot;DownBlock2D&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">    up_block_types=(</span><br><span class="line">        <span class="string">&quot;UpBlock2D&quot;</span>,  <span class="comment"># a regular ResNet upsampling block</span></span><br><span class="line">        <span class="string">&quot;AttnUpBlock2D&quot;</span>,  <span class="comment"># a ResNet upsampling block with spatial self-attention</span></span><br><span class="line">        <span class="string">&quot;UpBlock2D&quot;</span>,</span><br><span class="line">        <span class="string">&quot;UpBlock2D&quot;</span>,</span><br><span class="line">        <span class="string">&quot;UpBlock2D&quot;</span>,</span><br><span class="line">        <span class="string">&quot;UpBlock2D&quot;</span>,</span><br><span class="line">    ),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">sample_image = dataset[<span class="number">0</span>][<span class="string">&quot;images&quot;</span>].unsqueeze(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Input shape:&quot;</span>, sample_image.shape)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Output shape:&quot;</span>, model(sample_image, timestep=<span class="number">0</span>).sample.shape)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">noise_scheduler = DDPMScheduler(num_train_timesteps=<span class="number">1000</span>)</span><br><span class="line">noise = torch.randn(sample_image.shape)</span><br><span class="line">timesteps = torch.LongTensor([<span class="number">50</span>])</span><br><span class="line">noisy_image = noise_scheduler.add_noise(sample_image, noise, timesteps)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Image.fromarray(((noisy_image.permute(0, 2, 3, 1) + 1.0) * 127.5).type(torch.uint8).numpy()[0])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">noise_pred = model(noisy_image, timesteps).sample</span><br><span class="line">loss = F.mse_loss(noise_pred, noise)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">optimizer = torch.optim.AdamW(model.parameters(), lr=config.learning_rate)</span><br><span class="line">lr_scheduler = get_cosine_schedule_with_warmup(</span><br><span class="line">    optimizer=optimizer,</span><br><span class="line">    num_warmup_steps=config.lr_warmup_steps,</span><br><span class="line">    num_training_steps=(<span class="built_in">len</span>(train_dataloader) * config.num_epochs),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">evaluate</span>(<span class="params">config, epoch, pipeline</span>):</span><br><span class="line">    <span class="comment"># Sample some images from random noise (this is the backward diffusion process).</span></span><br><span class="line">    <span class="comment"># The default pipeline output type is `List[PIL.Image]`</span></span><br><span class="line">    images = pipeline(</span><br><span class="line">        batch_size=config.eval_batch_size,</span><br><span class="line">        generator=torch.manual_seed(config.seed),</span><br><span class="line">    ).images</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make a grid out of the images</span></span><br><span class="line">    image_grid = make_image_grid(images, rows=<span class="number">4</span>, cols=<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Save the images</span></span><br><span class="line">    test_dir = os.path.join(config.output_dir, <span class="string">&quot;samples&quot;</span>)</span><br><span class="line">    os.makedirs(test_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">    image_grid.save(<span class="string">f&quot;<span class="subst">&#123;test_dir&#125;</span>/<span class="subst">&#123;epoch:04d&#125;</span>.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_full_repo_name</span>(<span class="params">model_id: <span class="built_in">str</span>, organization: <span class="built_in">str</span> = <span class="literal">None</span>, token: <span class="built_in">str</span> = <span class="literal">None</span></span>):</span><br><span class="line">    <span class="keyword">if</span> token <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        token = HfFolder.get_token()</span><br><span class="line">    <span class="keyword">if</span> organization <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        username = whoami(token)[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;username&#125;</span>/<span class="subst">&#123;model_id&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;organization&#125;</span>/<span class="subst">&#123;model_id&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">train_loop</span>(<span class="params">config, model, noise_scheduler, optimizer, train_dataloader, lr_scheduler</span>):</span><br><span class="line">    <span class="comment"># Initialize accelerator and tensorboard logging</span></span><br><span class="line">    accelerator = Accelerator(</span><br><span class="line">        mixed_precision=config.mixed_precision,</span><br><span class="line">        gradient_accumulation_steps=config.gradient_accumulation_steps,</span><br><span class="line">        log_with=<span class="string">&quot;tensorboard&quot;</span>,</span><br><span class="line">        project_dir=os.path.join(config.output_dir, <span class="string">&quot;logs&quot;</span>),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">if</span> accelerator.is_main_process:</span><br><span class="line">        <span class="keyword">if</span> config.push_to_hub:</span><br><span class="line">            repo_name = get_full_repo_name(Path(config.output_dir).name)</span><br><span class="line">            repo = Repository(config.output_dir, clone_from=repo_name)</span><br><span class="line">        <span class="keyword">elif</span> config.output_dir <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            os.makedirs(config.output_dir, exist_ok=<span class="literal">True</span>)</span><br><span class="line">        accelerator.init_trackers(<span class="string">&quot;train_example&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Prepare everything</span></span><br><span class="line">    <span class="comment"># There is no specific order to remember, you just need to unpack the</span></span><br><span class="line">    <span class="comment"># objects in the same order you gave them to the prepare method.</span></span><br><span class="line">    model, optimizer, train_dataloader, lr_scheduler = accelerator.prepare(</span><br><span class="line">        model, optimizer, train_dataloader, lr_scheduler</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    global_step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Now you train the model</span></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(config.num_epochs):</span><br><span class="line">        progress_bar = tqdm(total=<span class="built_in">len</span>(train_dataloader),</span><br><span class="line">                            disable=<span class="keyword">not</span> accelerator.is_local_main_process)</span><br><span class="line">        progress_bar.set_description(<span class="string">f&quot;Epoch <span class="subst">&#123;epoch&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> step, batch <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_dataloader):</span><br><span class="line">            clean_images = batch[<span class="string">&quot;images&quot;</span>]</span><br><span class="line">            <span class="comment"># Sample noise to add to the images</span></span><br><span class="line">            noise = torch.randn(clean_images.shape).to(clean_images.device)</span><br><span class="line">            bs = clean_images.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Sample a random timestep for each image</span></span><br><span class="line">            timesteps = torch.randint(</span><br><span class="line">                <span class="number">0</span>, noise_scheduler.config.num_train_timesteps, (bs,), device=clean_images.device</span><br><span class="line">            ).long()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Add noise to the clean images according to the noise magnitude at each timestep</span></span><br><span class="line">            <span class="comment"># (this is the forward diffusion process)</span></span><br><span class="line">            noisy_images = noise_scheduler.add_noise(</span><br><span class="line">                clean_images, noise, timesteps)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> accelerator.accumulate(model):</span><br><span class="line">                <span class="comment"># Predict the noise residual</span></span><br><span class="line">                noise_pred = model(noisy_images, timesteps,</span><br><span class="line">                                   return_dict=<span class="literal">False</span>)[<span class="number">0</span>]</span><br><span class="line">                loss = F.mse_loss(noise_pred, noise)</span><br><span class="line">                accelerator.backward(loss)</span><br><span class="line"></span><br><span class="line">                accelerator.clip_grad_norm_(model.parameters(), <span class="number">1.0</span>)</span><br><span class="line">                optimizer.step()</span><br><span class="line">                lr_scheduler.step()</span><br><span class="line">                optimizer.zero_grad()</span><br><span class="line"></span><br><span class="line">            progress_bar.update(<span class="number">1</span>)</span><br><span class="line">            logs = &#123;<span class="string">&quot;loss&quot;</span>: loss.detach().item(), <span class="string">&quot;lr&quot;</span>: lr_scheduler.get_last_lr()[</span><br><span class="line">                <span class="number">0</span>], <span class="string">&quot;step&quot;</span>: global_step&#125;</span><br><span class="line">            progress_bar.set_postfix(**logs)</span><br><span class="line">            accelerator.log(logs, step=global_step)</span><br><span class="line">            global_step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># After each epoch you optionally sample some demo images with evaluate() and save the model</span></span><br><span class="line">        <span class="keyword">if</span> accelerator.is_main_process:</span><br><span class="line">            pipeline = DDPMPipeline(unet=accelerator.unwrap_model(</span><br><span class="line">                model), scheduler=noise_scheduler)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (epoch + <span class="number">1</span>) % config.save_image_epochs == <span class="number">0</span> <span class="keyword">or</span> epoch == config.num_epochs - <span class="number">1</span>:</span><br><span class="line">                evaluate(config, epoch, pipeline)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (epoch + <span class="number">1</span>) % config.save_model_epochs == <span class="number">0</span> <span class="keyword">or</span> epoch == config.num_epochs - <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">if</span> config.push_to_hub:</span><br><span class="line">                    repo.push_to_hub(</span><br><span class="line">                        commit_message=<span class="string">f&quot;Epoch <span class="subst">&#123;epoch&#125;</span>&quot;</span>, blocking=<span class="literal">True</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pipeline.save_pretrained(config.output_dir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">args = (config, model, noise_scheduler,</span><br><span class="line">        optimizer, train_dataloader, lr_scheduler)</span><br><span class="line"></span><br><span class="line">notebook_launcher(train_loop, args, num_processes=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sample_images = <span class="built_in">sorted</span>(glob.glob(<span class="string">f&quot;<span class="subst">&#123;config.output_dir&#125;</span>/samples/*.png&quot;</span>))</span><br><span class="line">Image.<span class="built_in">open</span>(sample_images[-<span class="number">1</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="给定lora模型直接加载使用">给定lora模型直接加载使用</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> huggingface_hub.repocard <span class="keyword">import</span> RepoCard</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DiffusionPipeline, StableDiffusionPipeline</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> EulerDiscreteScheduler</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> transformers <span class="keyword">import</span> CLIPImageProcessor</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> DPMSolverMultistepScheduler</span><br><span class="line"><span class="keyword">from</span> diffusers.utils <span class="keyword">import</span> make_image_grid</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> AutoencoderKL</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接加载现成的lora仓库</span></span><br><span class="line">lora_model_id = <span class="string">&quot;sayakpaul/sd-model-finetuned-lora-t4&quot;</span></span><br><span class="line">card = RepoCard.load(lora_model_id)</span><br><span class="line">base_model_id = card.data.to_dict()[<span class="string">&quot;base_model&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(base_model_id)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pipe = StableDiffusionPipeline.from_pretrained(<span class="string">&quot;CompVis/stable-diffusion-v1-4&quot;</span>, torch_dtype=torch.float16, use_safetensors=<span class="literal">True</span>)</span><br><span class="line">pipe.to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line">image = pipe(<span class="string">&quot;pokeman&quot;</span>, num_inference_steps=<span class="number">25</span>, guidance_scale=<span class="number">7.5</span>).images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># save the image in the specified directory</span></span><br><span class="line"><span class="comment"># 选择一个文件保存路径</span></span><br><span class="line">output_dir = <span class="string">&quot;/data1/sdtest/&quot;</span></span><br><span class="line">output_filename = <span class="string">&quot;3.1.png&quot;</span></span><br><span class="line">output_path = os.path.join(output_dir, output_filename)</span><br><span class="line"><span class="comment"># 将图像数据保存为图像文件</span></span><br><span class="line">image.save(output_path)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;生成的图像已保存到:&quot;</span>, output_path)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="利用数据集自己训练lora并使用">利用数据集自己训练lora并使用</h3>
<p>这里是直接用的别人的训练集</p>
<p>Specify the MODEL_NAME environment variable (either a Hub model repository id or a path to the directory containing the model weights) and pass it to the pretrained_model_name_or_path argument. You’ll also need to set the DATASET_NAME environment variable to the name of the dataset you want to train on. To use your own dataset, take a look at the Create a dataset for training guide.</p>
<p>The OUTPUT_DIR and HUB_MODEL_ID variables are optional and specify where to save the model to on the Hub:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型名称</span></span><br><span class="line">export MODEL_NAME=<span class="string">&quot;runwayml/stable-diffusion-v1-5&quot;</span></span><br><span class="line"><span class="comment">#lora输出文件位置</span></span><br><span class="line">export OUTPUT_DIR=<span class="string">&quot;/sddata/finetune/lora/pokemon&quot;</span></span><br><span class="line"><span class="comment">#同步到hub的id</span></span><br><span class="line">export HUB_MODEL_ID=<span class="string">&quot;pokemon-lora&quot;</span></span><br><span class="line"><span class="comment">#dateset名字</span></span><br><span class="line">export DATASET_NAME=<span class="string">&quot;lambdalabs/pokemon-blip-captions&quot;</span></span><br><span class="line"></span><br><span class="line">accelerate launch --mixed_precision=<span class="string">&quot;fp16&quot;</span>  train_text_to_image_lora.py \</span><br><span class="line">  --pretrained_model_name_or_path=$MODEL_NAME \</span><br><span class="line">  --dataset_name=$DATASET_NAME \</span><br><span class="line">  --dataloader_num_workers=<span class="number">8</span> \</span><br><span class="line">  --resolution=<span class="number">512</span> --center_crop --random_flip \</span><br><span class="line">  --train_batch_size=<span class="number">1</span> \</span><br><span class="line">  --gradient_accumulation_steps=<span class="number">4</span> \</span><br><span class="line">  --max_train_steps=<span class="number">15000</span> \</span><br><span class="line">  --learning_rate=<span class="number">1e-04</span> \</span><br><span class="line">  --max_grad_norm=<span class="number">1</span> \</span><br><span class="line">  --lr_scheduler=<span class="string">&quot;cosine&quot;</span> --lr_warmup_steps=<span class="number">0</span> \</span><br><span class="line">  --output_dir=$&#123;OUTPUT_DIR&#125; \</span><br><span class="line">  --push_to_hub \</span><br><span class="line">  --hub_model_id=$&#123;HUB_MODEL_ID&#125; \</span><br><span class="line">  --report_to=wandb \</span><br><span class="line">  --checkpointing_steps=<span class="number">500</span> \</span><br><span class="line">  --validation_prompt=<span class="string">&quot;A pokemon with blue eyes.&quot;</span> \</span><br><span class="line">  --seed=<span class="number">1337</span></span><br></pre></td></tr></table></figure>
<p>There are some flags to be aware of before you start training:</p>
<ul>
<li>–push_to_hub stores the trained LoRA embeddings on the Hub.</li>
<li>–report_to=wandb reports and logs the training results to your Weights &amp; Biases dashboard (as an example, take a look at this report).</li>
<li>–learning_rate=1e-04, you can afford to use a higher learning rate than you normally would with LoRA.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">from</span> diffusers <span class="keyword">import</span> StableDiffusionPipeline, DPMSolverMultistepScheduler</span><br><span class="line"></span><br><span class="line">model_base = <span class="string">&quot;runwayml/stable-diffusion-v1-5&quot;</span></span><br><span class="line"></span><br><span class="line">pipe = StableDiffusionPipeline.from_pretrained(model_base, torch_dtype=torch.float16, use_safetensors=<span class="literal">True</span>)</span><br><span class="line">pipe.scheduler = DPMSolverMultistepScheduler.from_config(pipe.scheduler.config)</span><br><span class="line"></span><br><span class="line">lora_model_path=<span class="string">&quot;/data1/sdtest/lora-test/diffusers/examples/text_to_image/data1/sdtest/sddata/finetune/lora/pokemon/&quot;</span></span><br><span class="line"></span><br><span class="line">pipe.unet.load_attn_procs(lora_model_path)</span><br><span class="line">pipe.to(<span class="string">&quot;cuda&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过cross_attention_kwargs参数指定lora的系数占比</span></span><br><span class="line">image = pipe(</span><br><span class="line">    <span class="string">&quot;pokemon&quot;</span>, num_inference_steps=<span class="number">25</span>, guidance_scale=<span class="number">7.5</span>, cross_attention_kwargs=&#123;<span class="string">&quot;scale&quot;</span>: <span class="number">0.3</span>&#125;</span><br><span class="line">).images[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#image = pipe(&quot;A pokemon with blue eyes.&quot;, num_inference_steps=25, guidance_scale=7.5).images[0]</span></span><br><span class="line">image.save(<span class="string">&quot;blue_pokemon.png&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>diffusion</tag>
      </tags>
  </entry>
  <entry>
    <title>GPT问答_NN数据拟合源码拆解</title>
    <url>/post/a43615c7.html</url>
    <content><![CDATA[<h2 id="sample-code-for-pytorch">Sample code for PyTorch</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">same_seed</span>(<span class="params">seed</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Fixes random number generator seeds for reproducibility.&#x27;&#x27;&#x27;</span></span><br><span class="line">    torch.backends.cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">    torch.backends.cudnn.benchmark = <span class="literal">False</span></span><br><span class="line">    np.random.seed(seed)</span><br><span class="line">    torch.manual_seed(seed)</span><br><span class="line">    <span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">        torch.cuda.manual_seed_all(seed)</span><br></pre></td></tr></table></figure>
<p>这是一个函数，看起来用于设置随机数生成器的种子以实现可重复性。以下是每一句的解释：</p>
<ol>
<li>
<p><code>def same_seed(seed):</code></p>
<ul>
<li>这是一个Python函数的定义，名为<code>same_seed</code>，它接受一个参数<code>seed</code>。</li>
</ul>
</li>
<li>
<p><code>'''Fixes random number generator seeds for reproducibility.'''</code></p>
<ul>
<li>这是函数的文档字符串，提供了对函数目的的简要描述。</li>
</ul>
</li>
<li>
<p><code>torch.backends.cudnn.deterministic = True</code></p>
<ul>
<li>这一行设置了PyTorch的CuDNN后端以确定性模式。这意味着CuDNN将使用固定的算法，以确保每次运行代码时生成的结果都相同，以实现可重复性。</li>
</ul>
</li>
<li>
<p><code>torch.backends.cudnn.benchmark = False</code></p>
<ul>
<li>这一行禁用了CuDNN的性能基准。通常，CuDNN会根据硬件性能自动选择最佳算法，但禁用它可以确保每次都使用相同的算法，以实现可重复性。</li>
</ul>
</li>
<li>
<p><code>np.random.seed(seed)</code></p>
<ul>
<li>这一行设置了NumPy库中随机数生成器的种子，确保NumPy的随机操作也是可重复的。</li>
</ul>
</li>
<li>
<p><code>torch.manual_seed(seed)</code></p>
<ul>
<li>这一行设置了PyTorch的随机数生成器的种子，以确保PyTorch中的随机操作也是可重复的。</li>
</ul>
</li>
<li>
<p><code>if torch.cuda.is_available():</code></p>
<ul>
<li>这一行检查是否有可用的CUDA（GPU）设备。如果系统支持GPU，并且GPU可用，它将执行以下代码块。</li>
</ul>
</li>
<li>
<p><code>torch.cuda.manual_seed_all(seed)</code></p>
<ul>
<li>这一行设置所有可用的CUDA设备上的随机数生成器的种子，以确保在使用GPU时也能实现可重复性。</li>
</ul>
</li>
</ol>
<p>这个函数的作用是在深度学习任务中设置各种随机数生成器的种子，以确保在每次运行相同的代码时，结果都是可重复的，这对于实验和调试非常有用。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">train_valid_split</span>(<span class="params">data_set, valid_ratio, seed</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Split provided training data into training set and validation set&#x27;&#x27;&#x27;</span></span><br><span class="line">    valid_set_size = <span class="built_in">int</span>(valid_ratio * <span class="built_in">len</span>(data_set))</span><br><span class="line">    train_set_size = <span class="built_in">len</span>(data_set) - valid_set_size</span><br><span class="line">    train_set, valid_set = random_split(data_set, [train_set_size, valid_set_size], generator=torch.Generator().manual_seed(seed))</span><br><span class="line">    <span class="keyword">return</span> np.array(train_set), np.array(valid_set)</span><br></pre></td></tr></table></figure>
<p>这是一个函数，用于将提供的训练数据集分割成训练集和验证集。以下是每一句的解释：</p>
<ol>
<li>
<p><code>def train_valid_split(data_set, valid_ratio, seed):</code></p>
<ul>
<li>这是一个Python函数的定义，名为<code>train_valid_split</code>，它接受三个参数：<code>data_set</code>（数据集），<code>valid_ratio</code>（验证集比例），和<code>seed</code>（随机数种子）。</li>
</ul>
</li>
<li>
<p><code>'''Split provided training data into training set and validation set'''</code></p>
<ul>
<li>这是函数的文档字符串，提供了对函数目的的简要描述。</li>
</ul>
</li>
<li>
<p><code>valid_set_size = int(valid_ratio * len(data_set))</code></p>
<ul>
<li>这一行计算了验证集的大小。<code>valid_ratio</code> 是一个介于0和1之间的比例，表示验证集在总数据集中的比例。<code>len(data_set)</code> 给出了总数据集的大小。</li>
</ul>
</li>
<li>
<p><code>train_set_size = len(data_set) - valid_set_size</code></p>
<ul>
<li>这一行计算了训练集的大小，即总数据集大小减去验证集的大小。</li>
</ul>
</li>
<li>
<p><code>train_set, valid_set = random_split(data_set, [train_set_size, valid_set_size], generator=torch.Generator().manual_seed(seed))</code></p>
<ul>
<li>这一行使用<code>random_split</code>函数将数据集分割成训练集和验证集。<code>random_split</code>函数接受三个参数：数据集本身 (<code>data_set</code>)，一个包含两个整数的列表，分别表示训练集和验证集的大小 (<code>[train_set_size, valid_set_size]</code>)，以及一个随机数生成器 (<code>torch.Generator().manual_seed(seed)</code>)，以确保拆分是可重复的。函数返回训练集 (<code>train_set</code>) 和验证集 (<code>valid_set</code>)。</li>
</ul>
</li>
<li>
<p><code>return np.array(train_set), np.array(valid_set)</code></p>
<ul>
<li>最后，函数返回训练集和验证集，这些集合被转换为NumPy数组（<code>np.array</code>），以便后续使用。</li>
</ul>
</li>
</ol>
<p>这个函数的作用是将给定的训练数据集按照指定的验证集比例和种子随机分成训练集和验证集，以用于深度学习模型的训练和验证。</p>
<h3 id="关于随机数生成器">关于随机数生成器</h3>
<p>您可以使用其他随机数生成器替代<code>torch.Generator().manual_seed(seed)</code>，但具体要使用哪个生成器取决于您的需求和代码中使用的深度学习框架。</p>
<p>在PyTorch中，<code>torch.Generator().manual_seed(seed)</code>是一种设置种子以确保随机性可重复的方式。如果您想使用其他生成器，通常可以考虑使用Python内置的<code>random</code>模块或NumPy的随机模块，例如<code>numpy.random.RandomState</code>。以下是一些示例：</p>
<ol>
<li>
<p>使用Python内置的<code>random</code>模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.seed(seed)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用NumPy的随机模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">rng = np.random.RandomState(seed)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这些生成器也可以用于设置随机种子以确保可重复性。但请注意，如果您使用的是PyTorch或其他深度学习框架的功能，通常最好使用该框架提供的生成器，以确保与框架的其他随机操作相协调。在这种情况下，使用<code>torch.Generator().manual_seed(seed)</code>可能是更好的选择。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">test_loader, model, device</span>):</span><br><span class="line">    model.<span class="built_in">eval</span>() <span class="comment"># Set your model to evaluation mode.</span></span><br><span class="line">    preds = []</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tqdm(test_loader):</span><br><span class="line">        x = x.to(device)</span><br><span class="line">        <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">            pred = model(x)</span><br><span class="line">            preds.append(pred.detach().cpu())</span><br><span class="line">    preds = torch.cat(preds, dim=<span class="number">0</span>).numpy()</span><br><span class="line">    <span class="keyword">return</span> preds</span><br></pre></td></tr></table></figure>
<p>这是一个Python函数，用于使用PyTorch模型进行推断（预测）。下面是它的逐句解释：</p>
<ol>
<li>
<p><code>def predict(test_loader, model, device):</code></p>
<ul>
<li>这是一个Python函数的定义，名为<code>predict</code>，它接受三个参数：<code>test_loader</code>，<code>model</code>和<code>device</code>。</li>
</ul>
</li>
<li>
<p><code>model.eval()</code></p>
<ul>
<li><code>model.eval()</code> 是PyTorch中的方法，将神经网络模型切换到评估（evaluation）模式。在评估模式下，模型不会进行梯度计算，通常用于推断（inference）阶段，以加快计算速度并节省内存。</li>
</ul>
</li>
<li>
<p><code>preds = []</code></p>
<ul>
<li>创建一个空列表 <code>preds</code> 以存储模型的预测结果。</li>
</ul>
</li>
<li>
<p><code>for x in tqdm(test_loader):</code></p>
<ul>
<li>这是一个循环，遍历<code>test_loader</code>，<code>test_loader</code>通常是一个数据加载器（data loader），用于提供测试数据。<code>tqdm</code>用于在循环中创建一个进度条，以便跟踪处理进度。</li>
</ul>
</li>
<li>
<p><code>x = x.to(device)</code></p>
<ul>
<li>将输入数据 <code>x</code> 移动到指定的计算设备（通常是GPU或CPU），由<code>device</code>参数指定。</li>
</ul>
</li>
<li>
<p><code>with torch.no_grad():</code></p>
<ul>
<li><code>with torch.no_grad():</code> 是一个上下文管理器，用于告诉PyTorch不要跟踪计算梯度，因为在评估模式下，不需要梯度信息。</li>
</ul>
</li>
<li>
<p><code>pred = model(x)</code></p>
<ul>
<li>使用模型 <code>model</code> 对输入数据 <code>x</code> 进行预测，生成预测结果 <code>pred</code>。</li>
</ul>
</li>
<li>
<p><code>preds.append(pred.detach().cpu())</code></p>
<ul>
<li>将预测结果 <code>pred</code> 从计算设备上移除（<code>.detach()</code>）并移动到CPU上（<code>.cpu()</code>），然后将它添加到 <code>preds</code> 列表中。</li>
</ul>
</li>
<li>
<p><code>preds = torch.cat(preds, dim=0).numpy()</code></p>
<ul>
<li>将列表中的所有预测结果 <code>preds</code> 连接成一个张量，连接维度为 <code>dim=0</code>，然后将结果转换为NumPy数组，最终返回这个NumPy数组。</li>
</ul>
</li>
<li>
<p><code>return preds</code></p>
<ul>
<li>返回包含所有测试样本预测结果的NumPy数组。</li>
</ul>
</li>
</ol>
<p>这个函数的作用是使用给定的PyTorch模型对测试数据进行推断，返回一个包含所有预测结果的NumPy数组。在这个过程中，确保模型处于评估模式，不进行梯度计算，提高推断效率。</p>
<hr>
<p><code>with torch.no_grad():</code> 上下文管理器的作用是告诉PyTorch在这个上下文中不要跟踪计算梯度。这在推断（inference）阶段非常有用，具体原因如下：</p>
<ol>
<li>
<p><strong>梯度计算开销：</strong> 在训练模型时，我们需要计算每个操作的梯度，以便进行反向传播和参数更新。然而，在推断阶段，我们通常不需要这些梯度信息，因为我们只是用模型进行前向传播，计算预测结果。</p>
</li>
<li>
<p><strong>内存优化：</strong> 禁用梯度跟踪可以显著减少内存占用。在训练期间，PyTorch会为每个操作保留梯度信息，这可能占用大量内存。在推断期间，我们可以通过使用<code>with torch.no_grad():</code> 来减少内存使用，特别是当处理大量数据时。</p>
</li>
<li>
<p><strong>加速计算：</strong> 由于不进行梯度计算，禁用梯度跟踪还可以提高计算速度。这对于实时应用或需要高性能的情况非常有帮助。</p>
</li>
</ol>
<p>因此，当你在推断模型时，使用<code>with torch.no_grad():</code> 可以提高效率，减少内存占用，并确保不会因不必要的梯度计算而导致性能下降。</p>
<hr>
<p><code>preds.append(pred.detach().cpu())</code> 的主要原因是将预测结果从GPU（或其他计算设备）移动到CPU是为了使其更易于处理和使用。这样做通常是有几个原因的：</p>
<ol>
<li>
<p><strong>兼容性：</strong> 在PyTorch中，如果你的模型在GPU上计算，那么GPU上的张量与CPU上的张量具有不同的类型。在某些情况下，你可能希望将结果移回CPU，以便与其他CPU上的数据进行处理和组合。</p>
</li>
<li>
<p><strong>NumPy互操作：</strong> 很多时候，你可能需要将PyTorch的张量转换为NumPy数组以便进行进一步的数据处理或可视化。通常，NumPy更容易与CPU上的数据交互，所以将数据移回CPU使得这一过程更简单。</p>
</li>
<li>
<p><strong>内存管理：</strong> GPU上的内存通常有限，将不再需要的数据移回CPU可以释放GPU内存，以便在后续计算中使用。这对于大型模型或大规模数据处理非常重要。</p>
</li>
</ol>
<p>总之，将预测结果从GPU移回CPU通常是为了提高兼容性、便于后续处理，以及有效地管理内存。但需要根据具体的应用场景和需求来决定是否需要这个步骤。如果你只在GPU上进行后续计算，并且不需要与CPU上的数据交互，那么可以跳过这一步。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">COVID19Dataset</span>(<span class="title class_ inherited__">Dataset</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    x: Features.</span></span><br><span class="line"><span class="string">    y: Targets, if none, do prediction.</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.y = y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.y = torch.FloatTensor(y)</span><br><span class="line">        self.x = torch.FloatTensor(x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, idx</span>):</span><br><span class="line">        <span class="keyword">if</span> self.y <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self.x[idx]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self.x[idx], self.y[idx]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__len__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.x)</span><br></pre></td></tr></table></figure>
<p>这是一个自定义的PyTorch数据集类 <code>COVID19Dataset</code>，用于加载和处理COVID-19数据集。以下是该类的逐句解释：</p>
<ol>
<li>
<p><code>class COVID19Dataset(Dataset):</code></p>
<ul>
<li>这是一个类定义，创建了一个名为 <code>COVID19Dataset</code> 的PyTorch数据集类，它继承自 <code>Dataset</code> 类。</li>
</ul>
</li>
<li>
<p><code>def __init__(self, x, y=None):</code></p>
<ul>
<li>这是类的构造函数，它接受两个参数：<code>x</code> 和可选的 <code>y</code>，其中 <code>x</code> 是特征数据，<code>y</code> 是目标数据（如果提供了）。如果没有提供目标数据，你可以在构造数据集对象时将 <code>y</code> 参数设置为 <code>None</code>。</li>
</ul>
</li>
<li>
<p><code>if y is None: self.y = y</code></p>
<ul>
<li>这里检查是否提供了目标数据 <code>y</code>。如果没有提供，<code>self.y</code> 被设置为 <code>None</code>，表示这是一个用于预测的数据集，而不是用于监督学习的数据集。</li>
</ul>
</li>
<li>
<p><code>self.y = torch.FloatTensor(y)</code></p>
<ul>
<li>如果提供了目标数据 <code>y</code>，则将其转换为PyTorch张量并将其存储在 <code>self.y</code> 中。这假设目标数据是浮点数类型。</li>
</ul>
</li>
<li>
<p><code>self.x = torch.FloatTensor(x)</code></p>
<ul>
<li>将特征数据 <code>x</code> 转换为PyTorch张量并将其存储在 <code>self.x</code> 中。同样，这假设特征数据是浮点数类型。</li>
</ul>
</li>
<li>
<p><code>def __getitem__(self, idx):</code></p>
<ul>
<li>这是一个特殊方法，用于定义如何获取数据集中的单个样本。根据是否提供了目标数据，它返回不同的内容。如果没有提供目标数据，只返回特征数据；否则，返回特征数据和目标数据。</li>
</ul>
</li>
<li>
<p><code>def __len__(self):</code></p>
<ul>
<li>这是另一个特殊方法，用于返回数据集的长度，即数据集中包含多少个样本。它返回特征数据 <code>self.x</code> 的长度。</li>
</ul>
</li>
</ol>
<p>这个自定义数据集类的主要作用是为PyTorch提供一种有效的方式来加载和处理COVID-19数据，适用于监督学习和预测任务，具体取决于是否提供了目标数据。这样的数据集类通常在训练和测试神经网络时非常有用。</p>
<hr>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">My_Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_dim</span>):</span><br><span class="line">        <span class="built_in">super</span>(My_Model, self).__init__()</span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> modify model&#x27;s structure, be aware of dimensions.</span></span><br><span class="line">        self.layers = nn.Sequential(</span><br><span class="line">            nn.Linear(input_dim, <span class="number">16</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">16</span>, <span class="number">8</span>),</span><br><span class="line">            nn.ReLU(),</span><br><span class="line">            nn.Linear(<span class="number">8</span>, <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        x = self.layers(x)</span><br><span class="line">        x = x.squeeze(<span class="number">1</span>) <span class="comment"># (B, 1) -&gt; (B)</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>
<p>这是一个自定义的PyTorch神经网络模型类 <code>My_Model</code>，以下是该类的逐句解释：</p>
<ol>
<li>
<p><code>class My_Model(nn.Module):</code></p>
<ul>
<li>这是一个类定义，创建了一个名为 <code>My_Model</code> 的PyTorch神经网络模型类，它继承自 <code>nn.Module</code>。</li>
</ul>
</li>
<li>
<p><code>def __init__(self, input_dim):</code></p>
<ul>
<li>这是类的构造函数，它接受一个参数 <code>input_dim</code>，表示输入数据的维度。</li>
</ul>
</li>
<li>
<p><code>super(My_Model, self).__init__()</code></p>
<ul>
<li>在构造函数中，首先调用父类 <code>nn.Module</code> 的构造函数以初始化模型。</li>
</ul>
</li>
<li>
<p><code>self.layers = nn.Sequential(...)</code></p>
<ul>
<li>这里定义了神经网络的结构。<code>self.layers</code> 是一个由多个层组成的序列（Sequential）模块。模型的结构包括三个线性层（全连接层）和两激活函数层。具体结构如下：
<ul>
<li>输入层：接受大小为 <code>input_dim</code> 的输入。</li>
<li>第一个隐藏层：包含 16 个神经元，并使用 ReLU（Rectified Linear Unit）激活函数。</li>
<li>第二个隐藏层：包含 8 个神经元，并使用 ReLU 激活函数。</li>
<li>输出层：包含 1 个神经元，用于回归任务。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>def forward(self, x):</code></p>
<ul>
<li>这是模型的前向传播方法，用于定义数据在模型中的传递过程。</li>
<li><code>x = self.layers(x)</code> 执行了输入数据 <code>x</code> 经过定义的层序列 <code>self.layers</code> 的前向传播。</li>
<li><code>x = x.squeeze(1)</code> 将输出张量中的维度 1 压缩，从 (B, 1) 到 (B)，其中 B 表示批量大小（Batch Size）。</li>
<li>最终返回处理后的张量 <code>x</code> 作为模型的输出。</li>
</ul>
</li>
</ol>
<hr>
<p>这是一个很好的问题，涉及到Python面向对象编程和继承中的特定语法。在这里，<code>My_Model</code>是一个类，它继承自<code>nn.Module</code>，这是PyTorch中所有神经网络模型的基类。</p>
<p><code>super(My_Model, self).__init__()</code>是一个调用父类<code>nn.Module</code>的<code>__init__</code>方法的特殊方式。让我们分解这个语法：</p>
<ol>
<li>
<p><strong><code>super()</code></strong>: 这是一个Python内置函数，用于调用父类（在这种情况下是<code>nn.Module</code>）的方法。这是在子类中调用父类的方法的推荐方式，特别是当有多重继承时。</p>
</li>
<li>
<p><strong><code>My_Model, self</code></strong>: 这是<code>super()</code>函数的两个参数。</p>
<ul>
<li><code>My_Model</code>: 这是当前的子类。</li>
<li><code>self</code>: 这是当前对象的实例。在Python中，类的方法总是接收其自身的实例作为第一个参数，通常命名为<code>self</code>。</li>
</ul>
</li>
<li>
<p><strong><code>.__init__()</code></strong>: 这是调用的方法名。在这里，我们正在调用<code>nn.Module</code>类的初始化方法<code>__init__</code>。</p>
</li>
</ol>
<ul>
<li>
<p>为什么要这样做？当您创建一个PyTorch模型并继承自<code>nn.Module</code>时，您需要确保<code>nn.Module</code>的初始化代码也被执行。这对于后续的一些PyTorch内部操作，如模型的参数注册等，是必要的。</p>
</li>
<li>
<p>至于为什么<code>self</code>有时在前，有时在后：在方法定义中，<code>self</code>总是作为第一个参数出现，表示对象本身。但在使用<code>super()</code>时，<code>self</code>通常作为第二个参数，这是Python的语法规定。</p>
</li>
</ul>
<hr>
<p>这个自定义模型类是一个典型的前馈神经网络（Feedforward Neural Network），适用于回归任务，它将输入数据通过一系列全连接层和激活函数层传递，最终产生一个输出。你可以根据具体任务的需要，修改模型的结构。</p>
<p>在PyTorch中，每次创建<code>nn.Linear</code>层时，你实际上是创建了一个新的线性层对象，而不是修改或覆盖以前的线性层。这是因为每个<code>nn.Linear</code>层都有自己的权重和偏置，它们是独立的。</p>
<p>所以，当你创建<code>nn.Linear(16, 8)</code>时，它实际上是一个新的线性层，而不会影响先前创建的<code>nn.Linear(input_dim, 16)</code>。这两个层是不同的对象，它们在模型中执行不同的转换。</p>
<p>这种分层的方法允许你创建具有不同权重和偏置的不同层，以便模型可以学习不同的特征表示。它是神经网络的关键之一，因为不同的层可以学习不同的特征并协同工作以解决问题。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_feat</span>(<span class="params">train_data, valid_data, test_data, select_all=<span class="literal">True</span></span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Selects useful features to perform regression&#x27;&#x27;&#x27;</span></span><br><span class="line">    y_train, y_valid = train_data[:,-<span class="number">1</span>], valid_data[:,-<span class="number">1</span>]</span><br><span class="line">    raw_x_train, raw_x_valid, raw_x_test = train_data[:,:-<span class="number">1</span>], valid_data[:,:-<span class="number">1</span>], test_data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> select_all:</span><br><span class="line">        feat_idx = <span class="built_in">list</span>(<span class="built_in">range</span>(raw_x_train.shape[<span class="number">1</span>]))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        feat_idx = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] <span class="comment"># <span class="doctag">TODO:</span> Select suitable feature columns.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> raw_x_train[:,feat_idx], raw_x_valid[:,feat_idx], raw_x_test[:,feat_idx], y_train, y_valid</span><br></pre></td></tr></table></figure>
<p>这是一个用于选择特征列的函数 <code>select_feat</code>，它用于执行回归任务。以下是这个函数的逐句解释：</p>
<ol>
<li>
<p><code>def select_feat(train_data, valid_data, test_data, select_all=True):</code></p>
<ul>
<li>这是函数的定义，它接受四个参数：<code>train_data</code>，<code>valid_data</code>，<code>test_data</code>，以及一个布尔值参数 <code>select_all</code>，默认为 <code>True</code>。</li>
</ul>
</li>
<li>
<p><code>y_train, y_valid = train_data[:,-1], valid_data[:,-1]</code></p>
<ul>
<li>这两行代码从 <code>train_data</code> 和 <code>valid_data</code> 中提取目标变量（标签），通常在回归任务中，这是模型要预测的值。</li>
</ul>
</li>
<li>
<p><code>raw_x_train, raw_x_valid, raw_x_test = train_data[:,:-1], valid_data[:,:-1], test_data</code></p>
<ul>
<li>这三行代码从输入数据中分别提取特征，通过切片 <code>[:,:-1]</code> 取掉最后一列，以便获得没有目标变量的特征数据。</li>
</ul>
</li>
<li>
<p><code>if select_all: feat_idx = list(range(raw_x_train.shape[1]))</code></p>
<ul>
<li>这是一个条件语句，如果 <code>select_all</code> 为 <code>True</code>，则 <code>feat_idx</code> 将包含所有特征的索引。这意味着将使用所有可用的特征进行建模。</li>
</ul>
</li>
<li>
<p><code>else: feat_idx = [0,1,2,3,4]</code></p>
<ul>
<li>如果 <code>select_all</code> 为 <code>False</code>，则 <code>feat_idx</code> 将包含一个手动选择的特征索引列表。这是一个示例，表示你可以手动选择使用的特征列，以便建模。</li>
</ul>
</li>
<li>
<p>最后，函数返回了已选择特征的训练集、验证集和测试集，以及相应的目标变量。所选的特征列由 <code>feat_idx</code> 决定，如果 <code>select_all</code> 为 <code>True</code>，则使用所有特征。</p>
</li>
</ol>
<p>这个函数的目的是根据 <code>select_all</code> 参数，选择特征列，并返回相应的数据子集，以便用于回归任务的训练和测试。根据具体问题，你可以选择使用所有特征或手动选择感兴趣的特征列。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">trainer</span>(<span class="params">train_loader, valid_loader, model, config, device</span>):</span><br><span class="line"></span><br><span class="line">    criterion = nn.MSELoss(reduction=<span class="string">&#x27;mean&#x27;</span>) <span class="comment"># Define your loss function, do not modify this.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Define your optimization algorithm.</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> Please check https://pytorch.org/docs/stable/optim.html to get more available algorithms.</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> L2 regularization (optimizer(weight decay...) or implement by your self).</span></span><br><span class="line">    optimizer = torch.optim.SGD(model.parameters(), lr=config[<span class="string">&#x27;learning_rate&#x27;</span>], momentum=<span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">    writer = SummaryWriter() <span class="comment"># Writer of tensoboard.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(<span class="string">&#x27;./models&#x27;</span>):</span><br><span class="line">        os.mkdir(<span class="string">&#x27;./models&#x27;</span>) <span class="comment"># Create directory of saving models.</span></span><br><span class="line"></span><br><span class="line">    n_epochs, best_loss, step, early_stop_count = config[<span class="string">&#x27;n_epochs&#x27;</span>], math.inf, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(n_epochs):</span><br><span class="line">        model.train() <span class="comment"># Set your model to train mode.</span></span><br><span class="line">        loss_record = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># tqdm is a package to visualize your training progress.</span></span><br><span class="line">        train_pbar = tqdm(train_loader, position=<span class="number">0</span>, leave=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> train_pbar:</span><br><span class="line">            optimizer.zero_grad()               <span class="comment"># Set gradient to zero.</span></span><br><span class="line">            x, y = x.to(device), y.to(device)   <span class="comment"># Move your data to device.</span></span><br><span class="line">            pred = model(x)</span><br><span class="line">            loss = criterion(pred, y)</span><br><span class="line">            loss.backward()                     <span class="comment"># Compute gradient(backpropagation).</span></span><br><span class="line">            optimizer.step()                    <span class="comment"># Update parameters.</span></span><br><span class="line">            step += <span class="number">1</span></span><br><span class="line">            loss_record.append(loss.detach().item())</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Display current epoch number and loss on tqdm progress bar.</span></span><br><span class="line">            train_pbar.set_description(<span class="string">f&#x27;Epoch [<span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;n_epochs&#125;</span>]&#x27;</span>)</span><br><span class="line">            train_pbar.set_postfix(&#123;<span class="string">&#x27;loss&#x27;</span>: loss.detach().item()&#125;)</span><br><span class="line"></span><br><span class="line">        mean_train_loss = <span class="built_in">sum</span>(loss_record)/<span class="built_in">len</span>(loss_record)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Loss/train&#x27;</span>, mean_train_loss, step)</span><br><span class="line"></span><br><span class="line">        model.<span class="built_in">eval</span>() <span class="comment"># Set your model to evaluation mode.</span></span><br><span class="line">        loss_record = []</span><br><span class="line">        <span class="keyword">for</span> x, y <span class="keyword">in</span> valid_loader:</span><br><span class="line">            x, y = x.to(device), y.to(device)</span><br><span class="line">            <span class="keyword">with</span> torch.no_grad():</span><br><span class="line">                pred = model(x)</span><br><span class="line">                loss = criterion(pred, y)</span><br><span class="line"></span><br><span class="line">            loss_record.append(loss.item())</span><br><span class="line"></span><br><span class="line">        mean_valid_loss = <span class="built_in">sum</span>(loss_record)/<span class="built_in">len</span>(loss_record)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;Epoch [<span class="subst">&#123;epoch+<span class="number">1</span>&#125;</span>/<span class="subst">&#123;n_epochs&#125;</span>]: Train loss: <span class="subst">&#123;mean_train_loss:<span class="number">.4</span>f&#125;</span>, Valid loss: <span class="subst">&#123;mean_valid_loss:<span class="number">.4</span>f&#125;</span>&#x27;</span>)</span><br><span class="line">        writer.add_scalar(<span class="string">&#x27;Loss/valid&#x27;</span>, mean_valid_loss, step)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mean_valid_loss &lt; best_loss:</span><br><span class="line">            best_loss = mean_valid_loss</span><br><span class="line">            torch.save(model.state_dict(), config[<span class="string">&#x27;save_path&#x27;</span>]) <span class="comment"># Save your best model</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Saving model with loss &#123;:.3f&#125;...&#x27;</span>.<span class="built_in">format</span>(best_loss))</span><br><span class="line">            early_stop_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            early_stop_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> early_stop_count &gt;= config[<span class="string">&#x27;early_stop&#x27;</span>]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\nModel is not improving, so we halt the training session.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>接下来一步一步分析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">criterion = nn.MSELoss(reduction=&#x27;mean&#x27;)</span><br></pre></td></tr></table></figure>
<p>这行代码用于定义损失函数，其中 <code>nn.MSELoss</code> 表示均方误差损失（Mean Squared Error Loss），通常用于回归任务。让我解释一下它的各个部分：</p>
<ul>
<li>
<p><code>nn.MSELoss</code>: 这部分表示你正在使用PyTorch的均方误差损失函数。均方误差是回归任务中常用的损失函数之一，它用于衡量模型的预测值与实际目标值之间的差距。</p>
</li>
<li>
<p><code>reduction='mean'</code>: 这是损失函数的一个参数，它定义了如何计算损失的标量值。在这里，设置为 <code>'mean'</code> 表示计算所有样本的均方误差，然后求平均值，得到一个标量损失值。其他可能的选项包括 <code>'sum'</code>（计算总和）和 <code>'none'</code>（不进行降维，保持与输入张量相同的维度）。</p>
</li>
</ul>
<p>所以，<code>nn.MSELoss(reduction='mean')</code> 的作用是定义了一个均方误差损失函数，它会计算模型的预测值与实际目标值之间的均方误差，并将其求平均得到一个标量损失值，用于衡量模型的性能。这是回归任务中常见的损失函数之一。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">optimizer = torch.optim.SGD(model.parameters(), lr=config[<span class="string">&#x27;learning_rate&#x27;</span>], momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure>
<p>这是PyTorch中定义优化器的语句。<br>
<code>optimizer = torch.optim.SGD(model.parameters(), lr=config['learning_rate'], momentum=0.9)</code></p>
<ul>
<li>
<p><code>optimizer</code>: 是一个变量，存储了优化器的实例。</p>
</li>
<li>
<p><code>torch.optim.SGD</code>: 这是PyTorch中随机梯度下降（SGD）的实现。</p>
</li>
<li>
<p><code>model.parameters()</code>: 这会返回模型中所有的可训练参数。这些参数是我们在训练过程中需要更新的。</p>
</li>
<li>
<p><code>lr=config['learning_rate']</code>: 这设置了学习率为配置字典中的<code>'learning_rate'</code>键对应的值。学习率是一个关键的超参数，它决定了在每次更新时参数应该改变的幅度。如果学习率太高，模型可能无法收敛；如果太低，则训练可能会非常慢。</p>
</li>
<li>
<p><code>momentum=0.9</code>: 动量是SGD优化器的一个变种，它在更新时考虑了前几次的梯度，以便更快地收敛并减少震荡。动量值通常设置在0.5到0.9之间。在此，它被设置为0.9，意味着当前梯度的90%和前一次的梯度的10%将被用来更新参数。</p>
</li>
</ul>
<p>总之，这行代码创建了一个随机梯度下降优化器，该优化器用于更新模型的参数，它使用了动量来加速收敛。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">writer = SummaryWriter() # Writer of tensoboard.</span><br></pre></td></tr></table></figure>
<p>这行代码与其注释是关于TensorBoard的可视化工具的。</p>
<p><code>writer = SummaryWriter()</code></p>
<ul>
<li>
<p><code>SummaryWriter()</code>: 这是PyTorch的<code>torch.utils.tensorboard</code>中的一个类，它允许用户记录数据，例如损失、准确率等，以便稍后在TensorBoard中进行可视化。</p>
</li>
<li>
<p><code>writer</code>: 是创建的<code>SummaryWriter</code>对象的实例。之后，你可以使用这个实例来添加标量、图像、文本等到TensorBoard日志中。</p>
</li>
</ul>
<p>注释 <code># Writer of tensorboard.</code> 提供了有关这一行代码的简短描述，即这是TensorBoard的写入器。</p>
<p>TensorBoard 是一个由TensorFlow提供的可视化工具，但也可以与PyTorch一起使用。它可以帮助用户可视化模型的训练进程、结构、梯度分布等。这在调试、优化和理解模型时非常有用。使用<code>SummaryWriter</code>，你可以很容易地将这些数据记录到日志中，并在TensorBoard中查看。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">train_pbar = tqdm(train_loader, position=<span class="number">0</span>, leave=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码涉及<code>tqdm</code>库，它是一个用于在Python中显示进度条的库。当你有一个长时间运行的循环或任务时，<code>tqdm</code>可以为你提供一个视觉上友好的进度条，以便你知道任务的进展情况。</p>
<p>让我们分析这行代码：</p>
<p><code>train_pbar = tqdm(train_loader, position=0, leave=True)</code></p>
<ol>
<li>
<p><strong><code>tqdm(train_loader)</code></strong>:</p>
<ul>
<li><code>train_loader</code>: 是一个可迭代对象，通常是一个PyTorch数据加载器。这意味着我们将在进度条中追踪<code>train_loader</code>的迭代进度。</li>
<li>当你迭代<code>train_pbar</code>（例如在一个for循环中）时，它实际上会迭代<code>train_loader</code>，同时更新和显示进度条。</li>
</ul>
</li>
<li>
<p><strong><code>position=0</code></strong>:</p>
<ul>
<li>这定义了进度条在屏幕上的位置。当你有多个进度条或在多线程环境中使用<code>tqdm</code>时，<code>position</code>参数确保进度条在正确的位置显示。</li>
</ul>
</li>
<li>
<p><strong><code>leave=True</code></strong>:</p>
<ul>
<li>当进度条完成时，这个参数决定进度条是否仍然保留在屏幕上。如果为<code>True</code>，进度条在完成后将保留在屏幕上；如果为<code>False</code>，进度条完成后将被清除。</li>
</ul>
</li>
</ol>
<p>总的来说，这行代码创建了一个用于显示<code>train_loader</code>迭代进度的进度条，并将其保存在<code>train_pbar</code>变量中。当你在后续的代码中迭代<code>train_pbar</code>时，进度条会自动更新。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optimizer.zero_grad()</span><br></pre></td></tr></table></figure>
<p>如果不在每个batch开始时调用<code>optimizer.zero_grad()</code>清空参数的梯度，会导致问题。具体来说，PyTorch的设计是为了累积梯度，也就是说，每当<code>.backward()</code>被调用时，梯度都会累积到现有的梯度上，而不是替换它们。</p>
<p>这种累积的特性有以下后果：</p>
<ol>
<li>
<p><strong>错误的参数更新</strong>：如果你不清空梯度，那么新的梯度值将被添加到上一个batch的梯度值上。这意味着，模型的参数更新会基于多个batch的梯度累积，而不是仅仅基于当前batch的梯度。这可能会导致模型收敛得更慢或者完全不收敛。</p>
</li>
<li>
<p><strong>梯度爆炸</strong>：累积的梯度可能会非常大，尤其是在深度网络或大数据集上。这可能会导致梯度爆炸，即梯度变得非常大，导致模型参数在训练过程中变得不稳定。</p>
</li>
<li>
<p><strong>增加的内存使用</strong>：持续的梯度累积可能会导致更大的内存占用。</p>
</li>
<li>
<p><strong>不正确的模型评估</strong>：如果你在评估模型时忘记清空梯度，并执行了<code>.backward()</code>（虽然在评估时通常不需要），那么梯度仍然会累积，这可能会影响到下一次的训练周期。</p>
</li>
</ol>
<p>为了避免这些问题，建议在每个batch开始时调用<code>optimizer.zero_grad()</code>，确保在每次前向和反向传播时都是从零开始计算梯度。</p>
<p>PyTorch选择累积梯度而不是直接替换具有其特定的原因和用途，这种设计为某些特定的模型和技术提供了灵活性：</p>
<ol>
<li>
<p><strong>支持更复杂的模型和损失结构</strong>：有时，我们可能需要从多个源头计算梯度，并将它们聚合。例如，当我们有多个损失函数时，我们可能希望分别计算每个损失的梯度，并在之后将它们相加。累积梯度允许我们这样做。</p>
</li>
<li>
<p><strong>RNNs和BPTT</strong>：对于循环神经网络（RNNs）和通过时间反向传播（BPTT），由于RNN的时间步长，我们可能希望在多个时间步上累积梯度，然后一次性更新。</p>
</li>
<li>
<p><strong>稀疏更新</strong>：对于一些特定的优化技术，我们可能不想在每个批次结束时立即更新所有的参数。通过梯度累积，我们可以在多个批次上计算梯度，然后再进行一次更大的更新。</p>
</li>
<li>
<p><strong>节省计算资源</strong>：在某些场景下，特别是当GPU内存有限时，使用更小的批次进行前向和反向传播，然后累积梯度，可以模拟更大批次的效果而不需要增加计算负担。</p>
</li>
<li>
<p><strong>支持多GPU训练</strong>：当使用多个GPU进行数据并行处理时，每个GPU可以处理一个批次的子集并计算梯度。然后，这些梯度可以在所有GPUs之间聚合（累积）。</p>
</li>
</ol>
<p>考虑到这些情况，PyTorch的设计者选择了更灵活的累积梯度方法。但这也意味着，在大多数常规训练场景中，开发者需要记住在每个批次开始时清零梯度，以避免不必要的累积。</p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">writer.add_scalar(&#x27;Loss/train&#x27;, mean_train_loss, step)</span><br></pre></td></tr></table></figure>
<p>这行代码使用<code>writer</code>（一个<code>SummaryWriter</code>的实例，通常用于TensorBoard日志记录）来添加一个标量值到日志中。这个标量通常用于记录和可视化模型的训练过程中的某些指标，如损失或准确率。我将为您详细解释这行代码：</p>
<p><code>writer.add_scalar('Loss/train', mean_train_loss, step)</code></p>
<ol>
<li>
<p><code>add_scalar</code>: 这是<code>SummaryWriter</code>类的一个方法，用于添加一个标量到TensorBoard日志中。</p>
</li>
<li>
<p><code>'Loss/train'</code>: 这是要添加的标量的标签或名称。在TensorBoard中，你将看到一个叫做&quot;Loss/train&quot;的图表。</p>
</li>
<li>
<p><code>mean_train_loss</code>: 这是要记录的实际数值。在此，它是当前训练周期内所有批次的平均损失。</p>
</li>
<li>
<p><code>step</code>: 这表示当前的全局步骤或迭代。它是一个整数，通常用于表示自训练开始以来已经处理过的批次数量。在TensorBoard的图表中，它将作为x轴，允许你随着时间看到损失的变化。</p>
</li>
</ol>
<p>总的来说，这行代码将当前训练周期的平均损失记录到TensorBoard的日志中，允许你在训练过程中可视化和跟踪损失的变化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">loss_record.append(loss.detach().item())</span><br></pre></td></tr></table></figure>
<p>这行代码涉及了将当前批次的损失值添加到一个记录损失的列表中。我会为您逐步解析这行代码：</p>
<p><code>loss_record.append(loss.detach().item())</code></p>
<ol>
<li>
<p><code>loss_record</code>: 这是一个Python列表，用于在整个训练周期内累积每个批次的损失值。</p>
</li>
<li>
<p><code>append()</code>: 这是Python列表的一个方法，用于在列表的末尾添加一个元素。</p>
</li>
<li>
<p><code>loss</code>: 这是计算得到的损失Tensor，它还包含关于模型参数的梯度信息。</p>
</li>
<li>
<p><code>detach()</code>: 这是一个PyTorch Tensor的方法。它返回一个新的Tensor，这个新Tensor与原始Tensor共享数据但不需要梯度计算（即它不会跟踪计算历史）。这在此上下文中是有用的，因为我们只关心损失的数值，不需要保留关于损失的任何计算历史。</p>
</li>
<li>
<p><code>item()</code>: 这是一个PyTorch Tensor的方法。对于只包含一个元素的tensor，它将返回tensor中的这个值作为一个标准的Python数字。在这种情况下，它返回损失的数值。</p>
</li>
</ol>
<p>所以，这行代码的主要目的是取得当前批次的损失值，并将其添加到<code>loss_record</code>列表中，以便后续可以计算整个训练周期的平均损失或进行其他统计分析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> mean_valid_loss &lt; best_loss:</span><br><span class="line">            best_loss = mean_valid_loss</span><br><span class="line">            torch.save(model.state_dict(), config[<span class="string">&#x27;save_path&#x27;</span>]) <span class="comment"># Save your best model</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Saving model with loss &#123;:.3f&#125;...&#x27;</span>.<span class="built_in">format</span>(best_loss))</span><br><span class="line">            early_stop_count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            early_stop_count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> early_stop_count &gt;= config[<span class="string">&#x27;early_stop&#x27;</span>]:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;\nModel is not improving, so we halt the training session.&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>这段代码实现了检查模型的验证损失是否改进，并根据结果决定是否保存模型和是否提前终止训练（early stopping）。下面是逐句的解释：</p>
<ol>
<li>
<p><code>if mean_valid_loss &lt; best_loss:</code></p>
<ul>
<li>判断当前的平均验证损失是否比之前记录的最佳验证损失更低。</li>
</ul>
</li>
<li>
<p><code>best_loss = mean_valid_loss</code></p>
<ul>
<li>如果当前的验证损失是更低的，那么更新<code>best_loss</code>为当前的<code>mean_valid_loss</code>。</li>
</ul>
</li>
<li>
<p><code>torch.save(model.state_dict(), config['save_path'])</code></p>
<ul>
<li>保存当前模型的参数到指定的路径。这里假定你只想保存最佳的模型，即验证损失最低的模型。</li>
</ul>
</li>
<li>
<p><code>print('Saving model with loss &#123;:.3f&#125;...'.format(best_loss))</code></p>
<ul>
<li>打印一条消息，告知用户模型已被保存，并显示最佳的验证损失。</li>
</ul>
</li>
<li>
<p><code>early_stop_count = 0</code></p>
<ul>
<li>重置早停计数器。这意味着模型在这个周期是有所改进的。</li>
</ul>
</li>
<li>
<p><code>else:</code></p>
<ul>
<li>如果模型没有改进。</li>
</ul>
</li>
<li>
<p><code>early_stop_count += 1</code></p>
<ul>
<li>早停计数器增加1。这意味着模型在这个周期没有改进。</li>
</ul>
</li>
<li>
<p><code>if early_stop_count &gt;= config['early_stop']:</code></p>
<ul>
<li>判断早停计数器是否达到预设的阈值。如果连续多个周期模型都没有改进，那么这个条件将为真。</li>
</ul>
</li>
<li>
<p><code>print('\nModel is not improving, so we halt the training session.')</code></p>
<ul>
<li>打印一条消息，告知用户模型已经连续多个周期没有改进。</li>
</ul>
</li>
<li>
<p><code>return</code></p>
<ul>
<li>提前结束<code>trainer</code>函数的执行。这将终止训练过程。</li>
</ul>
</li>
</ol>
<p>简而言之，这段代码的目的是在每个训练周期后检查模型的性能。如果模型在验证集上表现更好，它会保存模型。如果模型连续多个周期没有改进，它会终止训练。这是一个常用的策略，称为早停，可以帮助避免模型过度拟合并减少不必要的训练时间。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">device = <span class="string">&#x27;cuda&#x27;</span> <span class="keyword">if</span> torch.cuda.is_available() <span class="keyword">else</span> <span class="string">&#x27;cpu&#x27;</span></span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">&#x27;seed&#x27;</span>: <span class="number">5201314</span>,      <span class="comment"># Your seed number, you can pick your lucky number. :)</span></span><br><span class="line">    <span class="string">&#x27;select_all&#x27;</span>: <span class="literal">True</span>,   <span class="comment"># Whether to use all features.</span></span><br><span class="line">    <span class="string">&#x27;valid_ratio&#x27;</span>: <span class="number">0.2</span>,   <span class="comment"># validation_size = train_size * valid_ratio</span></span><br><span class="line">    <span class="string">&#x27;n_epochs&#x27;</span>: <span class="number">3000</span>,     <span class="comment"># Number of epochs.</span></span><br><span class="line">    <span class="string">&#x27;batch_size&#x27;</span>: <span class="number">256</span>,</span><br><span class="line">    <span class="string">&#x27;learning_rate&#x27;</span>: <span class="number">1e-5</span>,</span><br><span class="line">    <span class="string">&#x27;early_stop&#x27;</span>: <span class="number">400</span>,    <span class="comment"># If model has not improved for this many consecutive epochs, stop training.</span></span><br><span class="line">    <span class="string">&#x27;save_path&#x27;</span>: <span class="string">&#x27;./models/model.ckpt&#x27;</span>  <span class="comment"># Your model will be saved here.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要是设置运行训练的配置参数。我将为您逐步解析这段代码：</p>
<ol>
<li>
<p><code>device = 'cuda' if torch.cuda.is_available() else 'cpu'</code></p>
<ul>
<li>这行代码决定模型和数据应该在哪个设备上运行。如果CUDA（GPU支持）可用，它将选择GPU（<code>'cuda'</code>），否则它将选择CPU（<code>'cpu'</code>）。</li>
</ul>
</li>
<li>
<p><code>config = &#123;...&#125;</code></p>
<ul>
<li>定义一个名为<code>config</code>的字典，其中包含多个训练参数和设置。</li>
</ul>
</li>
<li>
<p><code>'seed': 5201314</code></p>
<ul>
<li>设置一个随机数种子，确保实验的可重复性。</li>
</ul>
</li>
<li>
<p><code>'select_all': True</code></p>
<ul>
<li>一个布尔标志，表示是否使用所有特征进行训练。</li>
</ul>
</li>
<li>
<p><code>'valid_ratio': 0.2</code></p>
<ul>
<li>表示验证集的大小是训练集大小的20%。</li>
</ul>
</li>
<li>
<p><code>'n_epochs': 3000</code></p>
<ul>
<li>指定训练的总周期数。</li>
</ul>
</li>
<li>
<p><code>'batch_size': 256</code></p>
<ul>
<li>在每次迭代中，模型将看到的数据批次的大小。</li>
</ul>
</li>
<li>
<p><code>'learning_rate': 1e-5</code></p>
<ul>
<li>设置学习率，它决定了在训练中参数更新的幅度。</li>
</ul>
</li>
<li>
<p><code>'early_stop': 400</code></p>
<ul>
<li>早停策略的参数。如果模型在连续400个周期中没有改进，训练将终止。</li>
</ul>
</li>
<li>
<p><code>'save_path': './models/model.ckpt'</code></p>
</li>
</ol>
<ul>
<li>定义了模型保存的路径。</li>
</ul>
<p>这个<code>config</code>字典为后续的训练步骤提供了一种方便的方式来访问和管理所有的配置参数。在实际项目中，使用这样的配置字典或配置文件是很常见的，因为它使代码更加整洁，并允许更容易地更改参数。</p>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set seed for reproducibility</span></span><br><span class="line">same_seed(config[<span class="string">&#x27;seed&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># train_data size: 2699 x 118 (id + 37 states + 16 features x 5 days)</span></span><br><span class="line"><span class="comment"># test_data size: 1078 x 117 (without last day&#x27;s positive rate)</span></span><br><span class="line">train_data, test_data = pd.read_csv(<span class="string">&#x27;./covid.train.csv&#x27;</span>).values, pd.read_csv(<span class="string">&#x27;./covid.test.csv&#x27;</span>).values</span><br><span class="line">train_data, valid_data = train_valid_split(train_data, config[<span class="string">&#x27;valid_ratio&#x27;</span>], config[<span class="string">&#x27;seed&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the data size.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;&quot;&quot;train_data size: <span class="subst">&#123;train_data.shape&#125;</span></span></span><br><span class="line"><span class="string">valid_data size: <span class="subst">&#123;valid_data.shape&#125;</span></span></span><br><span class="line"><span class="string">test_data size: <span class="subst">&#123;test_data.shape&#125;</span>&quot;&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select features</span></span><br><span class="line">x_train, x_valid, x_test, y_train, y_valid = select_feat(train_data, valid_data, test_data, config[<span class="string">&#x27;select_all&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print out the number of features.</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;number of features: <span class="subst">&#123;x_train.shape[<span class="number">1</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">train_dataset, valid_dataset, test_dataset = COVID19Dataset(x_train, y_train), \</span><br><span class="line">                                            COVID19Dataset(x_valid, y_valid), \</span><br><span class="line">                                            COVID19Dataset(x_test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pytorch data loader loads pytorch dataset into batches.</span></span><br><span class="line">train_loader = DataLoader(train_dataset, batch_size=config[<span class="string">&#x27;batch_size&#x27;</span>], shuffle=<span class="literal">True</span>, pin_memory=<span class="literal">True</span>)</span><br><span class="line">valid_loader = DataLoader(valid_dataset, batch_size=config[<span class="string">&#x27;batch_size&#x27;</span>], shuffle=<span class="literal">True</span>, pin_memory=<span class="literal">True</span>)</span><br><span class="line">test_loader = DataLoader(test_dataset, batch_size=config[<span class="string">&#x27;batch_size&#x27;</span>], shuffle=<span class="literal">False</span>, pin_memory=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码涉及数据处理和准备阶段，确保数据能够正确地被模型所使用。下面我会为您逐句解释这段代码：</p>
<ol>
<li>
<p><code># Set seed for reproducibility</code></p>
<ul>
<li>这是一个注释，说明接下来的代码是为了确保实验的可重复性。</li>
</ul>
</li>
<li>
<p><code>same_seed(config['seed'])</code></p>
<ul>
<li>调用一个名为<code>same_seed</code>的函数来设置随机数种子，以确保实验的可重复性。</li>
</ul>
</li>
<li>
<p><code>train_data, test_data = pd.read_csv('./covid.train.csv').values, pd.read_csv('./covid.test.csv').values</code></p>
<ul>
<li>使用pandas库读取训练和测试数据，并将其转化为NumPy数组。</li>
</ul>
</li>
<li>
<p><code>train_data, valid_data = train_valid_split(train_data, config['valid_ratio'], config['seed'])</code></p>
<ul>
<li>使用<code>train_valid_split</code>函数将原始训练数据分为训练数据和验证数据。</li>
</ul>
</li>
<li>
<p>打印训练数据、验证数据和测试数据的大小。</p>
</li>
<li>
<p><code>x_train, x_valid, x_test, y_train, y_valid = select_feat(train_data, valid_data, test_data, config['select_all'])</code></p>
<ul>
<li>使用<code>select_feat</code>函数从原始数据中选择特定的特征。</li>
</ul>
</li>
<li>
<p>打印所选择的特征的数量。</p>
</li>
<li>
<p>创建三个数据集：训练数据集、验证数据集和测试数据集。这里使用了名为<code>COVID19Dataset</code>的自定义数据集类。</p>
</li>
<li>
<p>使用PyTorch的<code>DataLoader</code>创建数据加载器，它们可以按批次加载数据，并提供其他功能，如数据打乱和内存管理。</p>
</li>
</ol>
<ul>
<li><code>shuffle=True</code>：在训练和验证加载器中使用，表示在每个训练周期中都要打乱数据。</li>
<li><code>pin_memory=True</code>：当使用GPU时，这可以加速数据从CPU传输到GPU的过程。</li>
</ul>
<p>总之，这段代码的目的是从CSV文件中加载数据、处理数据、选择特征，并为训练、验证和测试准备数据加载器。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">pd.read_csv(<span class="string">&#x27;./covid.train.csv&#x27;</span>).values</span><br></pre></td></tr></table></figure>
<p>这行代码使用pandas库来读取CSV文件，并将其转换为NumPy数组。我会为您详细解释：</p>
<ol>
<li>
<p><code>pd.read_csv('./covid.train.csv')</code>: 使用pandas的<code>read_csv</code>函数从指定的路径（<code>'./covid.train.csv'</code>）读取CSV文件。这将返回一个pandas的DataFrame对象，它是一个二维标签化的数据结构。</p>
</li>
<li>
<p><code>.values</code>: 这是一个DataFrame的属性，它会返回DataFrame中的数据作为NumPy数组。这对于进一步的数值处理或与需要NumPy数组的库（如PyTorch、Scikit-learn等）的互操作性很有用。</p>
</li>
</ol>
<p>所以，这行代码的结果是将<code>'./covid.train.csv'</code>文件中的数据读入一个NumPy数组。这个数组可以直接用于大多数数据处理和机器学习任务。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">test_loader = DataLoader(test_dataset, batch_size=config[<span class="string">&#x27;batch_size&#x27;</span>], shuffle=<span class="literal">False</span>, pin_memory=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>这行代码使用PyTorch的<code>DataLoader</code>来创建一个数据加载器，这个加载器用于按批次加载测试数据。我会为您逐步解析这行代码：</p>
<p><code>test_loader = DataLoader(test_dataset, batch_size=config['batch_size'], shuffle=False, pin_memory=True)</code></p>
<ol>
<li>
<p><code>DataLoader</code>: 这是PyTorch提供的一个类，它允许您按批次加载数据，并提供其他功能，如数据打乱、多线程数据加载等。</p>
</li>
<li>
<p><code>test_dataset</code>: 这是您要加载的数据集，通常是一个PyTorch <code>Dataset</code>实例。</p>
</li>
<li>
<p><code>batch_size=config['batch_size']</code>: 这定义了每个批次的大小。<code>config['batch_size']</code>从先前定义的<code>config</code>字典中获取批次大小。</p>
</li>
<li>
<p><code>shuffle=False</code>: 这意味着在加载数据时不应随机打乱数据。这在测试时是常见的，因为您通常只想按原始顺序处理和评估测试数据。</p>
</li>
<li>
<p><code>pin_memory=True</code>: 这是一个优化，当您使用GPU时，它可以加速数据从CPU传输到GPU的过程。在内部，它会为数据预留一个固定的、锁定的（或“钉住的”）内存区域，这使得数据传输更加高效。</p>
</li>
</ol>
<p>总之，这行代码创建了一个测试数据的加载器，这个加载器按照指定的批次大小加载数据，不会打乱数据，并优化了数据的内存管理，特别是在使用GPU时。</p>
<p><code>batch_size</code>是训练神经网络时的一个关键超参数，它决定了每次参数更新所使用的样本数量。<code>batch_size</code>的选择对训练的效率、效果以及模型的性能都有影响。下面列举了<code>batch_size</code>选择大或小时的一些差异和影响：</p>
<ol>
<li>
<p><strong>计算效率</strong>:</p>
<ul>
<li><strong>大</strong>: 利用矩阵运算的并行性，特别是在GPU上，大批次可以提高计算的效率。</li>
<li><strong>小</strong>: 更频繁地进行参数更新，可能会导致硬件资源（特别是GPU）的利用率不足。</li>
</ul>
</li>
<li>
<p><strong>内存使用</strong>:</p>
<ul>
<li><strong>大</strong>: 需要更多的内存来存储大批次的数据和中间计算结果。</li>
<li><strong>小</strong>: 使用更少的内存，允许在内存较小的设备上进行训练。</li>
</ul>
</li>
<li>
<p><strong>收敛速度</strong>:</p>
<ul>
<li><strong>大</strong>: 每个周期需要更少的参数更新，可能导致收敛速度变慢。</li>
<li><strong>小</strong>: 更频繁的参数更新可能使模型更快地收敛。</li>
</ul>
</li>
<li>
<p><strong>训练稳定性</strong>:</p>
<ul>
<li><strong>大</strong>: 噪音较小，梯度估计更为准确，训练路径平滑。</li>
<li><strong>小</strong>: 梯度估计可能存在更多的噪音，可能导致训练路径不稳定。</li>
</ul>
</li>
<li>
<p><strong>泛化能力</strong>:</p>
<ul>
<li><strong>大</strong>: 有研究显示，超大批次可能导致模型的泛化能力下降。</li>
<li><strong>小</strong>: 小批次或随机梯度下降（SGD，即<code>batch_size=1</code>）经常被视为具有某种正则化效果，可能提高模型的泛化能力。</li>
</ul>
</li>
<li>
<p><strong>卡在局部最小值</strong>:</p>
<ul>
<li><strong>大</strong>: 由于梯度估计较为准确，可能更容易卡在非最优的局部最小值。</li>
<li><strong>小</strong>: 更多的噪音可能帮助模型跳出某些局部最小值。</li>
</ul>
</li>
<li>
<p><strong>调整学习率</strong>:</p>
<ul>
<li><strong>大</strong>: 使用大批次可能需要对学习率进行调整，例如增大学习率。</li>
<li><strong>小</strong>: 较小的学习率可能更适合小批次。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>batch_size</code>的选择需要考虑多个因素，并可能需要实验来确定最佳值。在实践中，中等大小的批次（如32、64或128）往往是一个好的起点。</p>
<ol>
<li>
<p><strong>超大批次可能导致模型的泛化能力下降</strong>:</p>
<p>泛化能力是指模型在未见过的数据上的表现。理论上，当使用小批次时，由于每批数据都带有一定的噪音，模型在训练过程中会看到更多的“噪声”，这种噪声可以起到某种正则化的效果，有助于提高模型的泛化能力。另一方面，当使用大批次时，梯度估计更为准确，噪音更少，这可能导致模型过度拟合训练数据，从而降低其在测试数据上的性能。实际上，一些研究发现，使用超大批次可以迅速减少训练损失，但可能会导致测试损失下降得较慢或不如预期。</p>
</li>
<li>
<p><strong>大批次与学习率的关系</strong>:</p>
<p>学习率定义了每次参数更新的幅度。当使用大批次时，梯度估计基于更多的数据，因此它们通常更稳定和准确。因此，可以使用较大的学习率而不会导致训练不稳定。另外，由于大批次训练的收敛速度可能较慢（因为每个周期的更新次数减少了），增大学习率也可以帮助加速收敛。</p>
<p>另一方面，当使用小批次时，梯度估计可能会带有更多的噪音，因此较小的学习率可以帮助确保训练的稳定性，尤其是在训练的早期阶段。</p>
<p>这也解释了为什么许多自适应学习率算法，如Adam，能够在各种批次大小下都工作得很好，因为它们根据梯度的统计信息动态地调整学习率。</p>
</li>
</ol>
<p>综上所述，选择合适的批次大小和学习率是训练深度学习模型时的关键考虑因素，它们之间的关系也是深度学习研究和实践中的一个重要话题。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">save_pred</span>(<span class="params">preds, file</span>):</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Save predictions to specified file &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        writer = csv.writer(fp)</span><br><span class="line">        writer.writerow([<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;tested_positive&#x27;</span>])</span><br><span class="line">        <span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(preds):</span><br><span class="line">            writer.writerow([i, p])</span><br><span class="line"></span><br><span class="line">model = My_Model(input_dim=x_train.shape[<span class="number">1</span>]).to(device)</span><br><span class="line">model.load_state_dict(torch.load(config[<span class="string">&#x27;save_path&#x27;</span>]))</span><br><span class="line">preds = predict(test_loader, model, device)</span><br><span class="line">save_pred(preds, <span class="string">&#x27;pred.csv&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这段代码涉及加载一个训练好的模型、对测试数据进行预测，然后保存预测结果到CSV文件。我会为您逐步解析这段代码：</p>
<ol>
<li>
<p><code>def save_pred(preds, file):</code></p>
<ul>
<li>这是定义一个名为<code>save_pred</code>的函数，用于保存预测结果。它接受两个参数：<code>preds</code>是预测值的列表或数组，<code>file</code>是要保存的文件名。</li>
</ul>
</li>
<li>
<p>在函数内部：</p>
<ul>
<li>使用<code>with open(file, 'w') as fp:</code>，它打开指定的文件以供写入。</li>
<li><code>csv.writer(fp)</code>创建一个CSV写入器对象。</li>
<li>使用<code>writer.writerow()</code>来写入行到CSV文件。</li>
</ul>
</li>
<li>
<p><code>model = My_Model(input_dim=x_train.shape[1]).to(device)</code></p>
<ul>
<li>创建一个模型实例并将其移动到指定的计算设备。</li>
</ul>
</li>
<li>
<p><code>model.load_state_dict(torch.load(config['save_path']))</code></p>
<ul>
<li>使用PyTorch的<code>torch.load</code>函数从先前指定的路径加载模型的状态字典（即模型的参数）。</li>
<li>然后使用<code>load_state_dict</code>方法将这些参数加载到模型中。</li>
</ul>
</li>
<li>
<p><code>preds = predict(test_loader, model, device)</code></p>
<ul>
<li>调用一个名为<code>predict</code>的函数（虽然该函数在给定的代码片段中未定义，但我们可以假设它执行模型的前向传递并返回预测）。</li>
<li>它使用提供的测试数据加载器、模型和设备进行预测。</li>
</ul>
</li>
<li>
<p><code>save_pred(preds, 'pred.csv')</code></p>
<ul>
<li>使用先前定义的<code>save_pred</code>函数将预测结果保存到<code>pred.csv</code>文件中。</li>
</ul>
</li>
</ol>
<p>总的来说，这段代码描述了如何从磁盘加载训练好的模型，使用该模型对测试数据进行预测，然后将这些预测保存到CSV文件中。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">model.load_state_dict(torch.load(config[<span class="string">&#x27;save_path&#x27;</span>]))</span><br></pre></td></tr></table></figure>
<p>这行代码是PyTorch中加载预训练模型权重的常见方式。让我们逐部分解析这行代码：</p>
<ol>
<li>
<p><strong><code>torch.load(config['save_path'])</code></strong>:</p>
<ul>
<li>使用PyTorch的<code>torch.load</code>方法从指定的路径加载数据。这通常是一个包含模型参数的字典，该字典在保存模型时使用<code>torch.save</code>方法创建。</li>
<li><code>config['save_path']</code>是模型权重文件的路径。它从之前定义的<code>config</code>字典中获取。</li>
</ul>
</li>
<li>
<p><strong><code>model.load_state_dict(...)</code></strong>:</p>
<ul>
<li><code>load_state_dict</code>是PyTorch模型（或<code>nn.Module</code>实例）的一个方法，它负责将一个状态字典加载到模型中。</li>
<li>这个状态字典包含模型的权重。当我们调用<code>load_state_dict</code>方法时，它会为模型中的每个层设置适当的权重。</li>
</ul>
</li>
</ol>
<p>总之，<code>model.load_state_dict(torch.load(config['save_path']))</code>这行代码的目的是从指定路径加载模型权重，并将这些权重应用到模型<code>model</code>中。这允许你继续使用之前训练过的模型，而不必重新从头开始训练。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>GPT</tag>
        <tag>神经网络</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Stable-diffusion-command</title>
    <url>/post/9ba61012.html</url>
    <content><![CDATA[<h3 id="指定服务器调用显卡">指定服务器调用显卡</h3>
<p><code>export CUDA_VISIBLE_DEVICES=1,3</code></p>
<h3 id="export配置环境变量">export配置环境变量</h3>
<h3 id="pip换源">pip换源</h3>
<p>python -m pip config set global.index-url <a href="http://mirrors.cloud.tencent.com/pypi/simple">http://mirrors.cloud.tencent.com/pypi/simple</a></p>
<hr>
<h2 id="一次性打开代理">一次性打开代理</h2>
<p>export http_proxy=http://127.0.0.1:7890<br>
export https_proxy=http://127.0.0.1:7890<br>
export ALL_PROXY=socks5://127.0.0.1:7891</p>
<h2 id="打开代理：">打开代理：</h2>
<p><code>clash -d ~/.config/clash</code></p>
<p>echo $https_proxy</p>
<hr>
<p>如果你想要临时关闭终端会话中的代理设置，可以运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> https_proxy http_proxy all_proxy ALL_PROXY</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="关于科学上网：">关于科学上网：</h3>
<p>要设置 <code>https_proxy</code> 环境变量为 <code>http://127.0.0.1:7890</code>，你可以使用以下方式：</p>
<p>临时设置，只在当前终端会话中生效（终端关闭后将失效）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<p>永久设置，对当前用户在所有终端会话中都生效：</p>
<ol>
<li>打开终端并运行以下命令编辑用户的 <code>~/.bashrc</code> 文件（如果你使用的是 Bash shell）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nano ~/.bashrc</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>在文件末尾添加以下行：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>按下 <code>Ctrl + O</code> 保存文件，然后按下 <code>Ctrl + X</code> 关闭文本编辑器。</p>
</li>
<li>
<p>使更改生效：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>这样，在每次打开新终端会话时，<code>https_proxy</code> 环境变量都会被自动设置为 <code>http://127.0.0.1:7890</code>。</p>
<p>请注意，如果你使用的是其他 shell，例如 Zsh，那么相应的配置文件可能不是 <code>~/.bashrc</code>，而是 <code>~/.zshrc</code>。在这种情况下，请将上述步骤中的文件名替换为正确的配置文件名。</p>
<hr>
]]></content>
      <tags>
        <tag>sd</tag>
      </tags>
  </entry>
  <entry>
    <title>Python之散装知识</title>
    <url>/post/d9e0de5e.html</url>
    <content><![CDATA[<h2 id="1-staticmethod-的使用">1. @staticmethod 的使用</h2>
<p>在Python中，<code>@staticmethod</code>是一个装饰器（decorator），用于定义类中的静态方法（staticmethods）。静态方法是类中的一种方法，它与类的实例无关，因此不需要通过类的实例进行调用，而是直接通过类名调用。</p>
<p>使用<code>@staticmethod</code>装饰器可以将一个普通的方法转换为静态方法。在定义静态方法时，需要在方法上方加上<code>@staticmethod</code>装饰器。静态方法的定义和使用有以下特点：</p>
<ol>
<li>
<p><strong>不需要访问类的实例</strong>：静态方法没有 <code>self</code> 参数，因此在方法体内无法直接访问类的实例属性或调用实例方法。它只能访问类级别的属性和其他静态方法。</p>
</li>
<li>
<p><strong>通过类名调用</strong>：由于静态方法与类的实例无关，所以可以直接通过类名调用。不需要实例化类对象即可使用静态方法。</p>
</li>
<li>
<p><strong>不需要隐式传递参数</strong>：普通的实例方法会自动接收类的实例作为第一个参数，通常命名为 <code>self</code>，而静态方法没有这样的隐式传递参数，所以它在方法定义时不需要 <code>self</code> 参数。</p>
</li>
<li>
<p><strong>不能访问实例属性</strong>：由于静态方法与类的实例无关，它不能访问实例属性或实例方法。</p>
</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    class_variable = <span class="number">10</span>  <span class="comment"># 类级别的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.x = x  <span class="comment"># 实例属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">static_method</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;This is a static method.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用静态方法，不需要实例化类对象</span></span><br><span class="line">MyClass.static_method()  <span class="comment"># Output: This is a static method.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类的实例</span></span><br><span class="line">obj = MyClass(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态方法仍然可以通过类名调用</span></span><br><span class="line">obj.static_method()  <span class="comment"># Output: This is a static method.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态方法不能访问实例属性</span></span><br><span class="line"><span class="built_in">print</span>(obj.x)  <span class="comment"># Output: 5</span></span><br></pre></td></tr></table></figure>
<p>总结：<code>@staticmethod</code>装饰器用于定义静态方法，它可以通过类名直接调用，不需要实例化类对象，且在方法体内不能访问实例属性。静态方法在类的实例无关的情况下使用，常用于实现与类相关的工具函数或辅助函数。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>To_Do_List</title>
    <url>/post/6ab2dd9e.html</url>
    <content><![CDATA[<h1 id="center-nju课程"><center> NJU课程</h1>
<h2 id="概率论与数理统计">概率论与数理统计</h2>
<ul>
<li>
<p>作业为书上习题 两周一交</p>
</li>
<li>
<p>南大教材</p>
</li>
<li>
<p>作业会比较严格----每个双周的周三~周日交作业</p>
</li>
</ul>
<h2 id="ds">DS</h2>
<ul>
<li>
<p>oj+qq群布置的手写作业</p>
</li>
<li>
<p>书籍：数据结构与算法分析</p>
</li>
</ul>
<h2 id="并发算法与理论">并发算法与理论</h2>
<h4 id="课程主页"><a href="https://hongjin-liang.github.io/teaching/concurrency/">课程主页</a></h4>
<ul>
<li>ppt在课程主页上</li>
<li>教材《多处理器编程的艺术》</li>
<li>
<h3 id="考核：提交作业-course-report">考核：提交作业 + course report</h3>
</li>
</ul>
<h2 id="最优化方法导论">最优化方法导论</h2>
<h4 id="课程主页"><a href="https://www.lamda.nju.edu.cn/wuly/optfall2023/index.html">课程主页</a></h4>
<ul>
<li>Lecture Notes will be updated after every lesson</li>
<li>Referrence: Convex Optimization, Stephen Boyd and Lieven Vandenberghe</li>
</ul>
<h3 id="课程笔记">课程笔记</h3>
<ul>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/507328276">【矩阵论】范数</a></p>
</li>
<li>
<h3 id="考核-hw-40-final-exam-60">考核: HW:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>40</mn></mrow><annotation encoding="application/x-tex">40</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span><span class="mord">0</span></span></span></span> Final Exam:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>60</mn></mrow><annotation encoding="application/x-tex">60</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">0</span></span></span></span></h3>
</li>
</ul>
<h2 id="密码学原理">密码学原理</h2>
<p><img src="./image/002.png" alt=""></p>
<img src= "002.png" width="60%" length="60%">
<ul>
<li>ppt + 教材</li>
<li>
<h3 id="考核-6-hw-2-exam">考核:  6* HW + 2* exam</h3>
</li>
</ul>
<h2 id="人工智能导论">人工智能导论</h2>
<h3 id="课程主页"><a href="https://www.lamda.nju.edu.cn/introai/">课程主页</a></h3>
<ul>
<li>
<p>教材《人工智能一种现代的方法》-AIMA</p>
</li>
<li>
<p>学习新的游戏框架</p>
</li>
<li>
<h3 id="考核：4-1-lab-期末论文">考核：4+1 LAB + 期末论文</h3>
</li>
</ul>
<h2 id="搜索与演化算法">搜索与演化算法</h2>
<h3 id="课程主页"><a href="https://www.lamda.nju.edu.cn/HSEA23/">课程主页</a></h3>
<h3 id="考核-hw-60-final-exam-40">考核: HW(60%) + Final Exam(40%)</h3>
<h2 id="科研实践">科研实践</h2>
<ul>
<li>
<p>微信群通知 + 组会</p>
</li>
<li>
<p>读论文+实践</p>
</li>
</ul>
<hr>
<h1 id="center-to-do-list"><center> To do list</h1>
<h3 id="机器学习">机器学习</h3>
<ul>
<li>吴恩达课程  ✔</li>
<li>书籍</li>
<li>CS229</li>
</ul>
<h3 id="python学习">python学习</h3>
<ul>
<li>NunPy</li>
<li>Pytorch</li>
</ul>
<h3 id="c-学习">c++学习</h3>
<ul>
<li>异常及其处理 ✔</li>
<li>调试方法</li>
<li>线程管理</li>
</ul>
<h3 id="科研实践">科研实践</h3>
<ul>
<li>图像处理与检测</li>
</ul>
<h3 id="xcpc-acm">xcpc-acm</h3>
<ul>
<li>hdu_03 1002 1004 1008</li>
<li>牛客_04 B</li>
<li>hdu_09 1002 1008 1011</li>
</ul>
<h1 id="center-科研实践"><center> 科研实践</h1>
<h3 id="英文：">英文：</h3>
<p>Latent Diffusion论文：<a href="https://arxiv.org/pdf/2112.10752.pdf">https://arxiv.org/pdf/2112.10752.pdf</a></p>
<p>Diffusion Models详细公式：<a href="https://lilianweng.github.io/posts/2021-07-11-diffusion-models/">https://lilianweng.github.io/posts/2021-07-11-diffusion-models/</a></p>
<p>各种微调模型方法对比：<a href="https://www.youtube.com/watch?v=dVjMiJsuR5o">https://www.youtube.com/watch?v=dVjMiJsuR5o</a></p>
<p>Scheduler对比图来自论文: <a href="https://arxiv.org/pdf/2102.09672.pdf">https://arxiv.org/pdf/2102.09672.pdf</a></p>
<p>VAE结构图出处：<a href="https://towardsdatascience.com/vae-variational-autoencoders-how-to-employ-neural-networks-to-generate-new-images-bdeb216ed2c0">https://towardsdatascience.com/vae-variational-autoencoders-how-to-employ-neural-networks-to-generate-new-images-bdeb216ed2c0</a></p>
<p>柯基图来自DALLE2论文：<a href="https://cdn.openai.com/papers/dall-e-2.pdf">https://cdn.openai.com/papers/dall-e-2.pdf</a></p>
<p>CLIP模型的介绍：<a href="https://github.com/openai/CLIP">https://github.com/openai/CLIP</a></p>
<p>OpenCLIP：<a href="https://github.com/mlfoundations/open_clip">https://github.com/mlfoundations/open_clip</a></p>
<p>Textual Inversion: <a href="https://textual-inversion.github.io/">https://textual-inversion.github.io/</a></p>
<p>LoRA论文：<a href="https://arxiv.org/pdf/2106.09685.pdf">https://arxiv.org/pdf/2106.09685.pdf</a></p>
<p>Dreambooth 论文：<a href="https://arxiv.org/pdf/2208.12242.pdf">https://arxiv.org/pdf/2208.12242.pdf</a></p>
<p>ControlNet 论文：<a href="https://arxiv.org/pdf/2302.05543.pdf">https://arxiv.org/pdf/2302.05543.pdf</a></p>
<p>简单易懂的 Diffusion Model 解释：<a href="https://www.youtube.com/watch?v=1CIpzeNxIhU">https://www.youtube.com/watch?v=1CIpzeNxIhU</a></p>
<p>很棒的Stable Diffusion解释：<a href="https://jalammar.github.io/illustrated-stable-diffusion/">https://jalammar.github.io/illustrated-stable-diffusion/</a></p>
<p>同样很棒的SD解释：<a href="https://medium.com/@steinsfu/stable-diffusion-clearly-explained-ed008044e07e">https://medium.com/@steinsfu/stable-diffusion-clearly-explained-ed008044e07e</a></p>
<h3 id="中文：">中文：</h3>
<h4 id="stable-diffusion-unet-结构：https-zhuanlan-zhihu-com-p-582266032">Stable Diffusion UNET 结构：<a href="https://zhuanlan.zhihu.com/p/582266032">https://zhuanlan.zhihu.com/p/582266032</a></h4>
<ul>
<li>需要注意的是，在整个 UNET 执行一次的过程中，timestep_embedding 和 content embedding 始终保持不变。而在 UNET 反复执行多次的过程中，timestep_embedding 每次都会发生变化，而 content embedding 始终保持不变。在迭代过程中，每次 UNET 输出的 noise_slice 都原有的 latent 向量相减，作为下次迭代时，UNET 的 Latent 输入。</li>
</ul>
<img src="001.png" width="100%" length="100%">
<h4 id="很棒的stable-diffusion解释：https-blog-csdn-net-yujianmin1990-article-details-129143157">很棒的Stable Diffusion解释：<a href="https://blog.csdn.net/yujianmin1990/article/details/129143157">https://blog.csdn.net/yujianmin1990/article/details/129143157</a></h4>
<ul>
<li>采样噪声被预测了出来，所以如果我们从图像中减去它就能得到尽可能接近于模型训练样本的图像（不是精准的图像本身，而是分布，像素分布的世界里呈现起来天空通常是蓝色，人类有两个眼，小猫看向某个方向，耳朵竖起且专注）。</li>
</ul>
<h3 id="stable-diffusion非常详细的介绍：https-zhuanlan-zhihu-com-p-621493124">Stable Diffusion非常详细的介绍：<a href="https://zhuanlan.zhihu.com/p/621493124">https://zhuanlan.zhihu.com/p/621493124</a></h3>
<img src="6.png" width="60%" height="60%">
<ul>
<li>
<p>第一步，Prompt Encoder过程（Text Encoder）<br>
模型将潜在空间的随机种子和文本提示词（Prompt）同时作为输入，然后使用潜在空间的种子生成大小为64×64的随机潜在图像表示，通过CLIP的文本编码器将输入的文本提示转换为大小为77×768的文本嵌入。</p>
</li>
<li>
<p>第二步，使用U-Net进行Diffusion过程<br>
使用经过修改，含注意力机制的U-Net，在接受文本嵌入作为注意力机制计算对象的同时迭代地对随机潜在图像表示进行去噪。 U-Net 的输出是噪声的残差，用于通过scheduler 程序算法计算去噪的潜在图像表示。 scheduler 算法根据先前的噪声表示和预测的噪声残差计算预测的去噪图像表示。去噪过程重复约50-100次，这样可以逐步检索更好的潜在图像表示。许多不同的 scheduler 算法可以用于这个计算，每一个都有它的优点和缺点。对于Stable Diffusion，可以使用包括 PNDM scheduler、DDIM scheduler+PLMS、K-LMS scheduler等。</p>
</li>
<li>
<p>第三步，潜在图片通过VAE进行解码<br>
一旦上面步骤完成，潜在图像表示就会由变分自编码器的解码器部分进行解码，输出图片，步骤完成。</p>
</li>
</ul>
<p>（上面三个步骤的主要工作流程图）</p>
<img src="003.png" width="100%" height="100%">
<h4 id="万字长文讲解stable-diffusion的ai绘画基本技术原理"><a href="https://zhuanlan.zhihu.com/p/621493124">万字长文讲解Stable Diffusion的AI绘画基本技术原理</a></h4>
<ul>
<li>关于stablediffusion较底层的原理可以查看上面这篇文章，文末附有各个组件的原始论文+源码。</li>
</ul>
<hr>
<ol>
<li>公开课｜吴恩达 CS229</li>
</ol>
<p>吴恩达在斯坦福教授的机器学习课程 CS229 与 吴恩达在 Coursera 上的《Machine Learning》相似，但是有更多的数学要求和公式的推导，难度稍难一些。该课程对机器学习和统计模式识别进行了广泛的介绍。</p>
<p>课程主页： <a href="http://cs229.stanford.edu/">http://cs229.stanford.edu/</a><br>
中文视频： <a href="http://open.163.com/special/opencourse/machinelearning.html">http://open.163.com/special/opencourse/machinelearning.html</a><br>
中文笔记： <a href="https://kivy-cn.github.io/Stanford-CS-229-CN/#/">https://kivy-cn.github.io/Stanford-CS-229-CN/#/</a><br>
速查表： 这份资源贡献者是一名斯坦福的毕业生 Shervine Amidi。作者整理了一份超级详细的关于 CS229的速查表 <a href="https://zhuanlan.zhihu.com/p/56534902">https://zhuanlan.zhihu.com/p/56534902</a><br>
作业代码： <a href="https://github.com/Sierkinhane/CS229-ML-Implements">https://github.com/Sierkinhane/CS229-ML-Implements</a></p>
<ol start="3">
<li>公开课｜李宏毅机器学习</li>
</ol>
<p>课程主页： 最新2021年课程 <a href="https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html">https://speech.ee.ntu.edu.tw/~hylee/ml/2021-spring.html</a><br>
BiliBili： <a href="https://www.bilibili.com/video/BV1JE411g7XF?from=search&amp;seid=4319647467302480504&amp;spm_id_from=333.337.0.0">https://www.bilibili.com/video/BV1JE411g7XF?from=search&amp;seid=4319647467302480504&amp;spm_id_from=333.337.0.0</a><br>
学习笔记： <a href="https://github.com/datawhalechina/leeml-notes">https://github.com/datawhalechina/leeml-notes</a><br>
教学视频作为入门是绝佳的，但是口语化的教学不利于学习过程中对细节的考究，因此后面推荐一些书籍。</p>
<ol start="4">
<li>书籍｜《机器学习》</li>
</ol>
<p>周志华的《机器学习》被大家亲切地称为“西瓜书”。这本书非常经典，讲述了机器学习核心数学理论和算法，适合有作为学校的教材或者中阶读者自学使用，入门时学习这本书籍难度稍微偏高了一些。</p>
<p>读书笔记： <a href="https://www.cnblogs.com/limitlessun/p/8505647.html#_label0">https://www.cnblogs.com/limitlessun/p/8505647.html#_label0</a><br>
公式推导： <a href="https://datawhalechina.github.io/pumpkin-book/#/">https://datawhalechina.github.io/pumpkin-book/#/</a><br>
课后习题： <a href="https://zhuanlan.zhihu.com/c_1013850291887845376">https://zhuanlan.zhihu.com/c_1013850291887845376</a></p>
]]></content>
      <tags>
        <tag>catalog</tag>
      </tags>
  </entry>
  <entry>
    <title>effctive c++ tips</title>
    <url>/post/a20e8ec8.html</url>
    <content><![CDATA[<h2 id="1-除非有好的理由允许构造函数隐式转换-否则申明构造函数为explicit">1. 除非有好的理由允许构造函数隐式转换，否则申明构造函数为explicit</h2>
<hr>
<h2 id="2-default构造函数-copy构造函数-copy-assignment操作符">2. default构造函数，copy构造函数，copy assignment操作符</h2>
<p>新对象被定义一定有个构造函数被调用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Class w1;<span class="comment">//default </span></span><br><span class="line"><span class="function">Class <span class="title">w2</span><span class="params">(w1)</span></span>;<span class="comment">//copy构造</span></span><br><span class="line">Class w1=w1;<span class="comment">//copy赋值操作符</span></span><br><span class="line">Class w3=w2;<span class="comment">//copy构造</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-类中声明常量">3. 类中声明常量</h2>
<p>为确保此常量只有一个实例，用static</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> Num=<span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时也可以使用enum</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span>&#123;</span><br><span class="line">    <span class="keyword">enum</span>&#123;Num=<span class="number">5</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enum特征：</p>
<ol>
<li>enum和define一样不允许指针指向自己，绝不会导致不必要的内存分配</li>
<li>实用主义，很多代码用了它</li>
</ol>
<hr>
<h2 id="4-const食用技巧">4. const食用技巧</h2>
<ul>
<li>
<h3 id="1-const对象只能调用const成员函数-不能调用非const成员函数；非const对象可以调用const成员函数">1. const对象只能调用const成员函数、不能调用非const成员函数；非const对象可以调用const成员函数</h3>
</li>
</ul>
<h3 id="引发原因：-由调用成员函数时隐式传入的当前对象的this指针引起">引发原因： 由调用成员函数时隐式传入的当前对象的this指针引起。</h3>
<blockquote>
<p>1、 非<code>const</code>成员函数中的隐式参数：classA* this</p>
</blockquote>
<blockquote>
<p>2、 <code>const</code>成员函数中的隐式参数：<code>const classA* this</code></p>
</blockquote>
<h3 id="根本原因：">根本原因：</h3>
<blockquote>
<p>1、 <code>const</code>对象的指针为<code>const classA* this</code>，因此传入非const成员函数时编译器报错（类型不匹配，无法从const 指针转换为非const指针）；但传入const成员函数则类型匹配。</p>
</blockquote>
<blockquote>
<p>2、非<code>const</code>对象的指针为<code>classA* this</code>，可以调用const成员函数，因为const修饰符保证了不会修改该对象。</p>
</blockquote>
<p>所以对于const对象可能调用的函数，可以直接加个const函数重载，c++支持const函数重载。</p>
<ul>
<li>
<h3 id="2-类中使用mutable定义-这样在const成员函数中可以修改其值">2. 类中使用mutable定义，这样在const成员函数中可以修改其值</h3>
</li>
<li>
<h3 id="3-const类不能作为按地址形式传入non-const函数中">3. const类不能作为按地址形式传入non-const函数中</h3>
</li>
<li>
<h3 id="4-对operator-使用const-防止如a-b-c的意外引用">4. 对operator * 使用const，防止如<code>a*b=c</code>的意外引用</h3>
</li>
</ul>
<hr>
<h2 id="5-make-sure-that-objects-are-initialzed-before-they-re-used">5. Make sure that objects are initialzed before they’re used</h2>
<blockquote>
<p>建议永远使用<code>member initialization list</code>。（就算没有任何额外赋值，也建议在初始化成员列表里手动调用default或对内置数据类型附初值）</p>
</blockquote>
<blockquote>
<p>实际上，构造函数在运行前会对所有类成员调用default构造一遍，这样花费了不必要的时间开销。况且，如const常量一定需要初始值，而不能被赋值。</p>
</blockquote>
<hr>
<h2 id="6-构造-析构-赋值运算">6. 构造/析构/赋值运算</h2>
<ul>
<li>
<h3 id="1-只要你写了一个构造函数-default版构造函数就不会创建">1. 只要你写了一个构造函数，default版构造函数就不会创建</h3>
</li>
<li>
<h3 id="2-当类中有const成员-引用成员-string-或者base-class的赋值操作符是private-那么编译器拒绝生成默认operator">2. 当类中有const成员，引用成员(string&amp;),或者base class的赋值操作符是private，那么编译器拒绝生成默认operator=。</h3>
</li>
<li>
<h3 id="3-不想编译器自动生成函数-可以-delete">3. 不想编译器自动生成函数，可以<code>=delete</code></h3>
</li>
<li>
<h3 id="4-心得：只有当class内至少含有一个virtual函数-才为它声明virtual析构函数-virtual函数会开一个虚函数表占用内存-同时因为stl标准库里全是non-virtual-所以一般不将其作为base-class继承">4. 心得：只有当class内至少含有一个virtual函数，才为它声明virtual析构函数（virtual函数会开一个虚函数表占用内存）,同时因为STL标准库里全是non-virtual，所以一般不将其作为base class继承。</h3>
</li>
<li>
<h3 id="5-在虚析构函数继承时需要对虚析构函数提供实现">5. 在虚析构函数继承时需要对虚析构函数提供实现.</h3>
</li>
</ul>
<blockquote>
<p>因为当我们不定义虚构函数的时候，编译器会默认生成一个什么都不做的析构函数，但是注意了默认生成的析构函数就是普通函数不是虚函数！！！（因为虚函数会带来额外开销，c++追求的是速度），所以指望不上编译器自动生成虚构函数，而析构时又一定会调用，所以需要我们手动实现虚析构函数的实现。</p>
</blockquote>
<hr>
<h2 id="7-在构造函数和析构函数间不调用virtual函数">7.在构造函数和析构函数间不调用virtual函数。</h2>
<blockquote>
<p>因为这类调用从不下降至derived class。（需要的话可以用static函数从derived class传参向base class的构造函数，并在base里用non-virtual函数接收并按照接收参数的不同做出不同response。</p>
</blockquote>
<hr>
<h2 id="8-让operator-返回一个reference-to-this">8. 让operator=返回一个reference to *this</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span> =(<span class="type">const</span> Widget&amp; rhs)&#123;</span><br><span class="line">    <span class="comment">//******</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一方面可以实现连等，另一方面这样的协议被STL共同遵守。</p>
<hr>
<h2 id="9-以对象为资源管理-rall-resource-acquisition-is-initializaion">9. 以对象为资源管理(RALL(resource acquisition is initializaion))</h2>
<ul>
<li>
<h3 id="1-获得资源后立刻放进管理对象-如使用auto-ptr">1. 获得资源后立刻放进管理对象（如使用auto_ptr）</h3>
</li>
<li>
<h3 id="2-管理对象-managing-object-运用析构函数确保资源被释放">2. 管理对象(managing object)运用析构函数确保资源被释放</h3>
</li>
</ul>
<p>以防止开的空间在delete前因各种原因中端而导致内存泄漏<br>
auto_ptr一般用在heap_based资源</p>
<hr>
<h2 id="10-rall对象的copy行为">10. RALL对象的copy行为</h2>
<ul>
<li>
<h3 id="1-方法1：抑制copying-用private写copy">1. 方法1：抑制copying（用private写copy）</h3>
</li>
<li>
<h3 id="2-方法2：施行引用计数法-tr1-shared-ptr-可以以一个函数对象为第二参数-在计数为0时调用其">2. 方法2：施行引用计数法(tr1::shared_ptr,可以以一个函数对象为第二参数，在计数为0时调用其)</h3>
</li>
</ul>
<hr>
<h2 id="11-资源管理类中提供对原始资源的访问">11. 资源管理类中提供对原始资源的访问</h2>
<p>我们用RALL类将对象装在类中防止内存泄漏发生，但是一些api要求原始的数据进行传参，这时就需要提供对原始资源的访问</p>
<blockquote>
<p>对于智能指针<code>pINv.get()</code>即可调用其储存的原始资源</p>
</blockquote>
<blockquote>
<p>对于其他某些RALL类要么提供显式转换函数(如上)，要么提供隐式转换函数(<code>operator type()</code>)</p>
</blockquote>
<hr>
<h2 id="12-成对使用new和delete时要采用相同的形式">12. 成对使用new和delete时要采用相同的形式</h2>
<hr>
<h2 id="13-以独立语句将newed对象置于智能指针中">13. 以独立语句将newed对象置于智能指针中</h2>
<blockquote>
<p>这样在new对象创立到将对象存进RALL中没有其他语句干扰，防止难以察觉的资源泄露（可能其他语句会中断，导致只创立了new对象没放到RALL类里面）</p>
</blockquote>
<hr>
<h2 id="14-让接口更容易被使用">14. 让接口更容易被使用</h2>
<blockquote>
<ul>
<li>接口的一致性，与内置类型的行为兼容</li>
<li>“阻止误用”的办法包括建立新类型、限制类型上的操作、束缚对象值，以及消除客户的资源管理责任。</li>
<li><code>c++ tr1::shared_ptr</code>支持定制型删除器。</li>
</ul>
</blockquote>
<hr>
<h2 id="15-类型转化">15. 类型转化</h2>
<blockquote>
<pre><code>       T1 ---&gt; T2
</code></pre>
<ul>
<li>在T1中写一个类型转换函数（operator T2）???</li>
<li>或在T2中写一个non-explicit-one-aegument的构造函数</li>
</ul>
</blockquote>
<hr>
<h2 id="16-尽可能用pass-by-reference-to-const替换pass-by-value">16. 尽可能用pass-by-reference-to-const替换pass-by-value</h2>
<blockquote>
<p>第一，效率更好。第二，解决继承时的切割(slicing)问题<br>
以上规则不适用于内置数据类型和STL</p>
</blockquote>
<hr>
<h2 id="17-返回值reference和object之间的抉择">17. 返回值reference和object之间的抉择</h2>
<blockquote>
<p>绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个local-allocated对象。</p>
</blockquote>
<hr>
<h2 id="18-将成员变量设计为private">18. 将成员变量设计为private</h2>
<blockquote>
<p>切记将成员变量设计成private，好处：1. 访问数据的一致性 2. 可以细微划分访问时的控制权限 3. 提供class作者充分的实现弹性。</p>
</blockquote>
<blockquote>
<p>protected 并不比public 更具备封装性</p>
</blockquote>
<hr>
<h2 id="19-prefer拿non-member-non-friend函数替换member函数">19. prefer拿non-member non-friend函数替换member函数。</h2>
<p>可以增加封装性，包裹弹性，和机能拓展性。</p>
<blockquote>
<p>越少的函数能直接调用私有数据，封装性越好</p>
</blockquote>
<blockquote>
<p>将多个功能函数（如clear功能、cookie功能）放在多个头文件但隶属于同一个命名空间，可以轻松拓展这些功能函数。（namespace可以跨越多个源码文件）</p>
</blockquote>
<hr>
<h2 id="20-non-member函数">20. non-member函数</h2>
<p>如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是non-member。</p>
<p>最常见的是operator重载运算，因为this指针无法进行隐式类型转换，所以有必要变成non-member函数。但是是不是要friend是不一定的。不能只因函数不该是member，就让它自动成为friend。</p>
<hr>
<h2 id="21-swap的实现">21. swap的实现</h2>
<ul>
<li>当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常。</li>
<li>如果你提供一个member swap，也提供一个non-member swap用来调用前者。对于classes（而非templates），也要特化std::swap&gt;</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Widget&amp; other)</span></span>&#123;</span><br><span class="line">        <span class="keyword">using</span> std::swap;</span><br><span class="line">        <span class="built_in">swap</span>(Ptr,other.Ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">swap</span>&lt;Widget&gt;(Widget&amp; a,Widget&amp; b)&#123;</span><br><span class="line">        a.<span class="built_in">swap</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>调用swap时加上using std::swap，然后调用的时候不带任何“命名空间资格修饰”。</p>
</li>
<li>
<p>swap调用顺序： 1：class专属的swap 2：std::swap内的专属特化版 3：默认版std::swap。</p>
</li>
</ul>
<hr>
<h2 id="22-尽可能延后变量定义式的出现时间">22. 尽可能延后变量定义式的出现时间</h2>
<p>不只因该延后到非得使用该变量为止，甚至应该尝试延后这份定义知道能够给它初值实参为止。</p>
<p>不仅可以避免构造非必要对象，还可以避免无意义的default构造行为，更深一层说，以“具有明显意义之初值”将变量初始化还可以附带说明变量的目的。</p>
<hr>
<h2 id="23-c-转型操作">23. c++转型操作</h2>
<ul>
<li>
<h3 id="宁可用c-style转型-不使用旧式转型-前者很容易被分辨出来-而且作用更加细化">宁可用c++style转型，不使用旧式转型，前者很容易被分辨出来，而且作用更加细化</h3>
</li>
</ul>
<blockquote>
<p>const_cast 用来将对象的常量性移除</p>
<p>dynamic_cast 用来“安全向下转型”，也就是用来决定某对象是否归属继承体系中的<br>
某个类型。</p>
<p>reinterpret_cast 低级转型，e.g. 将pointer to int转为int</p>
<p>static_cast 强迫隐式转型</p>
</blockquote>
<ul>
<li>
<h3 id="使用旧式转型的唯一时机：调用一个explicit构造函数将一个对象传递给一个函数时">使用旧式转型的唯一时机：调用一个explicit构造函数将一个对象传递给一个函数时。</h3>
</li>
<li>
<h3 id="单个对象-如一个derived类-可以拥有一个以上的地址-所以不要以为-转型什么都没做-只是告诉编译器把某种类型视为另一种类型">单个对象（如一个derived类）可以拥有一个以上的地址，所以不要以为“转型什么都没做，只是告诉编译器把某种类型视为另一种类型“）</h3>
</li>
<li>
<h3 id="如果可以-尽量避免转型-如指针动态链接-或virtual函数">如果可以，尽量避免转型。（如指针动态链接，或virtual函数）</h3>
</li>
</ul>
<hr>
<h2 id="24-避免返回handles-reference-指针-迭代器-指向对象内部成分">24. 避免返回handles(reference,指针，迭代器)指向对象内部成分</h2>
<ul>
<li>可增加封装性，帮助const成员函数行为像一个const。</li>
<li>降低出现“虚吊号牌”(dangling handles)的可能性。（对象先寄了，导致成员赋值的内部指针虚吊。）</li>
</ul>
<hr>
<h2 id="25-关于inline">25. 关于inline</h2>
<ul>
<li>好处，调用其不用承受函数的额外开支</li>
<li>inline将“对此函数的每一个调用”都一函数本体来替换之。但是，可能会造成代码膨胀，降低高速缓存的集中率。</li>
<li>注意：将函数定义在class定义式中会隐式变成inline</li>
<li>virtual和inline不兼容，因为virtual意味着等待，运行阶段才能确定。而inline意味着执行前替换。</li>
<li>构造和析构函数往往不适合inline，哪怕是空的构造函数，编译器也会产生一定分量的代码，这样的inline往往会使代买膨胀。</li>
<li>inline内容一旦改，意味着所有用到f的内容都要重新编译，如果不用inline，重新链接即可。</li>
<li>将大多数inline限制在小型的，被频繁调用的函数身上。</li>
</ul>
<hr>
<h2 id="26-减小声明式的依赖性">26.减小声明式的依赖性</h2>
<ul>
<li>
<p>能使用object reference或者object pointer，就不要使用object。（因为如果定义某类型的object，会需要其定义式。</p>
</li>
<li>
<p>如果可以，尽量以class声明式替换class的定义式。</p>
<blockquote>
<p>注意，当你声明一个函数而用到某个class时，你并不需要其class的定义式，即使该函数以by value方式传递该class的参数(或者返回值)。</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">date</span>;</span><br><span class="line"><span class="function">date <span class="title">Today</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClearAppointments</span><span class="params">(date d)</span></span>;</span><br><span class="line"><span class="comment">//合法的</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="27-public继承塑模出is-a关系">27. public继承塑模出is-a关系</h2>
<p>适用于base的每一件事也一定适用于derived身上，因为每一个derived也是一个base。</p>
<p>e.g. bird类里fly函数。但是Penguin is a bird，但是不会fly。所以bird类里不能放fly函数。</p>
<hr>
<h2 id="28-避免遮盖继承而来的名称">28. 避免遮盖继承而来的名称</h2>
<ul>
<li>
<p>derived class内的名称会遮盖base class内的名称。在public继承下从来没有人希望如此。</p>
</li>
<li>
<p>为了让被遮盖的名称重见天日，可以使用<code>using声明式</code>或者<code>转交函数(forwarding function)</code>。</p>
</li>
</ul>
<hr>
<h2 id="29-接口继承与实现继承">29. 接口继承与实现继承</h2>
<ul>
<li>对于base class为真的任何事一定对其derived class也为真。因此每个函数可以用于class上，也一定可以用于derived class上。</li>
<li>声明一个pure virtual函数的目的是为了让derived classes只继承函数接口。（不干涉derived怎么实现它）</li>
<li>声明impure derived函数的目的，是让derived class继承该函数的接口和<strong>缺省实现</strong>。（default版直接用域名解析调用）</li>
<li>pure virtual函数也可以被实现，用来当缺省实现。</li>
<li>non-virtual 函数的目的是为了令derived class继承函数的接口及一份强制性的实现。</li>
</ul>
<h2 id="30-考虑用设计模式替换virtual函数">30. 考虑用设计模式替换virtual函数</h2>
<p>介绍两种设计模式，NVI(non-virtial interface)，主张将所有virtual设计为private。Strategy设计模式，用函数指针或者古典strategy，另外开个类。</p>
<p>因为是关于设计模式的介绍，详细可以看他人的 <strong><a href="https://blog.csdn.net/CltCj/article/details/128432338">博客分享</a></strong>。</p>
<hr>
<h2 id="31-绝不重新定义继承而来的non-virtual函数">31. 绝不重新定义继承而来的non-virtual函数</h2>
<ul>
<li>
<p>non-virtual函数为静态绑定，也就是说pointer-to-base永远调用的是base版本，即使其指向一个derived类。一个简单的例子是为什么多态中析构函数都是virtual：虚析构函数为了避免内存泄露,基类的析构函数一般都是虚函数。 如果基类析构函数不是虚函数:基类指针指向子类对象,delete基类指针,调用基类析构函数,不会调用子类析构函数,造成内存泄露。</p>
</li>
<li>
<p>non-virtual函数的不变性高于其特异性。（public继承下，一切base的non-virtual都适用于所有的derived classes）</p>
</li>
</ul>
<hr>
<h2 id="32-绝不重新定义继承而来的缺省参数值">32. 绝不重新定义继承而来的缺省参数值</h2>
<p>理由很简单，virtual函数时动态绑定(dynamically bound)，而缺省参数值却是静态绑定。</p>
<p>所以如果使用多态时，重新定义了继承而来的缺省参数值，在动态绑定中，其默认参数却永远是base的，导致难以发现的错位。（继承中唯一该覆写的东西是virtual函数）</p>
<p>（如果想要统一默认参数，可以使用30条中的NVI设计模式。）</p>
<hr>
<h2 id="33-复合关系">33. 复合关系</h2>
<ul>
<li>在应用域(application domain)，复合意味着has-a。</li>
<li>在实现域(implementation domain)，复合意味着 is-implemented-in-terms-of（根据某物实现出）。e.g. 用std::list 实现SET。</li>
</ul>
<hr>
<h2 id="34-private继承">34. private继承</h2>
<p>public继承在必要时可（为了让函数调用成功），可以将derived类转成base，而private继承则不行。</p>
<p>private base 继承而来的所有东西都会在derived类中变成private属性。</p>
<ul>
<li><strong>private继承意味着只有实现部分被继承，接口部分应略去。如果D以private形式继承B，意思是D对象根据B对象实现而得，再没有其他意涵了。</strong></li>
</ul>
<p>复合(composition)比private继承 （都是is-implemented-in-terms-of）</p>
<ul>
<li>复合优点：阻止derived类重新定义接口、可以解耦</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span>&#123;</span><br><span class="line">    <span class="keyword">private</span>: </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">WidgetTimer</span>: <span class="keyword">public</span> Timer&#123;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onTick</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>private继承优点：当derived函数需要访问protected based class的成员、或需要重新定义继承而来的virtual函数。</li>
</ul>
<hr>
<h2 id="35-多重继承">35. 多重继承</h2>
<ul>
<li>多重继承比单一继承更复杂。它可能导致新的歧义性，以及对virtual继承的需要。</li>
<li>virtual继承会增加大小，速度，初始化复杂度成本。</li>
<li>多重继承的确有正当用途。比如：<code>&quot;public继承某个inteface class&quot;,&quot;private继承某个协助实现的class&quot;</code>的两两组合。</li>
</ul>
<hr>
<h2 id="36-隐式接口和编译器多态">36.隐式接口和编译器多态</h2>
<ul>
<li>class和template都支持接口和多态</li>
<li>对class而言接口是显示的，以函数签名为中心。多态则是通过virtual函数发生于运行期。</li>
<li>对template参数而言，接口是隐式的，奠基于有效表达式。多态则是通过template具现化和函数重载解析发生于编译期。</li>
</ul>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>git初步</title>
    <url>/post/91c7c6a1.html</url>
    <content><![CDATA[<h1 id="git基本命令">git基本命令</h1>
<h2 id="git详细介绍-使用">git详细介绍&amp;使用</h2>
<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">史上最浅显易懂的Git教程</a></p>
<h2 id="git指令简版总结">git指令简版总结</h2>


	<div class="row">
    <embed src="https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf" width="100%" height="550" type="application/pdf">
	</div>


]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux指令集</title>
    <url>/post/4de2ff1e.html</url>
    <content><![CDATA[<p>常见的Linux操作和命令：</p>
<ol>
<li>
<p><strong>文件和目录操作</strong>：</p>
<ul>
<li><code>ls</code>：列出当前目录的文件和子目录。</li>
<li><code>cd</code>：改变当前工作目录。</li>
<li><code>pwd</code>：显示当前工作目录的完整路径。</li>
<li><code>mkdir</code>：创建新目录。</li>
<li><code>touch</code>：创建新文件。</li>
<li><code>cp</code>：复制文件或目录。</li>
<li><code>mv</code>：移动或重命名文件或目录。</li>
<li><code>rm</code>：删除文件或目录。</li>
</ul>
</li>
<li>
<p><strong>文件查看和编辑</strong>：</p>
<ul>
<li><code>cat</code>：查看文件内容。</li>
<li><code>more</code> 或 <code>less</code>：分页查看文件内容。</li>
<li><code>nano</code> 或 <code>vim</code>：文本编辑器。</li>
<li><code>head</code> 和 <code>tail</code>：查看文件的开头和结尾部分。</li>
</ul>
</li>
<li>
<p><strong>系统信息</strong>：</p>
<ul>
<li><code>uname</code>：显示系统信息。</li>
<li><code>top</code> 或 <code>htop</code>：查看系统资源使用情况。</li>
<li><code>df</code>：显示磁盘空间使用情况。</li>
<li><code>free</code>：显示内存使用情况。</li>
</ul>
</li>
<li>
<p><strong>进程管理</strong>：</p>
<ul>
<li><code>ps</code>：列出当前正在运行的进程。</li>
<li><code>kill</code>：终止进程。</li>
<li><code>bg</code> 和 <code>fg</code>：在后台和前台运行进程。</li>
</ul>
</li>
<li>
<p><strong>用户和权限</strong>：</p>
<ul>
<li><code>sudo</code>：以超级用户权限运行命令。</li>
<li><code>useradd</code> 和 <code>userdel</code>：创建和删除用户。</li>
<li><code>passwd</code>：更改用户密码。</li>
<li><code>chmod</code>：更改文件和目录权限。</li>
<li><code>chown</code>：更改文件和目录的所有者。</li>
</ul>
</li>
<li>
<p><strong>包管理</strong>：</p>
<ul>
<li><code>apt</code> 或 <code>apt-get</code>：Debian/Ubuntu系统的包管理工具。</li>
<li><code>yum</code>：CentOS/RHEL系统的包管理工具。</li>
<li><code>dnf</code>：Fedora系统的包管理工具。</li>
</ul>
</li>
<li>
<p><strong>网络操作</strong>：</p>
<ul>
<li><code>ping</code>：测试与主机的网络连接。</li>
<li><code>ifconfig</code> 或 <code>ip</code>：查看和配置网络接口。</li>
<li><code>ssh</code>：远程登录其他计算机。</li>
<li><code>wget</code> 或 <code>curl</code>：下载文件或内容。</li>
</ul>
</li>
<li>
<p><strong>压缩和解压缩</strong>：</p>
<ul>
<li><code>tar</code>：打包和解包文件。</li>
<li><code>gzip</code> 和 <code>gunzip</code>：压缩和解压缩文件。</li>
<li><code>zip</code> 和 <code>unzip</code>：创建和解压ZIP文件。</li>
</ul>
</li>
<li>
<p><strong>查找文件</strong>：</p>
<ul>
<li><code>find</code>：按名称、类型等条件查找文件。</li>
<li><code>grep</code>：在文本文件中搜索特定字符串。</li>
</ul>
</li>
<li>
<p><strong>系统日志</strong>：</p>
<ul>
<li><code>dmesg</code>：显示系统消息日志。</li>
<li><code>journalctl</code>：查看systemd日志。</li>
</ul>
</li>
</ol>
<p>这只是Linux命令的一小部分，Linux系统非常强大且具有高度可定制性，可以根据需要执行各种任务。要了解有关特定命令的详细信息，你可以在终端中运行<code>man</code>命令，后跟命令名称，以查看其手册页。例如：<code>man ls</code> 或 <code>man mkdir</code>。这将提供有关该命令的详细信息和选项。</p>
]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>tips for vim</title>
    <url>/post/54b5cdaf.html</url>
    <content><![CDATA[<h1 id="一些tips">一些tips</h1>
<p>可以在settings里面自定义vim映射</p>


	<div class="row">
    <embed src="pdf/vim.pdf" width="100%" height="550" type="application/pdf">
	</div>



]]></content>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/post/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>python入门</title>
    <url>/post/15af28d0.html</url>
    <content><![CDATA[<h2 id="博客教程"><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">博客教程</a></h2>
<p>讲的比较细致也比较全面，适合新手入门。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>引用</title>
    <url>/post/c96f7df0.html</url>
    <content><![CDATA[<h1 id="center-博客指路-center"><center><a href="https://www.cnblogs.com/alex-gc/p/11165821.html">博客指路</a></center></h1>
]]></content>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能导论HW2黑白棋实验报告</title>
    <url>/post/97fe6ca1.html</url>
    <content><![CDATA[<h1 id="center-报告题目：黑白棋游戏-博弈算法-center"><center> 报告题目：黑白棋游戏&amp;博弈算法 </center></h1>
<h3 id="center-detect0530-gmail-com-center"><center>  <a href="mailto:detect0530@gmail.com">detect0530@gmail.com</a> </center></h3>
<h2 id="1-引言">1 引言</h2>
<p>过去曾有关注过博弈论的相关算法，比如那什均衡、博弈树。但是因为效率的担心，往往忽略了最为传统但又花样百出的搜索博弈。这次作业，我将尝试用搜索博弈的思维来考虑黑白棋游戏。</p>
<h2 id="2-实验内容">2 实验内容</h2>
<h3 id="2-1-task1-介绍minimax的实现">2.1 Task1 介绍minimax的实现</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">MiniMaxDecider</span><span class="params">(<span class="type">boolean</span> maximize, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.maximize = maximize;</span><br><span class="line">    <span class="built_in">this</span>.depth = depth;</span><br><span class="line">    computedStates = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;State, Float&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的maximize表示当前的决策者是最大化还是最小化，depth表示搜索的深度，computedStates表示已经计算过的状态，用HashMap进行存储。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Action <span class="title function_">decide</span><span class="params">(State state)</span> &#123;</span><br><span class="line">	<span class="comment">// Choose randomly between equally good options</span></span><br><span class="line">	<span class="type">float</span> <span class="variable">value</span> <span class="operator">=</span> maximize ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;</span><br><span class="line">	List&lt;Action&gt; bestActions = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Action&gt;();</span><br><span class="line">	<span class="comment">// Iterate!</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> maximize ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (Action action : state.getActions()) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Algorithm!</span></span><br><span class="line">			<span class="type">State</span> <span class="variable">newState</span> <span class="operator">=</span> action.applyTo(state);</span><br><span class="line">			<span class="type">float</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="built_in">this</span>.miniMaxRecursor(newState, <span class="number">1</span>, !<span class="built_in">this</span>.maximize);</span><br><span class="line">			<span class="comment">// Better candidates?</span></span><br><span class="line">			<span class="keyword">if</span> (flag * newValue &gt; flag * value) &#123;</span><br><span class="line">				value = newValue;</span><br><span class="line">				bestActions.clear();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Add it to the list of candidates?</span></span><br><span class="line">			<span class="keyword">if</span> (flag * newValue &gt;= flag * value) bestActions.add(action);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InvalidActionException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid action!&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If there are more than one best actions, pick one of the best randomly</span></span><br><span class="line">	Collections.shuffle(bestActions);</span><br><span class="line">	<span class="keyword">return</span> bestActions.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>c</mi><mi>i</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">decide</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span>函数决定当前走哪一步，方法很暴力，对于每种可能的走法都计算一遍minimax，取最大的即可。思想堪称朴实无华。</p>
<hr>
<p>接下来将详细解释关键的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>i</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>x</mi><mi>R</mi><mi>e</mi><mi>c</mi><mi>u</mi><mi>r</mi><mi>s</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">minimaxRecursor()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>函数:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">miniMaxRecursor</span><span class="params">(State state, <span class="type">int</span> depth, <span class="type">boolean</span> maximize)</span> &#123;</span><br><span class="line">	<span class="comment">// Has this state already been computed?</span></span><br><span class="line">	<span class="keyword">if</span> (computedStates.containsKey(state)) </span><br><span class="line">                   <span class="comment">// Return the stored result</span></span><br><span class="line">                   <span class="keyword">return</span> computedStates.get(state);</span><br><span class="line">	<span class="comment">// Is this state done?</span></span><br><span class="line">	<span class="keyword">if</span> (state.getStatus() != Status.Ongoing)</span><br><span class="line">                   <span class="comment">// Store and return</span></span><br><span class="line">                   <span class="keyword">return</span> finalize(state, state.heuristic());</span><br><span class="line">	<span class="comment">// Have we reached the end of the line?</span></span><br><span class="line">	<span class="keyword">if</span> (depth == <span class="built_in">this</span>.depth)</span><br><span class="line">                   <span class="comment">//Return the heuristic value</span></span><br><span class="line">                   <span class="keyword">return</span> state.heuristic();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>首先是如果当前状态我们已经算过了，那么直接返回上一次计算存在HashMap的值即可。</li>
<li>否则，如果状态结束或者深度到了我们指定的超参数Maxdep，也就停止搜索返回heuristic值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">value</span> <span class="operator">=</span> maximize ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;</span><br><span class="line">		<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> maximize ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">		List&lt;Action&gt; test = state.getActions();</span><br><span class="line">		<span class="keyword">for</span> (Action action : test) &#123;</span><br><span class="line">			<span class="comment">// Check it. Is it better? If so, keep it.</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">State</span> <span class="variable">childState</span> <span class="operator">=</span> action.applyTo(state);</span><br><span class="line">				<span class="type">float</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="built_in">this</span>.miniMaxRecursor(childState, depth + <span class="number">1</span>, !maximize);</span><br><span class="line">				<span class="comment">//Record the best value</span></span><br><span class="line">                <span class="keyword">if</span> (flag * newValue &gt; flag * value) </span><br><span class="line">                    value = newValue;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidActionException e) &#123;</span><br><span class="line">                            <span class="comment">//Should not go here</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid action!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Store so we don&#x27;t have to compute it again.</span></span><br><span class="line">    <span class="keyword">return</span> finalize(state, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码非常巧妙地利用maximize作为开来判断当前应该取最小值还是最大值，并且利用不等式两边同时乘以负一会变号的手段，保证了对于min和max情况下的代码一致性。</p>
<p>而整体结构依然是喜闻乐见的递归搜索，对于每一个可能的走法，都进行一次递归搜索，直到到达最大深度或者游戏结束。结构上倒没有什么特别之处。</p>
<hr>
<h3 id="2-2-task2-加入alpha-beta剪枝">2.2 Task2 加入alpha-beta剪枝</h3>
<p>第一步修改传参</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="built_in">this</span>.miniMaxRecursor(newState, <span class="number">1</span>, !<span class="built_in">this</span>.maximize,Float.NEGATIVE_INFINITY,Float.POSITIVE_INFINITY);</span><br></pre></td></tr></table></figure>
<p>这是修改剪枝后的主体部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">miniMaxRecursor</span><span class="params">(State state, <span class="type">int</span> depth, <span class="type">boolean</span> maximize,<span class="type">float</span> alpha,<span class="type">float</span> beta)</span> &#123;</span><br><span class="line">		<span class="comment">// Has this state already been computed?</span></span><br><span class="line">		<span class="keyword">if</span> (computedStates.containsKey(state))</span><br><span class="line">                    <span class="comment">// Return the stored result</span></span><br><span class="line">                    <span class="keyword">return</span> computedStates.get(state);</span><br><span class="line">		<span class="comment">// Is this state done?</span></span><br><span class="line">		<span class="keyword">if</span> (state.getStatus() != Status.Ongoing)</span><br><span class="line">                    <span class="comment">// Store and return</span></span><br><span class="line">                    <span class="keyword">return</span> finalize(state, state.heuristic());</span><br><span class="line">		<span class="comment">// Have we reached the end of the line?</span></span><br><span class="line">		<span class="keyword">if</span> (depth == <span class="built_in">this</span>.depth)</span><br><span class="line">                    <span class="comment">//Return the heuristic value</span></span><br><span class="line">                    <span class="keyword">return</span> state.heuristic();</span><br><span class="line">                </span><br><span class="line">		<span class="comment">// If not, recurse further. Identify the best actions to take.</span></span><br><span class="line">		<span class="type">float</span> <span class="variable">value</span> <span class="operator">=</span> maximize ? Float.NEGATIVE_INFINITY : Float.POSITIVE_INFINITY;</span><br><span class="line">		<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> maximize ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">		List&lt;Action&gt; test = state.getActions();</span><br><span class="line">		<span class="keyword">for</span> (Action action : test) &#123;</span><br><span class="line">			<span class="comment">// Check it. Is it better? If so, keep it.</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="type">State</span> <span class="variable">childState</span> <span class="operator">=</span> action.applyTo(state);</span><br><span class="line">				<span class="type">float</span> <span class="variable">newValue</span> <span class="operator">=</span> <span class="built_in">this</span>.miniMaxRecursor(childState, depth + <span class="number">1</span>, !maximize,alpha,beta);</span><br><span class="line">				<span class="comment">//Record the best value</span></span><br><span class="line">				<span class="keyword">if</span> (flag * newValue &gt; flag * value)&#123;</span><br><span class="line">					value = newValue;</span><br><span class="line">                    <span class="comment">//here!!!!!!!!!!!!!!!!!!!</span></span><br><span class="line">					<span class="keyword">if</span>(maximize)&#123;</span><br><span class="line">						<span class="keyword">if</span>(value&gt;alpha)&#123;</span><br><span class="line">							<span class="keyword">if</span>(value&gt;beta) <span class="keyword">return</span> finalize(state, value);</span><br><span class="line">							alpha = value;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span>&#123;</span><br><span class="line">						<span class="keyword">if</span>(value&lt;beta)&#123;</span><br><span class="line">							<span class="keyword">if</span>(value&lt;alpha) <span class="keyword">return</span> finalize(state, value);</span><br><span class="line">							beta = value;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">catch</span> (InvalidActionException e) &#123;</span><br><span class="line">                                <span class="comment">//Should not go here</span></span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Invalid action!&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Store so we don&#x27;t have to compute it again.</span></span><br><span class="line">		<span class="keyword">return</span> finalize(state, value);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><strong>经过调整搜索时的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">MaxDep</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span></span></span></span>，当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">MaxDep</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span></span></span></span>设为较大的值比如<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8</mn><mo separator="true">,</mo><mn>9</mn><mo separator="true">,</mo><mn>10</mn></mrow><annotation encoding="application/x-tex">8,9,10</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">8</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mord">0</span></span></span></span>，且在棋局稍微复杂的情况下，alpha-beta剪枝的效果非常明显，搜索时间从30s左右大大减少到3s。</strong></p>
<p>由此可见，alpha-beta剪枝的效果非常明显，能够大大减少搜索时间。</p>
<hr>
<h3 id="2-3-task3-理解并改进heuristic函数">2.3 Task3 理解并改进heuristic函数</h3>
<p>这是预先给出的heuristic函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">float</span> <span class="title function_">heuristic</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="comment">//System.out.printf(&quot;%f %f %f %f\n&quot;,this.pieceDifferential(), this.moveDifferential(), this.cornerDifferential(), this.stabilityDifferential());</span></span><br><span class="line">	<span class="type">Status</span> <span class="variable">s</span> <span class="operator">=</span> <span class="built_in">this</span>.getStatus();</span><br><span class="line">	<span class="type">int</span> <span class="variable">winconstant</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span> (s) &#123;</span><br><span class="line">	<span class="keyword">case</span> PlayerOneWon:</span><br><span class="line">		winconstant = <span class="number">5000</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> PlayerTwoWon:</span><br><span class="line">		winconstant = -<span class="number">5000</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		winconstant = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.pieceDifferential() +</span><br><span class="line">	   <span class="number">8</span> * <span class="built_in">this</span>.moveDifferential() +</span><br><span class="line">	  <span class="number">300</span> * <span class="built_in">this</span>.cornerDifferential() +</span><br><span class="line">	   <span class="number">1</span> * <span class="built_in">this</span>.stabilityDifferential() + </span><br><span class="line">	   winconstant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很直观朴素的计分方法：</p>
<ol>
<li>是否胜利 * 5000</li>
<li>棋子差距 * 1</li>
<li>可以下的位置数论差 * 8</li>
<li>四个角的棋子差 * 300</li>
<li>可以翻转的棋子的差 * 1</li>
</ol>
<p>总结一下，是基于棋子灵活度，棋子数量，以及棋子与棋盘的交互来计算的。</p>
<p>至于优化，我们可以更进一步也更智慧地思考以上问题。</p>
<p><img src="010.png" alt="Alt text"></p>
<ol start="6">
<li>既然四个角的棋子是最有价值的，那么我们不光关心自己拿到四个角，还要防止对手拿到四个角。于是对于白色叉的格子，我们拿到它只能帮助对手拿到四个角，于是我们对白叉格子赋值为-100。</li>
<li>对于边缘格子，其被取代的方式非常有限，于是我们也希望多拿一些边缘格子，赋值为10</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6,7条对应的函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> <span class="title function_">secondcorneDifferential</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">float</span> diff=<span class="number">0</span>;</span><br><span class="line">	<span class="type">short</span>[] corners = <span class="keyword">new</span> <span class="title class_">short</span>[<span class="number">4</span>];</span><br><span class="line">	corners[<span class="number">0</span>] = getSpotOnLine(hBoard[<span class="number">1</span>], (<span class="type">byte</span>)<span class="number">1</span>);</span><br><span class="line">	corners[<span class="number">1</span>] = getSpotOnLine(hBoard[<span class="number">1</span>], (<span class="type">byte</span>)(dimension - <span class="number">2</span>));</span><br><span class="line">	corners[<span class="number">2</span>] = getSpotOnLine(hBoard[dimension - <span class="number">2</span>], (<span class="type">byte</span>)<span class="number">1</span>);</span><br><span class="line">	corners[<span class="number">3</span>] = getSpotOnLine(hBoard[dimension - <span class="number">2</span>], (<span class="type">byte</span>)(dimension - <span class="number">2</span>));</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">short</span> corner : corners) <span class="keyword">if</span> (corner != <span class="number">0</span>) diff += corner == <span class="number">2</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="type">float</span> <span class="title function_">edgeDifferent</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">float</span> diff=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=dimension-<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="type">short</span> Left=getSpotOnLine(hBoard[i], (<span class="type">byte</span>)<span class="number">0</span>);</span><br><span class="line">		<span class="type">short</span> Right=getSpotOnLine(hBoard[i], (<span class="type">byte</span>)(dimension-<span class="number">1</span>));</span><br><span class="line">		diff += Left==<span class="number">2</span>?<span class="number">1</span>:-<span class="number">1</span>;diff+= Right==<span class="number">2</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=dimension-<span class="number">2</span>;i++)&#123;</span><br><span class="line">		<span class="type">short</span> Up=getSpotOnLine(hBoard[<span class="number">0</span>], (<span class="type">byte</span>)(i));</span><br><span class="line">		<span class="type">short</span> Down=getSpotOnLine(hBoard[dimension-<span class="number">1</span>], (<span class="type">byte</span>)(i));</span><br><span class="line">		diff+= Up==<span class="number">2</span>?<span class="number">1</span>:-<span class="number">1</span>;diff+= Down==<span class="number">2</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="011.png" alt="Alt text"></p>
<ol start="8">
<li>游戏开始后，在前面12步中，也就是抛开开局系统给出的四颗棋子外（红色方框1内），最好不要把棋子放在红色方框2之外。这个部分的宗旨是先占满方框2，把对方逼出方框。让我们有希望拿到边缘点。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">float</span> <span class="title function_">FirstDifferent</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">float</span> diff=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=dimension-<span class="number">3</span>;i++)&#123;</span><br><span class="line">			<span class="type">short</span> Left=getSpotOnLine(hBoard[i], (<span class="type">byte</span>)<span class="number">2</span>);</span><br><span class="line">			<span class="type">short</span> Right=getSpotOnLine(hBoard[i], (<span class="type">byte</span>)(dimension-<span class="number">3</span>));</span><br><span class="line">			diff += Left==<span class="number">2</span>?<span class="number">1</span>:-<span class="number">1</span>;diff+= Right==<span class="number">2</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=dimension-<span class="number">3</span>;i++)&#123;</span><br><span class="line">			<span class="type">short</span> Up=getSpotOnLine(hBoard[<span class="number">2</span>], (<span class="type">byte</span>)(i));</span><br><span class="line">			<span class="type">short</span> Down=getSpotOnLine(hBoard[dimension-<span class="number">3</span>], (<span class="type">byte</span>)(i));</span><br><span class="line">			diff+= Up==<span class="number">2</span>?<span class="number">1</span>:-<span class="number">1</span>;diff+= Down==<span class="number">2</span>?<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> diff;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>最后我们的heuristic函数长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.pieceDifferential() +</span><br><span class="line">		   <span class="number">8</span> * <span class="built_in">this</span>.moveDifferential() +</span><br><span class="line">		  <span class="number">300</span> * <span class="built_in">this</span>.cornerDifferential() +</span><br><span class="line">		   <span class="number">1</span> * <span class="built_in">this</span>.stabilityDifferential() +</span><br><span class="line">		        -<span class="number">100</span> * <span class="built_in">this</span>.secondcorneDifferential() +</span><br><span class="line">				<span class="number">10</span> * <span class="built_in">this</span>.edgeDifferent() +</span><br><span class="line">				<span class="number">5</span> * <span class="built_in">this</span>.FirstDifferent() +</span><br></pre></td></tr></table></figure>
<p>经过测试，确实能在游戏过程中很大程度上完成上述设置的要求，证明了我们的优化是有效的。</p>
<hr>
<h3 id="2-4-task4-mtd搜索法的分析">2.4 Task4 MTD搜索法的分析</h3>
<p>MTD-f 算法的全称是Memory-enhanced Test Driver，是一种搜索算法，它是一种迭代加深搜索算法，它的特点是在每次迭代中，都会使用一个零窗口搜索来确定当前的最佳值，然后使用这个值来作为下一次迭代的窗口的中心。</p>
<p>我们先从代码层理解MTD到底在做什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Action <span class="title function_">decide</span><span class="params">(State state)</span> &#123;</span><br><span class="line">	startTimeMillis = System.currentTimeMillis();</span><br><span class="line">	transpositionTable = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;State, SearchNode&gt;(<span class="number">10000</span>);</span><br><span class="line">	<span class="keyword">return</span> iterative_deepening(state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记录一个时钟，并记下转移过程中的索引表，这样遇到同样的位置就不用重新做一遍了。</p>
<p>接下来，进入迭代加深过程，在这个过程中，我们可以找到一个优秀的解法。</p>
<p>删掉一些无关紧要的部分：</p>
<p><strong>对代码的一些分析在注释里</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 对代码的一些分析在注释里</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> d;</span><br><span class="line"><span class="comment">//对于限定的深度下每一个深度都要跑一遍</span></span><br><span class="line"><span class="keyword">for</span> (d = <span class="number">1</span>; d &lt; maxdepth; d++) &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">alpha</span> <span class="operator">=</span> LOSE; <span class="type">int</span> <span class="variable">beta</span> <span class="operator">=</span> WIN; <span class="type">int</span> <span class="variable">actionsExplored</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (ActionValuePair a : actions) &#123;</span><br><span class="line">		<span class="comment">//枚举所有的actions，注意这里的actions有一个pair对，除了action动作外还有这个action下的最优value</span></span><br><span class="line">		State n;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			n = a.action.applyTo(root);</span><br><span class="line">			</span><br><span class="line">			<span class="type">int</span> value;</span><br><span class="line">			<span class="keyword">if</span> (USE_MTDF)</span><br><span class="line">			<span class="comment">//这里进入关键的MTDF评估函数，传入的参数是当前的状态，当前的最优值，当前的深度</span></span><br><span class="line">				value = MTDF(n, (<span class="type">int</span>) a.value, d);</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> maximizer ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">				value = -AlphaBetaWithMemory(n, -beta , -alpha, d - <span class="number">1</span>, -flag);</span><br><span class="line">			&#125;</span><br><span class="line">			actionsExplored++;</span><br><span class="line">			<span class="comment">// Store the computed value for move ordering</span></span><br><span class="line">			a.value = value;</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InvalidActionException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (OutOfTimeException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Out of time&quot;</span>);</span><br><span class="line">			<span class="comment">// revert to the previously computed values. </span></span><br><span class="line">			<span class="comment">//HOWEVER, if our best value is found to be catastrophic, keep its value.</span></span><br><span class="line">			<span class="comment">// <span class="doctag">TODO:</span> this should keep all found catastrophic values, not just the first!</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">//在至少有两个action探索过后，我们就可以进行比较了！</span></span><br><span class="line"></span><br><span class="line">			<span class="type">boolean</span> <span class="variable">resetBest</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">if</span> (actionsExplored &gt; <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="type">ActionValuePair</span> <span class="variable">bestAction</span> <span class="operator">=</span> actions.get(<span class="number">0</span>);</span><br><span class="line">				<span class="comment">// check to see if the best action is worse than another action</span></span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i &lt; actionsExplored; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (bestAction.value &lt; actions.get(i).value) &#123;</span><br><span class="line">						<span class="comment">// don&#x27;t reset the first choice</span></span><br><span class="line">						resetBest = <span class="literal">false</span>;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;	</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果我们发现了更好的action，那么就把之前的action的value恢复到之前的状态，否则除了第一个action，其他的都恢复到之前的状态</span></span><br><span class="line">			<span class="keyword">if</span> (resetBest) &#123;</span><br><span class="line">				<span class="keyword">for</span> (ActionValuePair ac: actions) &#123;</span><br><span class="line">					ac.value = ac.previousValue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i &lt; actionsExplored; i++) &#123;</span><br><span class="line">					actions.get(i).value = actions.get(i).previousValue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 提前排好序，为下一轮的迭代做好准备</span></span><br><span class="line">	Collections.sort(actions, Collections.reverseOrder());</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 更新previousvalue</span></span><br><span class="line">	<span class="keyword">for</span> (ActionValuePair a: actions) &#123;</span><br><span class="line">		a.previousValue = a.value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上述内容会在给定的时间内进行迭代，每一次迭代都会更新当前的最优值，直到时间到了，我们就可以返回当前的最优值了。（所以会按照深度迭代，在时间范围内尽可能多地在更深的地方搜索）</strong></p>
<p>接下来是关键的MTDF函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">MTDF</span><span class="params">(State root, <span class="type">int</span> firstGuess, <span class="type">int</span> depth)</span></span><br><span class="line">		<span class="keyword">throws</span> OutOfTimeException &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> firstGuess;</span><br><span class="line">	<span class="type">int</span> beta;</span><br><span class="line">	<span class="type">int</span> <span class="variable">upperbound</span> <span class="operator">=</span> WIN;</span><br><span class="line">	<span class="type">int</span> <span class="variable">lowerbound</span> <span class="operator">=</span> LOSE;</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> maximizer ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (lowerbound &lt; upperbound) &#123;</span><br><span class="line">		<span class="keyword">if</span> (g == lowerbound) &#123;</span><br><span class="line">			beta = g + <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			beta = g;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Traditional NegaMax call, just with different bounds</span></span><br><span class="line">		g = -AlphaBetaWithMemory(root, beta - <span class="number">1</span>, beta, depth, -flag);</span><br><span class="line">		<span class="keyword">if</span> (g &lt; beta) &#123;</span><br><span class="line">			upperbound = g;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			lowerbound = g;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> g;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>D</mi><mo>−</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">MTD-f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>算法采用零窗口搜索方法，旨在确定局面的最优值，初始时将最佳值范围设置为负无穷到正无穷。通过一系列零窗口搜索，不断缩小这个范围，最终确定当前局面的最优值。</p>
<p>其采用一种与期望搜索相似的方法，但在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>−</mo><mi>B</mi><mi>e</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Alpha-Beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>搜索中对初始值进行智能调整。它的核心思想是通过使搜索窗口尽可能窄来提高搜索效率，一直使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>e</mi><mi>t</mi><mi>a</mi><mo>=</mo><mi>a</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">beta = alpha + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>来调用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>−</mo><mi>B</mi><mi>e</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Alpha-Beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>搜索。这种&quot;零宽度&quot;搜索的目的是与Alpha值进行比较，如果搜索的返回值不超过Alpha，那么确切值也不会超过Alpha；反之亦然，如果确切值大于Alpha，搜索结果也会大于Alpha。这种方法有助于更快速地确定最佳局面值。</p>
<p>由于在搜索过程中上下界差只有1，所以可以迅速剪枝，并以极快的速度返回解。</p>
<p>有关<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>D</mi><mo>−</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">MTD-f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>的更多细节：</p>
<ol>
<li>试探值并不一定设成零，可以用迭代加深的形式由浅一层的MTD(f)搜索给出</li>
<li>因为要进行多次多轮的探索，所以置换表技术相当重要。</li>
<li>虽然要跑很多次，但是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>T</mi><mi>D</mi><mo>−</mo><mi>f</mi></mrow><annotation encoding="application/x-tex">MTD-f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span></span></span>用极端的限制进行<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>l</mi><mi>p</mi><mi>h</mi><mi>a</mi><mo>−</mo><mi>B</mi><mi>e</mi><mi>t</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">Alpha-Beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">p</span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span></span></span></span>搜索大大减少了搜索时间，所以效率还是很高的。</li>
</ol>
<p>最后，<strong>MTD与MiniMax的比较</strong></p>
<ul>
<li>相同点：</li>
</ul>
<ol>
<li>都是基于minimax，或者说MTD是minimax的拓展做法</li>
</ol>
<ul>
<li>不同点：</li>
</ul>
<ol>
<li>MTD使用了迭代加深，每次迭代都在更新最优的策略行为</li>
<li>MTD使用了置换表技术和Alpha-Beta优化，同时也使用了零窗口搜索，大大减少了搜索时间。</li>
</ol>
<h2 id="3-结语">3 结语</h2>
<p>本次实验，我充分分析并实践了minimax和其的拓展做法MTD，同时也对alpha-beta剪枝有了更深刻的理解。其强大的性能让我对搜索博弈有了新的认识，收货斐然。</p>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>实验报告</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo食用技巧</title>
    <url>/post/b1320771.html</url>
    <content><![CDATA[<h1 id="关于hexo的合理食用">关于hexo的合理食用</h1>
<h2 id="1-添加pdf">1. 添加pdf</h2>
<ol>
<li>\post\pdf本地目录下本地加入xxx.pdf</li>
<li>md文件里加入</li>
<li>也可以直接插入网址外部访问</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&#123;% pdf pdf/xxx.pdf %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入图片">插入图片</h2>
<p>将图片保存在\post下，直接调用即可，可以改变图片长宽比例以及大小</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">&lt;img src=<span class="string">&quot;xxx.png&quot;</span> width=<span class="string">&quot;10%&quot;</span> height=<span class="string">&quot;10%&quot;</span>&gt;</span><br></pre></td></tr></table></figure>
<img src="1.png" width="10%" height="10%">]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能导论HW1实验报告</title>
    <url>/post/776c3856.html</url>
    <content><![CDATA[<h1 id="center-报告题目：bait游戏-搜索算法-center"><center> 报告题目：Bait游戏&amp;搜索算法 </center></h1>
<h3 id="center-detect0530-gmail-com-center"><center> <a href="mailto:detect0530@gmail.com">detect0530@gmail.com</a> </center></h3>
<h2 id="引言：">引言：</h2>
<p>在个人过去的实践中，搜索算法是低效暴力的代名词，但是通过本课程的学习，从深度优先宽度优先到代价优先，再到A*算法，我才发现搜索算法的强大之处。优秀的启发式函数可以大大提高搜索效率，搜索算法的强大之处在于其可以解决各式各样的问题，比如本次实验中的Bait游戏，可以通过搜索算法来解决。并在一次次优化算法的过程中，我也对搜索算法有了更深的理解。</p>
<h1 id="2-实验内容">2 实验内容</h1>
<h2 id="2-1-task1-深度优先搜索">2.1 Task1: 深度优先搜索</h2>
<h3 id="2-1-1-记录走过的状态">2.1.1 记录走过的状态</h3>
<p>要求使用深度优先搜索完成Bait游戏，我们首先要确保一定可以遍历完所有的情况（即completion），因为游戏规定精灵可以上下左右移动，那么每张地图都构成一个图，那么首要问题就是避免死循环，即避免走“回头路”，我们使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ArrayList&lt;StateObservation&gt; Visited= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StateObservation&gt;();</span><br></pre></td></tr></table></figure>
<p>定义一个状态数组表示已经走过的状态，仔细阅读源码框架后，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>O</mi><mi>b</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">StateObservation</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>类表示了当前局面的所有信息，因为实际上我们不能只是简单的记录走过的坐标集合，因为一旦精灵拿到钥匙或者推开箱子都会使得局面状态改变而使得同样坐标的位置可以再次走到，所以我们需要记录每个局面的状态，即记录每个局面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>O</mi><mi>b</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">StateObservation</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>。</p>
<p>同时注意到，比较两个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>O</mi><mi>b</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">StateObservation</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>是否相同的方法不能简单用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>=</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">==</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span>，在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>O</mi><mi>b</mi><mi>s</mi><mi>e</mi><mi>r</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">StateObservation</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>类中给了我们<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>q</mi><mi>u</mi><mi>a</mi><mi>l</mi><mi>P</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">equalPosition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>接口。于是我们创建一个方法用来判断当前局面是否已经走过：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">CheckifVisited</span><span class="params">(StateObservation stataObs)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Visited.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stataObs.equalPosition(Visited.get(i))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-act接口调用">2.1.2 act接口调用</h3>
<p>阅读框架源码知<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>l</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">controler</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>每次行动调用的是act函数，也就是说我们搜索结束后，不能直接返回<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">action</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>数组，而是：</p>
<ul>
<li>
<ol>
<li>第一次act时，搜索得到正确actionlist，返回第一个元素。</li>
</ol>
</li>
<li>
<ol start="2">
<li>第二次act时，返回actionlist的第二个元素。</li>
</ol>
</li>
<li>
<ol start="3">
<li>依此类推…</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//act函数内：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(OK==<span class="literal">true</span>)&#123;</span><br><span class="line">    numstep++;</span><br><span class="line">    <span class="keyword">return</span> DFSActions.get(numstep);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Visited.clear();</span><br><span class="line">DFSActions.clear();</span><br><span class="line">DFS(stateObs,elapsedTimer);</span><br><span class="line"><span class="keyword">if</span>(DFSActions.size()==<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;action nil&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> Types.ACTIONS.ACTION_NIL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    OK=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> DFSActions.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-深度优先搜索的实现">2.1.3 深度优先搜索的实现</h3>
<p>我采用递归的方式实现DFS，每次递归时，先判断当前局面是否已经走过，如果走过则返回，否则将当前局面加入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Visited</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span>数组，然后判断当前局面是否为终局，如果是则返回，否则遍历当前局面的所有可行动作，对每个动作进行递归，直到找到终局或者所有动作都走过。</p>
<p>在搜索的时候，我始终使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">DFSaction</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span></span></span></span>数组记录当前的动作序列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">boolean</span> <span class="title function_">DFS</span><span class="params">(StateObservation stataObs, ElapsedCpuTimer elapsedTimer)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(CheckifVisited(stataObs))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Visited.add(stataObs);</span><br><span class="line">    <span class="type">StateObservation</span> <span class="variable">stCopy</span> <span class="operator">=</span> stataObs.copy();</span><br><span class="line">    ArrayList&lt;Types.ACTIONS&gt; actions = stataObs.getAvailableActions();</span><br><span class="line">    <span class="comment">//  StateObservation stCopy = stataObs.copy(),re=null;</span></span><br><span class="line">    <span class="keyword">for</span>(Types.ACTIONS action:actions) &#123;</span><br><span class="line">        stCopy.advance(action);</span><br><span class="line">        DFSActions.add(action);</span><br><span class="line">        <span class="keyword">if</span> (stCopy.getGameWinner() == Types.WINNER.PLAYER_WINS) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (CheckifVisited(stCopy) || stCopy.isGameOver()) &#123;</span><br><span class="line">            stCopy = stataObs.copy();</span><br><span class="line">            DFSActions.remove(DFSActions.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DFS(stCopy, elapsedTimer)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stCopy = stataObs.copy();</span><br><span class="line">            DFSActions.remove(DFSActions.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-task1-完整代码展示">2.1.4 TASK1 完整代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controllers.dfs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics2D;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> core.game.ForwardModel;</span><br><span class="line"><span class="keyword">import</span> core.game.Observation;</span><br><span class="line"><span class="keyword">import</span> core.game.StateObservation;</span><br><span class="line"><span class="keyword">import</span> core.player.AbstractPlayer;</span><br><span class="line"><span class="keyword">import</span> ontology.Types;</span><br><span class="line"><span class="keyword">import</span> tools.ElapsedCpuTimer;</span><br><span class="line"><span class="keyword">import</span> tools.Vector2d;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Random generator for the agent.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Random randomGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Observation grid.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> ArrayList&lt;Observation&gt; grid[][];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * block size</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> block_size,numstep=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> OK=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;StateObservation&gt; Visited= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StateObservation&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Vector2d&gt; Key= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;tools.Vector2d&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Types.ACTIONS&gt;  DFSActions= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Types.ACTIONS&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Agent</span><span class="params">(StateObservation so, ElapsedCpuTimer elapsedTimer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        randomGenerator = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        grid = so.getObservationGrid();</span><br><span class="line">        block_size = so.getBlockSize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">CheckifVisited</span><span class="params">(StateObservation stataObs)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Visited.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stataObs.equalPosition(Visited.get(i))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">DFS</span><span class="params">(StateObservation stataObs, ElapsedCpuTimer elapsedTimer)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(CheckifVisited(stataObs))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Visited.add(stataObs);</span><br><span class="line">        <span class="type">StateObservation</span> <span class="variable">stCopy</span> <span class="operator">=</span> stataObs.copy();</span><br><span class="line">        ArrayList&lt;Types.ACTIONS&gt; actions = stataObs.getAvailableActions();</span><br><span class="line">      <span class="comment">//  StateObservation stCopy = stataObs.copy(),re=null;</span></span><br><span class="line">        <span class="keyword">for</span>(Types.ACTIONS action:actions) &#123;</span><br><span class="line">            stCopy.advance(action);</span><br><span class="line">            DFSActions.add(action);</span><br><span class="line">            <span class="keyword">if</span> (stCopy.getGameWinner() == Types.WINNER.PLAYER_WINS) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (CheckifVisited(stCopy) || stCopy.isGameOver()) &#123;</span><br><span class="line">                stCopy = stataObs.copy();</span><br><span class="line">                DFSActions.remove(DFSActions.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DFS(stCopy, elapsedTimer)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stCopy = stataObs.copy();</span><br><span class="line">                DFSActions.remove(DFSActions.size() - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Types.ACTIONS <span class="title function_">act</span><span class="params">(StateObservation stateObs, ElapsedCpuTimer elapsedTimer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(OK==<span class="literal">true</span>)&#123;</span><br><span class="line">            numstep++;</span><br><span class="line">            <span class="keyword">return</span> DFSActions.get(numstep);</span><br><span class="line">        &#125;</span><br><span class="line">        grid = stateObs.getObservationGrid();</span><br><span class="line"></span><br><span class="line">        Visited.clear();</span><br><span class="line">        DFSActions.clear();</span><br><span class="line">        DFS(stateObs,elapsedTimer);</span><br><span class="line">        <span class="keyword">if</span>(DFSActions.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;action nil&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Types.ACTIONS.ACTION_NIL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            OK=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> DFSActions.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-1-5-algorithm-performance">2.1.5 Algorithm Performance</h3>
<p>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>10</mn><mi>s</mi></mrow><annotation encoding="application/x-tex">10s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord mathdefault">s</span></span></span></span>的限制里可以解决第1,2,3张地图。但是很明显看出来路径有随机性，很多时候绕了路。</p>
<hr>
<hr>
<h2 id="2-2-task2-深度受限的搜索-初步astar">2.2 Task2: 深度受限的搜索+初步Astar</h2>
<p>起初看题以为是加个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mi>L</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">MaxDepthLimitt</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span></span></span></span>就完事了，但是注意到题目有要求用启发式函数。我们不妨把这两者结合，即：</p>
<ul>
<li>搜索中仍有深度要求，搜到指定的参数<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mi>L</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">MaxDepthLimit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>后就返回。</li>
<li>对于深度达到<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mi>L</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">MaxDepthLimit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>或者终局的局面，我们用启发式函数来评估这个局面的好坏。</li>
</ul>
<p>基于上述两点，我们一次可以找到多个深度为指定值的局面并使用启发式函数选择最好的一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ActionList</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>执行。</p>
<h3 id="2-2-1-启发式函数的设计">2.2.1 启发式函数的设计</h3>
<p>本题只是设计一个简单的启发式函数，初心是过TASK1即可，行之有效的启发式函数设计待我在后面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord">∗</span></span></span></span>算法时来介绍。</p>
<ul>
<li>
<p>赢得游戏 score + 1*W_1</p>
</li>
<li>
<p>丢失游戏 score - 1*W_2</p>
</li>
<li>
<p>计算得分 score + GetGameScore()*W_3</p>
</li>
<li>
<p>得到钥匙 score + 1*W_1</p>
</li>
<li>
<p>箱子推到了钥匙位置上 score - W_4</p>
</li>
<li>
<p>Distance：</p>
<ol>
<li>
<p>拿到钥匙前：score - DistanceToKey()*W_5</p>
</li>
<li>
<p>拿到钥匙后：score + DistanceToDoor()*W_6</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">heuristic</span><span class="params">(StateObservation stateObs)</span>&#123;</span><br><span class="line">    <span class="type">int</span> score=<span class="number">0</span>;</span><br><span class="line">    ArrayList&lt;Observation&gt;[] movingPositions = stateObs.getMovablePositions();</span><br><span class="line">    <span class="keyword">if</span>(stateObs.getGameWinner()==Types.WINNER.PLAYER_WINS)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Winnnnnn&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Visited.size();i++)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot;Visited x=&quot;</span> + (Visited.get(i).getAvatarPosition().x/<span class="number">50</span>+<span class="number">1</span>) + <span class="string">&quot; y=&quot;</span> + (Visited.get(i).getAvatarPosition().y/<span class="number">50</span>+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        score+=<span class="number">1000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stateObs.getGameWinner()==Types.WINNER.PLAYER_LOSES)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Loseeeee&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Visited.size();i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Visited x=&quot;</span> + (Visited.get(i).getAvatarPosition().x/<span class="number">50</span>+<span class="number">1</span>) + <span class="string">&quot; y=&quot;</span> + (Visited.get(i).getAvatarPosition().y/<span class="number">50</span>+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        score-=<span class="number">1000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    score+=(<span class="type">int</span>)stateObs.getGameScore()*<span class="number">100</span>;</span><br><span class="line">  <span class="comment">//  System.out.println(&quot;score= &quot; + score);</span></span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Visited.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(keypos.equals(stateObs.getAvatarPosition()))&#123;</span><br><span class="line">            flag=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(keypos.equals(stateObs.getAvatarPosition())) flag=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// System.out.println(stateObs.getAvatarPosition() + &quot; &quot; + keypos);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag&amp;&amp;KKK) score+=<span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Getkey(stateObs).isEmpty())&#123;</span><br><span class="line">        score-=GetDistance(stateObs.getAvatarPosition(),goalpos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(GetBox(stateObs).contains(keypos)) score-=<span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">        score-=GetDistance(stateObs.getAvatarPosition(),keypos);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// System.out.println(&quot;score= &quot; + score);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-搜索的实现">2.2.2 搜索的实现</h3>
<p>和第一题类似，只不过加了个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mi>L</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">MaxDepthLimit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>的限制，然后选择最优的启发式<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>o</mi><mi>c</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">socre</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span></span></span></span>对应的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ActionList</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>即。</p>
<p>细节上说，设置一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Has\_Init</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>开关，控制现在是否已经初始化，如果现在还没初始化，则每次搜索前先清空<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">Visited</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span></span></span></span>数组和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>F</mi><mi>S</mi><mi>A</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">DFSActions</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">A</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>数组，然后再进行搜索。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">LFS</span><span class="params">(StateObservation stataObs, ElapsedCpuTimer elapsedTimer,<span class="type">int</span> dep)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep==MaxDepth||stataObs.getGameWinner()==Types.WINNER.PLAYER_WINS)&#123;</span><br><span class="line">        <span class="type">int</span> score=heuristic(stataObs);</span><br><span class="line">        <span class="keyword">if</span>(score&gt;MaxScore)&#123;</span><br><span class="line">            MaxScore=score;</span><br><span class="line">            MaxAction= (ArrayList&lt;Types.ACTIONS&gt;) DFSActions.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(Has_Init)&#123;</span><br><span class="line">        <span class="keyword">if</span>(CheckifVisited(stataObs))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Visited.clear();</span><br><span class="line">        DFSActions.clear();</span><br><span class="line">        MaxAction.clear();</span><br><span class="line">        Has_Init=<span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Visited.add(stataObs);</span><br><span class="line">    <span class="type">StateObservation</span> <span class="variable">stCopy</span> <span class="operator">=</span> stataObs.copy();</span><br><span class="line">    ArrayList&lt;Types.ACTIONS&gt; actions = stataObs.getAvailableActions();</span><br><span class="line">    <span class="keyword">for</span>(Types.ACTIONS action:actions) &#123;</span><br><span class="line">        stCopy.advance(action);</span><br><span class="line">        DFSActions.add(action);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(CheckifVisited(stCopy))&#123;</span><br><span class="line">            stCopy=stataObs.copy();</span><br><span class="line">            DFSActions.remove(DFSActions.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stCopy.getGameWinner() == Types.WINNER.PLAYER_WINS) &#123;</span><br><span class="line">            <span class="type">int</span> score=heuristic(stCopy);</span><br><span class="line">            <span class="keyword">if</span>(score&gt;MaxScore)&#123;</span><br><span class="line">                MaxScore=score;</span><br><span class="line">                MaxAction= (ArrayList&lt;Types.ACTIONS&gt;) DFSActions.clone();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stCopy=stataObs.copy();</span><br><span class="line">            DFSActions.remove(DFSActions.size()-<span class="number">1</span>);</span><br><span class="line">            Has_Init=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            LFS(stCopy,elapsedTimer,dep+<span class="number">1</span>);</span><br><span class="line">            Visited.remove(stCopy);</span><br><span class="line">            stCopy=stataObs.copy();</span><br><span class="line">            DFSActions.remove(DFSActions.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">act</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span></span></span></span>函数里，也根据<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>a</mi><mi>s</mi><mi mathvariant="normal">_</mi><mi>I</mi><mi>n</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Has\_Init</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.99333em;vertical-align:-0.31em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>开关的不同施行不同的造作：</p>
<ul>
<li>如果没初始化，则意味着现在需要搜索一遍，即进入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>F</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">LFs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">s</span></span></span></span>函数</li>
<li>如果已经搜索过了，那么依次执行搜索好的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>A</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">BestActionList</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">A</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>就可以了。</li>
</ul>
<hr>
<h3 id="2-2-3-task2-完整代码展示">2.2.3 TASK2 完整代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controllers.dls;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.Graphics2D;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> core.game.ForwardModel;</span><br><span class="line"><span class="keyword">import</span> core.game.Observation;</span><br><span class="line"><span class="keyword">import</span> core.game.StateObservation;</span><br><span class="line"><span class="keyword">import</span> core.player.AbstractPlayer;</span><br><span class="line"><span class="keyword">import</span> ontology.Types;</span><br><span class="line"><span class="keyword">import</span> ontology.avatar.MovingAvatar;</span><br><span class="line"><span class="keyword">import</span> tools.ElapsedCpuTimer;</span><br><span class="line"><span class="keyword">import</span> tools.Vector2d;</span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.awt.image.BufferedImage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Random randomGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ArrayList&lt;Observation&gt; grid[][];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> block_size,numstep=<span class="number">0</span>,MaxScore=-<span class="number">10000000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> OK=<span class="literal">false</span>,Has_Init=<span class="literal">false</span>,KKK=<span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> MaxDepth=<span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;StateObservation&gt; Visited= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StateObservation&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Types.ACTIONS&gt;  DFSActions= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Types.ACTIONS&gt;(),MaxAction= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Types.ACTIONS&gt;();</span><br><span class="line">    <span class="keyword">private</span> Vector2d goalpos,keypos;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Public constructor with state observation and time due.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> so state observation of the current game.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> elapsedTimer Timer for the controller creation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Agent</span><span class="params">(StateObservation so, ElapsedCpuTimer elapsedTimer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        randomGenerator = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        grid = so.getObservationGrid();</span><br><span class="line">        block_size = so.getBlockSize();</span><br><span class="line">        ArrayList&lt;Observation&gt;[] fixedPositions = so.getImmovablePositions();</span><br><span class="line">        ArrayList&lt;Observation&gt;[] movingPositions = so.getMovablePositions();</span><br><span class="line">        goalpos = fixedPositions[<span class="number">1</span>].get(<span class="number">0</span>).position; <span class="comment">//目标的坐标</span></span><br><span class="line">        keypos = movingPositions[<span class="number">0</span>].get(<span class="number">0</span>).position ;<span class="comment">//钥匙的坐标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否走过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">CheckifVisited</span><span class="params">(StateObservation stataObs)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Visited.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stataObs.equalPosition(Visited.get(i))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取箱子的坐标</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Vector2d&gt; <span class="title function_">GetBox</span><span class="params">(StateObservation stataObs)</span>&#123;</span><br><span class="line">        ArrayList&lt;Observation&gt;[][] observationGrid= stataObs.getObservationGrid();</span><br><span class="line">        ArrayList&lt;Vector2d&gt; Box= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;tools.Vector2d&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;observationGrid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;observationGrid[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(observationGrid[i][j]!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;observationGrid[i][j].size();k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(observationGrid[i][j].get(k).itype==<span class="number">8</span>)&#123;</span><br><span class="line">                            Box.add(observationGrid[i][j].get(k).position);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取钥匙的坐标</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Vector2d&gt; <span class="title function_">Getkey</span><span class="params">(StateObservation stataObs)</span>&#123;</span><br><span class="line">        ArrayList&lt;Observation&gt;[][] observationGrid= stataObs.getObservationGrid();</span><br><span class="line">        ArrayList&lt;Vector2d&gt; Key= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;tools.Vector2d&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;observationGrid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;observationGrid[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(observationGrid[i][j]!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;observationGrid[i][j].size();k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(observationGrid[i][j].get(k).itype==<span class="number">6</span>)&#123;</span><br><span class="line">                            Key.add(observationGrid[i][j].get(k).position);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到两点的曼哈顿距离</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">GetDistance</span><span class="params">(Vector2d a,Vector2d b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.abs(a.x-b.x)/<span class="number">50</span>+(<span class="type">int</span>)Math.abs(a.y-b.y)/<span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启发式估价函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">heuristic</span><span class="params">(StateObservation stateObs)</span>&#123;</span><br><span class="line">        <span class="type">int</span> score=<span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Observation&gt;[] movingPositions = stateObs.getMovablePositions();</span><br><span class="line">        <span class="keyword">if</span>(stateObs.getGameWinner()==Types.WINNER.PLAYER_WINS)&#123;</span><br><span class="line">            score+=<span class="number">1000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stateObs.getGameWinner()==Types.WINNER.PLAYER_LOSES)&#123;</span><br><span class="line">            score-=<span class="number">1000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        score+=(<span class="type">int</span>)stateObs.getGameScore()*<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Visited.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(keypos.equals(stateObs.getAvatarPosition()))&#123;</span><br><span class="line">                flag=<span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(keypos.equals(stateObs.getAvatarPosition())) flag=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag&amp;&amp;KKK) score+=<span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Getkey(stateObs).isEmpty())&#123;</span><br><span class="line">            score-=GetDistance(stateObs.getAvatarPosition(),goalpos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(GetBox(stateObs).contains(keypos)) score-=<span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">            score-=GetDistance(stateObs.getAvatarPosition(),keypos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">LFS</span><span class="params">(StateObservation stataObs, ElapsedCpuTimer elapsedTimer,<span class="type">int</span> dep)</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dep==MaxDepth||stataObs.getGameWinner()==Types.WINNER.PLAYER_WINS)&#123;</span><br><span class="line">            <span class="type">int</span> score=heuristic(stataObs);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(score&gt;MaxScore)&#123;</span><br><span class="line">                MaxScore=score;</span><br><span class="line">                MaxAction= (ArrayList&lt;Types.ACTIONS&gt;) DFSActions.clone();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(Has_Init)&#123;</span><br><span class="line">            <span class="keyword">if</span>(CheckifVisited(stataObs))&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Visited.clear();</span><br><span class="line">            DFSActions.clear();</span><br><span class="line">            MaxAction.clear();</span><br><span class="line">            Has_Init=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Visited.add(stataObs);</span><br><span class="line">        <span class="type">StateObservation</span> <span class="variable">stCopy</span> <span class="operator">=</span> stataObs.copy();</span><br><span class="line">        ArrayList&lt;Types.ACTIONS&gt; actions = stataObs.getAvailableActions();</span><br><span class="line">        <span class="keyword">for</span>(Types.ACTIONS action:actions) &#123;</span><br><span class="line">            stCopy.advance(action);</span><br><span class="line">            DFSActions.add(action);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(CheckifVisited(stCopy))&#123;</span><br><span class="line">                stCopy=stataObs.copy();</span><br><span class="line">                DFSActions.remove(DFSActions.size()-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stCopy.getGameWinner() == Types.WINNER.PLAYER_WINS) &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="type">int</span> score=heuristic(stCopy);</span><br><span class="line">                <span class="keyword">if</span>(score&gt;MaxScore)&#123;</span><br><span class="line">                    MaxScore=score;</span><br><span class="line">                    MaxAction= (ArrayList&lt;Types.ACTIONS&gt;) DFSActions.clone();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                stCopy=stataObs.copy();</span><br><span class="line">                DFSActions.remove(DFSActions.size()-<span class="number">1</span>);</span><br><span class="line">                Has_Init=<span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                LFS(stCopy,elapsedTimer,dep+<span class="number">1</span>);</span><br><span class="line">                Visited.remove(stCopy);</span><br><span class="line">                stCopy=stataObs.copy();</span><br><span class="line">                DFSActions.remove(DFSActions.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Types.ACTIONS <span class="title function_">act</span><span class="params">(StateObservation stateObs, ElapsedCpuTimer elapsedTimer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(Has_Init)&#123;</span><br><span class="line">            numstep++;<span class="type">int</span> now=numstep;</span><br><span class="line">            <span class="keyword">if</span>(numstep&gt;MaxAction.size()-<span class="number">1</span>)&#123;</span><br><span class="line">                Has_Init=<span class="literal">false</span>;numstep=<span class="number">0</span>;MaxScore=-<span class="number">100000</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> MaxAction.get(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!Getkey(stateObs).isEmpty()) KKK=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> KKK=<span class="literal">false</span>;MaxScore=-<span class="number">10000000</span>;</span><br><span class="line">        System.out.println(stateObs.getAvatarPosition());</span><br><span class="line">        LFS(stateObs,elapsedTimer,<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;MaxScore= &quot;</span> + MaxScore + <span class="string">&quot; &quot;</span> +  MaxAction.size());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxAction.size();i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;action &quot;</span> + MaxAction.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(MaxAction.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;action nil&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Types.ACTIONS.ACTION_NIL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> MaxAction.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printDebug</span><span class="params">(ArrayList&lt;Observation&gt;[] positions, String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (positions != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(str + <span class="string">&quot;:&quot;</span> + positions.length + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; positions.length; i++) &#123;</span><br><span class="line">                System.out.print(positions[i].size() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;); &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;positions.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;positions[i].size();j++)&#123;</span><br><span class="line">                    System.out.println(str + <span class="string">&quot; x=&quot;</span> + positions[i].get(j).position.x/<span class="number">50</span> + <span class="string">&quot; y=&quot;</span> + positions[i].get(j).position.y/<span class="number">50</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> System.out.print(str + <span class="string">&quot;: 0; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-4-algorithm-performance">2.2.4 Algorithm Performance</h3>
<p>程序的执行效果与各项参数密切相关，首先是各项启发式函数的系数常数，经过调整得到以下参数：</p>
<ul>
<li>
<p>赢得游戏 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>+</mo><mn>1</mn><mo>∗</mo><msub><mi>W</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>100000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">score + 1*W_1(100000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>丢失游戏 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>−</mo><mn>1</mn><mo>∗</mo><msub><mi>W</mi><mn>2</mn></msub><mo stretchy="false">(</mo><mn>100000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">score - 1*W_2(100000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>计算得分 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>+</mo><mi>G</mi><mi>e</mi><mi>t</mi><mi>G</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>S</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>W</mi><mn>3</mn></msub><mo stretchy="false">(</mo><mn>100</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">score + GetGameScore()*W_3(100)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">G</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>得到钥匙 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>+</mo><mn>1</mn><mo>∗</mo><msub><mi>W</mi><mn>1</mn></msub><mo stretchy="false">(</mo><mn>500</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">score + 1*W_1(500)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>箱子推到了钥匙位置上 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>−</mo><msub><mi>W</mi><mn>4</mn></msub><mo stretchy="false">(</mo><mn>100000</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">score - W_4(100000)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>Distance：</p>
<ol>
<li>
<p>拿到钥匙前：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>−</mo><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>T</mi><mi>o</mi><mi>K</mi><mi>e</mi><mi>y</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>W</mi><mn>5</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">score - DistanceToKey()*W_5(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p>拿到钥匙后：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>+</mo><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>T</mi><mi>o</mi><mi>D</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>∗</mo><msub><mi>W</mi><mn>6</mn></msub><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">score + DistanceToDoor()*W_6(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
</li>
</ol>
</li>
</ul>
<p>另外的一个关键参数是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mi>L</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">MaxDepthLimit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span></span></span></span>，这个参数十分关键，设小了会导致程序找不到成功的路径(比如距离小到无法在一次搜索中推开箱子拿到钥匙)，设置大了会导致程序运行时间过长，甚至超过单步的时间限制。</p>
<p>经过尝试，设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mi>L</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">MaxDepthLimit=3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span> 能通过第一关。而设置<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>D</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi><mi>L</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mo>=</mo><mn>15</mn></mrow><annotation encoding="application/x-tex">MaxDepthLimit=15</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">5</span></span></span></span>能通过第二关。</p>
<hr>
<h2 id="2-3-task3-astar启发式搜索">2.3 Task3: Astar启发式搜索</h2>
<h3 id="2-3-1-a-算法问题概述：">2.3.1 A*算法问题概述：</h3>
<p>本题要求使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∗</mo></mrow><annotation encoding="application/x-tex">A*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord">∗</span></span></span></span>算法来解决Bait游戏，在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">BFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>的基础上加入了启发式函数，即每次搜索时，优先搜索启发式函数值最小的节点，这样可以大大提高搜索效率。</p>
<p>其算法的核心在于启发式函数的设定，优秀的启发式函数可以极大程度加速搜索。</p>
<p><strong>在本题中，设定为单步时限<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">100ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>，经过参数反复打磨与设定，我的程序可以在第1,2,3,5张图中在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">100ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>内直接找到获胜策略。</strong></p>
<p>设计好了启发式函数后，整体框架其实类似于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mi>F</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">BFS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>，只不过在每次搜索时，我们需要优先搜索集合中启发式函数值最小的节点。这一点可以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">java</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span></span></span></span>中的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">TreeSet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>内置的红黑树加速实现（因为到后期节点数会很多，所以用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mi>r</mi><mi>e</mi><mi>e</mi><mi>S</mi><mi>e</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">TreeSet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span></span></span></span>来存储节点可以大幅度优化时间开销）。</p>
<h3 id="2-3-2-启发式函数的设计">2.3.2 启发式函数的设计</h3>
<p>先阐述一下游戏的整体流程：</p>
<p>推动箱子或者填坑 --&gt; 拿到钥匙 --&gt; 推动箱子或者填坑 --&gt; 到达终点</p>
<p>整个过程和箱子的位置、是否拿到钥匙、箱子是否进坑密切相关。</p>
<p>于是自然有以下参数：</p>
<ul>
<li>
<ol start="0">
<li>深度<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>e</mi><mi>p</mi><mo>∗</mo><msub><mi>c</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">Dep*c_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
</li>
<li>
<ol>
<li>游戏得分<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>e</mi><mi>t</mi><mi>G</mi><mi>a</mi><mi>m</mi><mi>e</mi><mi>S</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi><mo>∗</mo><msub><mi>c</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">GetGameScore*c_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">G</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
</li>
<li>
<ol start="2">
<li>是否赢得游戏<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mi>i</mi><mi>n</mi><mi>o</mi><mi>r</mi><mi>L</mi><mi>o</mi><mi>s</mi><mi>e</mi><mo>∗</mo><msub><mi>c</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">WinorLose*c_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">W</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">L</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ol>
</li>
<li>
<ol start="3">
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>∗</mo><msub><mi>c</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">Distance*c_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （拿到钥匙前Distance为到钥匙的距离，拿到钥匙后Distance为到终点的距离）</li>
</ol>
</li>
</ul>
<p>看起来现在的启发式函数会直奔钥匙并保证不会掉坑里并且会选择得分高的方式（推箱子入坑，吃蘑菇等），但是在第二张图中会出现下面的情况：</p>
<p><img src="007.png" alt="Alt text"></p>
<p>即不会往两边的箱子走，因为往两边走意味着远离钥匙，我们的启发式函数不鼓励我们这样做。</p>
<p>另外是容易出现推箱子进入死角的情况。</p>
<p>为了避免上述两种不利情况，我们为箱子单独增加参数：</p>
<p>理论上，我们需要为每一个box都计算一个单独但是权值，但是实际上因为走一步影响的box有限，故只需统计走一步能影响到的box数就可以。形式化的，即我们只对于当前精灵位置曼哈顿距离小于等于二的box进行权值计算。</p>
<ul>
<li>4.1 自由度<span class='katex-error' title='ParseError: KaTeX parse error: Double subscript at position 5: *C_4_̲1'>*C_4_1</span> （自由度表示箱子左右或者上下都是空的，自由度越大，箱子越容易被推动，值为0/1/2）</li>
<li>4.2 离当前box最近的坑的距离<span class='katex-error' title='ParseError: KaTeX parse error: Double subscript at position 5: *C_4_̲2'>*C_4_2</span> (我们期望推着箱子往坑走)</li>
<li>4.3 是否可以一步入洞，即箱子的一侧是精灵对侧是坑<span class='katex-error' title='ParseError: KaTeX parse error: Double subscript at position 5: *C_4_̲3'>*C_4_3</span>（这种情况我们期望把箱子推进坑）</li>
<li>4.4 是否挡住了钥匙<span class='katex-error' title='ParseError: KaTeX parse error: Double subscript at position 5: *C_4_̲4'>*C_4_4</span>（这种情况赋很大的负权值直接毙掉就可以）</li>
</ul>
<p>上述参数可以有效解决箱子进入死角或者推着箱子乱走的情况。</p>
<p>同时，对于精灵，我们要引导其往箱子走。</p>
<ul>
<li>5 与精灵最近的box距离<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∗</mo><msub><mi>C</mi><mn>5</mn></msub></mrow><annotation encoding="application/x-tex">*C_5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord">∗</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> （我们期望精灵往箱子走）</li>
</ul>
<p>至此，启发式函数的设计已经完成。剩下的工作是对于每个参数赋予合适的权值。（炼丹太痛苦了</p>
<p>经过反复调试，我最终得到的参数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> W_0=-<span class="number">2</span>,W_1=<span class="number">100</span>,W_2=<span class="number">100000000</span>,W_3=-<span class="number">5</span>,W_4_1=<span class="number">30</span>,W_4_2=<span class="number">10</span>,W_4_3=<span class="number">1000</span>,W_4_4=-<span class="number">10000000</span>,W_5=-<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>并成功在总时间<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">100ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>内通过了第1,2,3,5张图。（远远比要求的单步<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">100ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>优秀。</p>
<p>code如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">heuristic</span><span class="params">(StateObservation stateObs,<span class="type">boolean</span> HasGetKey,<span class="type">int</span> dep)</span>&#123;</span><br><span class="line">    <span class="type">double</span> score=<span class="number">0</span>,W_0=-<span class="number">2</span>,W_1=<span class="number">100000000</span>,W_2=<span class="number">100</span>,W_3=-<span class="number">5</span>,W_4_1=<span class="number">30</span>,W_4_2=<span class="number">10</span>,W_4_3=<span class="number">1000</span>,W_4_4=-<span class="number">10</span>,W_5=-<span class="number">10</span>;</span><br><span class="line">    <span class="type">double</span> Dep,WinorLose=<span class="number">0</span>,Nowscore=<span class="number">0</span>,Distance,Box_1=<span class="number">0</span>,Box_2=<span class="number">0</span>,Box_3=<span class="number">0</span>,Box_4=<span class="number">0</span>,GG=<span class="number">0</span>,MinDistanceBox=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Dep=dep;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(stateObs.getGameWinner()==Types.WINNER.PLAYER_WINS)&#123;</span><br><span class="line">        WinorLose=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(stateObs.getGameWinner()==Types.WINNER.PLAYER_LOSES)&#123;</span><br><span class="line">        WinorLose=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Nowscore=stateObs.getGameScore();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(HasGetKey)&#123;</span><br><span class="line">        Distance=GetDistance(stateObs.getAvatarPosition(),goalpos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Distance=GetDistance(stateObs.getAvatarPosition(),keypos);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Vector2d&gt; Box=GetBox(stateObs);</span><br><span class="line">    ArrayList&lt;Observation&gt;[][] observationGrid= stateObs.getObservationGrid();</span><br><span class="line">    <span class="type">int</span>[][] Map=<span class="keyword">new</span> <span class="title class_">int</span>[observationGrid.length][observationGrid[<span class="number">0</span>].length];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;observationGrid.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;observationGrid[i].length;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(observationGrid[i][j].size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;observationGrid[i][j].size();k++)&#123;</span><br><span class="line">                    Map[i][j]=observationGrid[i][j].get(k).itype;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                Map[i][j]=-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ax=(<span class="type">int</span>)stateObs.getAvatarPosition().x/<span class="number">50</span>,ay=(<span class="type">int</span>)stateObs.getAvatarPosition().y/<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Box.size();i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> x=(<span class="type">int</span>)Box.get(i).x/<span class="number">50</span>,y=(<span class="type">int</span>)Box.get(i).y/<span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> n=observationGrid.length,m=observationGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x==keypos.x/<span class="number">50</span>&amp;&amp;y==keypos.y/<span class="number">50</span>&amp;&amp; !HasGetKey) GG=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> is=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(ax==x&amp;&amp;(ay==y+<span class="number">1</span>||ay==y-<span class="number">1</span>)) is=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(ay==y&amp;&amp;(ax==x+<span class="number">1</span>||ax==x-<span class="number">1</span>)) is=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(ax==x-<span class="number">1</span>&amp;&amp;ay==y-<span class="number">1</span>) is=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(ax==x+<span class="number">1</span>&amp;&amp;ay==y+<span class="number">1</span>) is=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(ax==x-<span class="number">1</span>&amp;&amp;ay==y+<span class="number">1</span>) is=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(ax==x+<span class="number">1</span>&amp;&amp;ay==y-<span class="number">1</span>) is=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!is) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x&lt;n-<span class="number">1</span>&amp;&amp;x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Map[x+<span class="number">1</span>][y]==-<span class="number">1</span>&amp;&amp;Map[x-<span class="number">1</span>][y]==-<span class="number">1</span>) Box_1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;m-<span class="number">1</span>&amp;&amp;y&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Map[x][y+<span class="number">1</span>]==-<span class="number">1</span>&amp;&amp;Map[x][y-<span class="number">1</span>]==-<span class="number">1</span>) Box_1++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x&lt;n-<span class="number">1</span>) <span class="keyword">if</span>(Map[x+<span class="number">1</span>][y]==<span class="number">2</span>) Box_2++;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;<span class="number">0</span>) <span class="keyword">if</span>(Map[x-<span class="number">1</span>][y]==<span class="number">2</span>) Box_2++;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;m-<span class="number">1</span>) <span class="keyword">if</span>(Map[x][y+<span class="number">1</span>]==<span class="number">2</span>) Box_2++;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;<span class="number">0</span>) <span class="keyword">if</span>(Map[x][y-<span class="number">1</span>]==<span class="number">2</span>) Box_2++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x&lt;n-<span class="number">1</span>&amp;&amp;x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Map[x+<span class="number">1</span>][y]==<span class="number">2</span>&amp;&amp;Map[x-<span class="number">1</span>][y]==-<span class="number">1</span>) Box_3++;</span><br><span class="line">            <span class="keyword">if</span>(Map[x-<span class="number">1</span>][y]==<span class="number">2</span>&amp;&amp;Map[x+<span class="number">1</span>][y]==<span class="number">1</span>) Box_3++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(y&lt;m-<span class="number">1</span>&amp;&amp;y&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Map[x][y+<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;Map[x][y-<span class="number">1</span>]==-<span class="number">1</span>) Box_3++;</span><br><span class="line">            <span class="keyword">if</span>(Map[x][y-<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;Map[x][y+<span class="number">1</span>]==-<span class="number">1</span>) Box_3++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Box_4+=GetDistanceHole(x*<span class="number">50</span>,y*<span class="number">50</span>,stateObs);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(HasGetKey) GG--;</span><br><span class="line"></span><br><span class="line">    MinDistanceBox=GetMinDistanceBox(stateObs);</span><br><span class="line"></span><br><span class="line">    score=W_0*Dep+W_1*WinorLose+W_2*Nowscore+W_3*Distance+W_4_1*Box_1+W_4_2*Box_2+W_4_3*Box_3+W_4_4*Box_4+GG*-<span class="number">1000000</span>+W_5*MinDistanceBox;</span><br><span class="line">    <span class="keyword">return</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-3-a-算法的实现">2.3.3 A*算法的实现</h3>
<p>与在2.3.1概述中说的一样，我们用红黑树数据结构实现。</p>
<p>为了方便代码实现，实现了基础类Node。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">double</span> score, StateObservation stateObs, ArrayList&lt;Types.ACTIONS&gt; Actions, <span class="type">int</span> depth,<span class="type">boolean</span> GetKey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.stateObs = stateObs;</span><br><span class="line">        <span class="built_in">this</span>.Actions = Actions;</span><br><span class="line">        <span class="built_in">this</span>.depth = depth;</span><br><span class="line">        <span class="built_in">this</span>.GetKey=GetKey;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">score</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span></span></span></span>为启发式函数值，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mi>O</mi><mi>b</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">stateObs</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span></span></span></span>为当前局面，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Actions</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span></span></span></span>为当前局面的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>L</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">ActionList</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">L</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>p</mi><mi>t</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">depth</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span></span></span></span>为当前深度，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mi>e</mi><mi>t</mi><mi>K</mi><mi>e</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">GetKey</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">G</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>为是否拿到钥匙。</p>
<p>同时定义红黑树排序关键字是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>c</mi><mi>o</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">score</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span></span></span></span>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node other)</span> &#123;</span><br><span class="line">    <span class="comment">// 降序排列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ok</span> <span class="operator">=</span> Double.compare(other.score, <span class="built_in">this</span>.score);</span><br><span class="line">    <span class="keyword">if</span>(ok==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(stateObs.equalPosition(other.stateObs))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Astar算法的实现框架代码如下:（和之前两个的框架类似，只不过变成了优先队列展开而已</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Types.ACTIONS&gt; Astar(Node StartNode, ElapsedCpuTimer elapsedTimer,<span class="type">int</span> dep)&#123;</span><br><span class="line">        <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        Todolist.add(StartNode);</span><br><span class="line">        <span class="keyword">while</span>(!Todolist.isEmpty())&#123;</span><br><span class="line">            Node now=Todolist.pollFirst();</span><br><span class="line">            System.out.println(<span class="string">&quot;score= &quot;</span> + now.getScore() + <span class="string">&quot; depth= &quot;</span> + now.getDepth() + <span class="string">&quot; GetKey= &quot;</span> + now.GetKey + <span class="string">&quot;Positon= &quot;</span> + (now.getStateObs().getAvatarPosition().x/<span class="number">50</span>)+<span class="string">&quot;,&quot;</span>+(now.getStateObs().getAvatarPosition().y/<span class="number">50</span>)+<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">            tot++;</span><br><span class="line">            StateObservation stataObs=now.getStateObs();</span><br><span class="line">            Visited.add(stataObs);<span class="comment">//记录走过的节点</span></span><br><span class="line">            ArrayList&lt;Types.ACTIONS&gt; actions = now.getStateObs().getAvailableActions();</span><br><span class="line">            <span class="keyword">for</span>(Types.ACTIONS action:actions)&#123;</span><br><span class="line">                <span class="type">StateObservation</span> <span class="variable">stCopy</span> <span class="operator">=</span> now.getStateObs().copy();</span><br><span class="line">                stCopy.advance(action);</span><br><span class="line">                ArrayList&lt;Types.ACTIONS&gt;  AstarAction= (ArrayList&lt;Types.ACTIONS&gt;) now.getActions().clone();</span><br><span class="line">                AstarAction.add(action);</span><br><span class="line">                <span class="keyword">if</span>(stCopy.getGameWinner()==Types.WINNER.PLAYER_WINS)&#123;</span><br><span class="line">                    OK=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> AstarAction;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(stCopy.getGameWinner()==Types.WINNER.PLAYER_LOSES||CheckifVisited(stCopy))&#123;</span><br><span class="line">                    AstarAction.remove(AstarAction.size()-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断是否取得了钥匙</span></span><br><span class="line">                <span class="type">boolean</span> NowGetKey=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(Getkey(now.getStateObs()).size()==<span class="number">1</span>&amp;&amp; Getkey(stCopy).isEmpty())&#123;</span><br><span class="line">                    NowGetKey=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果Todolist有该位置的节点，比较两个节点的score，取最优的</span></span><br><span class="line">                Node node=contain(Todolist,stCopy);</span><br><span class="line">                <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="type">double</span> score0=node.getScore();</span><br><span class="line"></span><br><span class="line">                    <span class="type">double</span> score1=heuristic(stCopy,NowGetKey|now.GetKey,dep+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(score0&gt;=score1)&#123;</span><br><span class="line">                        AstarAction.remove(AstarAction.size()-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        Node Newnode=<span class="keyword">new</span> <span class="title class_">Node</span>(score1,stCopy,AstarAction, dep+<span class="number">1</span>,NowGetKey|now.GetKey);</span><br><span class="line">                        Todolist.remove(node);</span><br><span class="line">                        Todolist.add(Newnode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//反之，则加入红黑树中排序</span></span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Node Newnode=<span class="keyword">new</span> <span class="title class_">Node</span>(heuristic(stCopy,NowGetKey|now.GetKey,dep+<span class="number">1</span>),stCopy,AstarAction, dep+<span class="number">1</span>,NowGetKey|now.GetKey);</span><br><span class="line">                    Todolist.add(Newnode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;GGGGGGGGGGGGGGGGGGGGGGG&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Types.ACTIONS&gt;());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-3-4-task3-完整代码展示">2.3.4 TASK3 完整代码展示</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> controllers.Astar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> core.game.Observation;</span><br><span class="line"><span class="keyword">import</span> core.game.StateObservation;</span><br><span class="line"><span class="keyword">import</span> core.player.AbstractPlayer;</span><br><span class="line"><span class="keyword">import</span> ontology.Types;</span><br><span class="line"><span class="keyword">import</span> tools.ElapsedCpuTimer;</span><br><span class="line"><span class="keyword">import</span> tools.Vector2d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Double.min;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Node类用于描述一个状态，包括状态的得分、状态本身、状态的动作、状态的深度、是否拿过钥匙</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Node&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> score;</span><br><span class="line">    <span class="keyword">private</span> StateObservation stateObs;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Types.ACTIONS&gt; Actions;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> depth;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> GetKey;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">double</span> score, StateObservation stateObs, ArrayList&lt;Types.ACTIONS&gt; Actions, <span class="type">int</span> depth,<span class="type">boolean</span> GetKey)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.score = score;</span><br><span class="line">        <span class="built_in">this</span>.stateObs = stateObs;</span><br><span class="line">        <span class="built_in">this</span>.Actions = Actions;</span><br><span class="line">        <span class="built_in">this</span>.depth = depth;</span><br><span class="line">        <span class="built_in">this</span>.GetKey=GetKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Node other)</span> &#123;</span><br><span class="line">        System.out.println(other.stateObs==<span class="literal">null</span>);</span><br><span class="line">        <span class="built_in">this</span>.score = other.score;</span><br><span class="line">        <span class="built_in">this</span>.stateObs = stateObs.copy(); <span class="comment">// 假设stateObs也需要克隆</span></span><br><span class="line">        <span class="built_in">this</span>.Actions = (ArrayList&lt;Types.ACTIONS&gt;) other.Actions.clone(); <span class="comment">// 假设Actions也需要克隆</span></span><br><span class="line">        <span class="built_in">this</span>.depth = other.depth;</span><br><span class="line">        <span class="built_in">this</span>.GetKey=other.GetKey;</span><br><span class="line">        <span class="comment">// 复制其他属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getScore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> StateObservation <span class="title function_">getStateObs</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stateObs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Types.ACTIONS&gt; getActions() &#123;</span><br><span class="line">        <span class="keyword">return</span> Actions;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序按照score启发式得分降序排序</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Node other)</span> &#123;</span><br><span class="line">        <span class="comment">// 降序排列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ok</span> <span class="operator">=</span> Double.compare(other.score, <span class="built_in">this</span>.score);</span><br><span class="line">        <span class="keyword">if</span>(ok==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(stateObs.equalPosition(other.stateObs))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> ok;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">other</span> <span class="operator">=</span> (Node) o;</span><br><span class="line">        <span class="keyword">return</span> stateObs.equalPosition(other.stateObs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Double.toString(score);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Agent</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlayer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Random randomGenerator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ArrayList&lt;Observation&gt; grid[][];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeSet&lt;Node&gt; Todolist = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> OK=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> block_size,numstep=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;StateObservation&gt; Visited= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;StateObservation&gt;();</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Types.ACTIONS&gt;  MaxAction= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Types.ACTIONS&gt;();</span><br><span class="line">    <span class="keyword">private</span> Vector2d goalpos,keypos;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Agent</span><span class="params">(StateObservation so, ElapsedCpuTimer elapsedTimer)</span></span><br><span class="line">    &#123;</span><br><span class="line">        randomGenerator = <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        grid = so.getObservationGrid();</span><br><span class="line">        block_size = so.getBlockSize();</span><br><span class="line">        ArrayList&lt;Observation&gt;[] fixedPositions = so.getImmovablePositions();</span><br><span class="line">        ArrayList&lt;Observation&gt;[] movingPositions = so.getMovablePositions();</span><br><span class="line">        goalpos = fixedPositions[<span class="number">1</span>].get(<span class="number">0</span>).position; <span class="comment">//目标的坐标</span></span><br><span class="line">        keypos = movingPositions[<span class="number">0</span>].get(<span class="number">0</span>).position ;<span class="comment">//钥匙的坐标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是否走过相同的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">CheckifVisited</span><span class="params">(StateObservation stataObs)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; Visited.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stataObs.equalPosition(Visited.get(i))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获得两点的距离</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">GetDistance</span><span class="params">(Vector2d a,Vector2d b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.abs(a.x-b.x)/<span class="number">50</span>+(<span class="type">int</span>)Math.abs(a.y-b.y)/<span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查openlist是否走过相同的状态</span></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">contain</span><span class="params">(TreeSet&lt;Node&gt; Todolist,StateObservation stataObs)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Node node:Todolist)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.getStateObs().equalPosition(stataObs))&#123;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Vector2d&gt; <span class="title function_">GetBox</span><span class="params">(StateObservation stataObs)</span>&#123;</span><br><span class="line">        ArrayList&lt;Observation&gt;[][] observationGrid= stataObs.getObservationGrid();</span><br><span class="line">        ArrayList&lt;Vector2d&gt; Box= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;tools.Vector2d&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;observationGrid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;observationGrid[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(observationGrid[i][j]!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;observationGrid[i][j].size();k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(observationGrid[i][j].get(k).itype==<span class="number">8</span>)&#123;</span><br><span class="line">                            Box.add(observationGrid[i][j].get(k).position);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Box;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到与box最近的坑的距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">GetDistanceHole</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,StateObservation stateObs)</span>&#123;</span><br><span class="line">        ArrayList&lt;Observation&gt;[][] observationGrid= stateObs.getObservationGrid();</span><br><span class="line">        <span class="type">int</span> n=observationGrid.length,m=observationGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">double</span> sum=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;observationGrid[i][j].size();k++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(observationGrid[i][j].get(k).itype==<span class="number">2</span>)&#123;</span><br><span class="line">                        sum=min(sum,GetDistance(<span class="keyword">new</span> <span class="title class_">Vector2d</span>(x,y),observationGrid[i][j].get(k).position));</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">1e9</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到与精灵最近的额box的距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">GetMinDistanceBox</span><span class="params">(StateObservation stateObs)</span>&#123;</span><br><span class="line">        ArrayList&lt;Observation&gt;[][] observationGrid= stateObs.getObservationGrid();</span><br><span class="line">        ArrayList&lt;Vector2d&gt; Box= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;tools.Vector2d&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;observationGrid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;observationGrid[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(observationGrid[i][j]!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;observationGrid[i][j].size();k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(observationGrid[i][j].get(k).itype==<span class="number">8</span>)&#123;</span><br><span class="line">                            Box.add(observationGrid[i][j].get(k).position);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> sum=<span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Box.size();i++)&#123;</span><br><span class="line">            sum=min(sum,GetDistance(stateObs.getAvatarPosition(),Box.get(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum==<span class="number">1e9</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到key的坐标集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Vector2d&gt; <span class="title function_">Getkey</span><span class="params">(StateObservation stataObs)</span>&#123;</span><br><span class="line">        ArrayList&lt;Observation&gt;[][] observationGrid= stataObs.getObservationGrid();</span><br><span class="line">        ArrayList&lt;Vector2d&gt; Key= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;tools.Vector2d&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;observationGrid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;observationGrid[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(observationGrid[i][j]!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;observationGrid[i][j].size();k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(observationGrid[i][j].get(k).itype==<span class="number">6</span>)&#123;</span><br><span class="line">                            Key.add(observationGrid[i][j].get(k).position);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//启发式函数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="title function_">heuristic</span><span class="params">(StateObservation stateObs,<span class="type">boolean</span> HasGetKey,<span class="type">int</span> dep)</span>&#123;</span><br><span class="line">        <span class="type">double</span> score=<span class="number">0</span>,W_0=<span class="number">0</span>,W_1=<span class="number">100000000</span>,W_2=<span class="number">100</span>,W_3=-<span class="number">5</span>,W_4_1=<span class="number">30</span>,W_4_2=<span class="number">10</span>,W_4_3=<span class="number">1000</span>,W_4_4=-<span class="number">10</span>,W_5=-<span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> Dep,WinorLose=<span class="number">0</span>,Nowscore=<span class="number">0</span>,Distance,Box_1=<span class="number">0</span>,Box_2=<span class="number">0</span>,Box_3=<span class="number">0</span>,Box_4=<span class="number">0</span>,GG=<span class="number">0</span>,MinDistanceBox=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Dep=dep;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stateObs.getGameWinner()==Types.WINNER.PLAYER_WINS)&#123;</span><br><span class="line">            WinorLose=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stateObs.getGameWinner()==Types.WINNER.PLAYER_LOSES)&#123;</span><br><span class="line">            WinorLose=-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Nowscore=stateObs.getGameScore();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(HasGetKey)&#123;</span><br><span class="line">            Distance=GetDistance(stateObs.getAvatarPosition(),goalpos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Distance=GetDistance(stateObs.getAvatarPosition(),keypos);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Vector2d&gt; Box=GetBox(stateObs);</span><br><span class="line">        ArrayList&lt;Observation&gt;[][] observationGrid= stateObs.getObservationGrid();</span><br><span class="line">        <span class="type">int</span>[][] Map=<span class="keyword">new</span> <span class="title class_">int</span>[observationGrid.length][observationGrid[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;observationGrid.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;observationGrid[i].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(observationGrid[i][j].size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;observationGrid[i][j].size();k++)&#123;</span><br><span class="line">                        Map[i][j]=observationGrid[i][j].get(k).itype;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Map[i][j]=-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ax=(<span class="type">int</span>)stateObs.getAvatarPosition().x/<span class="number">50</span>,ay=(<span class="type">int</span>)stateObs.getAvatarPosition().y/<span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;Box.size();i++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> x=(<span class="type">int</span>)Box.get(i).x/<span class="number">50</span>,y=(<span class="type">int</span>)Box.get(i).y/<span class="number">50</span>;</span><br><span class="line">            <span class="type">int</span> n=observationGrid.length,m=observationGrid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x==keypos.x/<span class="number">50</span>&amp;&amp;y==keypos.y/<span class="number">50</span>&amp;&amp; !HasGetKey) GG=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> is=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(ax==x&amp;&amp;(ay==y+<span class="number">1</span>||ay==y-<span class="number">1</span>)) is=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(ay==y&amp;&amp;(ax==x+<span class="number">1</span>||ax==x-<span class="number">1</span>)) is=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(ax==x-<span class="number">1</span>&amp;&amp;ay==y-<span class="number">1</span>) is=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(ax==x+<span class="number">1</span>&amp;&amp;ay==y+<span class="number">1</span>) is=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(ax==x-<span class="number">1</span>&amp;&amp;ay==y+<span class="number">1</span>) is=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(ax==x+<span class="number">1</span>&amp;&amp;ay==y-<span class="number">1</span>) is=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(!is) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x&lt;n-<span class="number">1</span>&amp;&amp;x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Map[x+<span class="number">1</span>][y]==-<span class="number">1</span>&amp;&amp;Map[x-<span class="number">1</span>][y]==-<span class="number">1</span>) Box_1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;m-<span class="number">1</span>&amp;&amp;y&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Map[x][y+<span class="number">1</span>]==-<span class="number">1</span>&amp;&amp;Map[x][y-<span class="number">1</span>]==-<span class="number">1</span>) Box_1++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x&lt;n-<span class="number">1</span>) <span class="keyword">if</span>(Map[x+<span class="number">1</span>][y]==<span class="number">2</span>) Box_2++;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;<span class="number">0</span>) <span class="keyword">if</span>(Map[x-<span class="number">1</span>][y]==<span class="number">2</span>) Box_2++;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;m-<span class="number">1</span>) <span class="keyword">if</span>(Map[x][y+<span class="number">1</span>]==<span class="number">2</span>) Box_2++;</span><br><span class="line">            <span class="keyword">if</span>(y&gt;<span class="number">0</span>) <span class="keyword">if</span>(Map[x][y-<span class="number">1</span>]==<span class="number">2</span>) Box_2++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(x&lt;n-<span class="number">1</span>&amp;&amp;x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Map[x+<span class="number">1</span>][y]==<span class="number">2</span>&amp;&amp;Map[x-<span class="number">1</span>][y]==-<span class="number">1</span>) Box_3++;</span><br><span class="line">                <span class="keyword">if</span>(Map[x-<span class="number">1</span>][y]==<span class="number">2</span>&amp;&amp;Map[x+<span class="number">1</span>][y]==<span class="number">1</span>) Box_3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(y&lt;m-<span class="number">1</span>&amp;&amp;y&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Map[x][y+<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;Map[x][y-<span class="number">1</span>]==-<span class="number">1</span>) Box_3++;</span><br><span class="line">                <span class="keyword">if</span>(Map[x][y-<span class="number">1</span>]==<span class="number">2</span>&amp;&amp;Map[x][y+<span class="number">1</span>]==-<span class="number">1</span>) Box_3++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Box_4+=GetDistanceHole(x*<span class="number">50</span>,y*<span class="number">50</span>,stateObs);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(HasGetKey) GG--;</span><br><span class="line"></span><br><span class="line">        MinDistanceBox=GetMinDistanceBox(stateObs);</span><br><span class="line"></span><br><span class="line">        score=W_0*Dep+W_1*WinorLose+W_2*Nowscore+W_3*Distance+W_4_1*Box_1+W_4_2*Box_2+W_4_3*Box_3+W_4_4*Box_4+GG*-<span class="number">1000000</span>+W_5*MinDistanceBox;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Types.ACTIONS&gt; Astar(Node StartNode, ElapsedCpuTimer elapsedTimer,<span class="type">int</span> dep)&#123;</span><br><span class="line">        <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">        Todolist.add(StartNode);</span><br><span class="line">        <span class="keyword">while</span>(!Todolist.isEmpty())&#123;</span><br><span class="line">            Node now=Todolist.pollFirst();</span><br><span class="line">            System.out.println(<span class="string">&quot;score= &quot;</span> + now.getScore() + <span class="string">&quot; depth= &quot;</span> + now.getDepth() + <span class="string">&quot; GetKey= &quot;</span> + now.GetKey + <span class="string">&quot;Positon= &quot;</span> + (now.getStateObs().getAvatarPosition().x/<span class="number">50</span>)+<span class="string">&quot;,&quot;</span>+(now.getStateObs().getAvatarPosition().y/<span class="number">50</span>)+<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">            tot++;</span><br><span class="line">            StateObservation stataObs=now.getStateObs();</span><br><span class="line">            Visited.add(stataObs);</span><br><span class="line">            ArrayList&lt;Types.ACTIONS&gt; actions = now.getStateObs().getAvailableActions();</span><br><span class="line">            <span class="keyword">for</span>(Types.ACTIONS action:actions)&#123;</span><br><span class="line">                <span class="type">StateObservation</span> <span class="variable">stCopy</span> <span class="operator">=</span> now.getStateObs().copy();</span><br><span class="line">                stCopy.advance(action);</span><br><span class="line">                ArrayList&lt;Types.ACTIONS&gt;  AstarAction= (ArrayList&lt;Types.ACTIONS&gt;) now.getActions().clone();</span><br><span class="line">                AstarAction.add(action);</span><br><span class="line">                <span class="keyword">if</span>(stCopy.getGameWinner()==Types.WINNER.PLAYER_WINS)&#123;</span><br><span class="line">                    OK=<span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> AstarAction;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(stCopy.getGameWinner()==Types.WINNER.PLAYER_LOSES||CheckifVisited(stCopy))&#123;</span><br><span class="line">                    AstarAction.remove(AstarAction.size()-<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="type">boolean</span> NowGetKey=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span>(Getkey(now.getStateObs()).size()==<span class="number">1</span>&amp;&amp; Getkey(stCopy).isEmpty())&#123;</span><br><span class="line">                    NowGetKey=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Node node=contain(Todolist,stCopy);</span><br><span class="line">                <span class="keyword">if</span>(node!=<span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="type">double</span> score0=node.getScore();</span><br><span class="line"></span><br><span class="line">                    <span class="type">double</span> score1=heuristic(stCopy,NowGetKey|now.GetKey,dep+<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">if</span>(score0&gt;=score1)&#123;</span><br><span class="line">                        AstarAction.remove(AstarAction.size()-<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        Node Newnode=<span class="keyword">new</span> <span class="title class_">Node</span>(score1,stCopy,AstarAction, dep+<span class="number">1</span>,NowGetKey|now.GetKey);</span><br><span class="line">                        Todolist.remove(node);</span><br><span class="line">                        Todolist.add(Newnode);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    Node Newnode=<span class="keyword">new</span> <span class="title class_">Node</span>(heuristic(stCopy,NowGetKey|now.GetKey,dep+<span class="number">1</span>),stCopy,AstarAction, dep+<span class="number">1</span>,NowGetKey|now.GetKey);</span><br><span class="line">                    Todolist.add(Newnode);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;GGGGGGGGGGGGGGGGGGGGGGG&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Types.ACTIONS&gt;());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Types.ACTIONS <span class="title function_">act</span><span class="params">(StateObservation stateObs, ElapsedCpuTimer elapsedTimer)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(OK==<span class="literal">false</span>)&#123;</span><br><span class="line">            Node StartNode=<span class="keyword">new</span> <span class="title class_">Node</span>(heuristic(stateObs,<span class="literal">false</span>,<span class="number">0</span>),stateObs.copy(),<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Types.ACTIONS&gt;(),<span class="number">0</span>,<span class="literal">false</span>);</span><br><span class="line">            MaxAction= Astar(StartNode,elapsedTimer,<span class="number">0</span>);OK=<span class="literal">true</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;AstarAction.size()= &quot;</span> + MaxAction.size());</span><br><span class="line">            <span class="keyword">return</span> MaxAction.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            numstep++;</span><br><span class="line">            <span class="keyword">return</span> MaxAction.get(numstep);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">printDebug</span><span class="params">(ArrayList&lt;Observation&gt;[] positions, String str)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (positions != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.print(str + <span class="string">&quot;:&quot;</span> + positions.length + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; positions.length; i++) &#123;</span><br><span class="line">                System.out.print(positions[i].size() + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;); &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;positions.length;i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;positions[i].size();j++)&#123;</span><br><span class="line">                    System.out.println(str + <span class="string">&quot; x=&quot;</span> + positions[i].get(j).position.x/<span class="number">50</span> + <span class="string">&quot; y=&quot;</span> + positions[i].get(j).position.y/<span class="number">50</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> System.out.print(str + <span class="string">&quot;: 0; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-5-algorithm-performance">2.3.5 Algorithm Performance</h3>
<p>至此Astar算法实现完毕，经过测试可以在<strong>总时间</strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>100</mn><mi>m</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">100ms</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span></span></span></span>内通过第1,2,3,5张图。从结果上证明了参数的设定和权值具有较高的泛化性和可行性。</p>
<p><strong>附图为运用Astar算法在单步100ms通过第一二三五关的截图（虽然设置的是单步，但是其实在第一步（100ms）内就找到了一条正确路径，后续不需要再搜索而是只需要读存好的actionlist就可以了）</strong><br>
<img src="image-1.png" alt=""><br>
<img src="image-2.png" alt="Alt text"><br>
<img src="image-3.png" alt="Alt text"><br>
<img src="image.png" alt="Alt text"></p>
<hr>
<h2 id="2-4-task4：">2.4 TASK4：</h2>
<h3 id="2-4-1-蒙特卡洛树搜索概述">2.4.1 蒙特卡洛树搜索概述</h3>
<p>首先了解一下蒙特卡洛树搜索。</p>
<ol>
<li>
<p><strong>初始化</strong>：</p>
<ul>
<li>创建一个根节点，代表当前的游戏状态或问题。</li>
<li>初始化根节点的统计信息，如访问次数和累积奖励。</li>
</ul>
</li>
<li>
<p><strong>选择</strong>：</p>
<ul>
<li>从根节点开始，通过一定策略选择子节点，直到达到叶子节点（尚未被扩展的节点）。</li>
<li>选择子节点的策略通常是根据已有信息，来平衡探索未知节点和利用已知节点之间的权衡。</li>
</ul>
</li>
<li>
<p><strong>扩展</strong>：</p>
<ul>
<li>对于已选中的叶子节点，根据可行的行动扩展它，生成一个或多个子节点。</li>
<li>如果子节点中的某个代表游戏结束状态，那么不再扩展它，而是直接进入模拟步骤。</li>
</ul>
</li>
<li>
<p><strong>模拟</strong>：</p>
<ul>
<li>针对扩展的子节点，执行随机模拟或随机走子，直到达到游戏结束状态或者达到一个预定的深度限制。</li>
<li>在模拟中通常使用随机策略，以模拟游戏状态的不确定性。</li>
</ul>
</li>
<li>
<p><strong>回溯</strong>：</p>
<ul>
<li>从模拟结束的节点开始，将模拟结果的奖励值（通常是游戏胜利与否的评估）反向传播回父节点，并更新父节点的统计信息，如访问次数和累积奖励。</li>
<li>这一步鼓励树搜索在每个节点上逐渐累积关于最佳动作的信息。</li>
</ul>
</li>
<li>
<p><strong>重复</strong>：</p>
<ul>
<li>重复执行选择、扩展、模拟和回溯步骤，直到达到某个停止条件，例如时间限制或迭代次数。</li>
</ul>
</li>
<li>
<p><strong>选择最佳行动</strong>：</p>
<ul>
<li>在根节点的所有子节点中选择具有最高价值（通常是累积奖励除以访问次数）的行动作为最佳行动。</li>
<li>返回最佳行动作为决策的结果。</li>
</ul>
</li>
</ol>
<p>蒙特卡洛树搜索通过不断地模拟和探索可能的决策路径，逐渐提高对最佳行动的估计，从而在复杂的决策问题中表现出色。实际上，只要迭代的次数足够多，其选择最优解的可能性会逼近1。</p>
<p>在给出的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>a</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>e</mi><mi>M</mi><mi>C</mi><mi>T</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">SampleMCTS</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">a</span><span class="mord mathdefault">m</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>中，其实现了一个十分简化的蒙特卡洛树搜索。</p>
<p>首先设定一个搜素深度和评价函数（由胜利与否和得分共同决定）。</p>
<p>然后在每一步中，用绝大部分时间去建树，迭代当前的最优解往下搜索，当到达搜索深度或者游戏结束时，反向传播不断更新父节点的值。</p>
<p>最终在时间耗尽前返回路过频率最高的那个action。（因为我们的评价函数与胜利、得分相关，即往这个方向走分多且容易胜利</p>
<p>以上。</p>
<h3 id="2-4-2-样例代码分析">2.4.2 样例代码分析</h3>
<p>由于蒙特卡洛树搜索算法是一步一步跑的，所以在act部分，每次传入当前的状态和剩余时间的接口即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Types.ACTIONS <span class="title function_">act</span><span class="params">(StateObservation stateObs, ElapsedCpuTimer elapsedTimer)</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Observation&gt; obs[] = stateObs.getFromAvatarSpritesPositions();</span><br><span class="line">    ArrayList&lt;Observation&gt; grid[][] = stateObs.getObservationGrid();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Set the state observation object as the new root of the tree.</span></span><br><span class="line">    mctsPlayer.init(stateObs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Determine the action using MCTS...</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">action</span> <span class="operator">=</span> mctsPlayer.run(elapsedTimer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//... and return it.</span></span><br><span class="line">    <span class="keyword">return</span> actions[action];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主体部分，rollback是随机往下面走并记录得分和胜利情况。<br>
backUp回溯过程中更新父节点的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(remaining &gt; <span class="number">2</span>*avgTimeTaken &amp;&amp; remaining &gt; remainingLimit)&#123;</span><br><span class="line">        <span class="type">ElapsedCpuTimer</span> <span class="variable">elapsedTimerIteration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ElapsedCpuTimer</span>();</span><br><span class="line">        <span class="type">SingleTreeNode</span> <span class="variable">selected</span> <span class="operator">=</span> treePolicy();</span><br><span class="line">        <span class="type">double</span> <span class="variable">delta</span> <span class="operator">=</span> selected.rollOut();</span><br><span class="line">        backUp(selected, delta);</span><br><span class="line"></span><br><span class="line">        numIters++;</span><br><span class="line">        acumTimeTaken += (elapsedTimerIteration.elapsedMillis()) ;</span><br><span class="line"></span><br><span class="line">        avgTimeTaken  = acumTimeTaken/numIters;</span><br><span class="line">        remaining = elapsedTimer.remainingTimeMillis();</span><br><span class="line">        <span class="comment">//System.out.println(elapsedTimerIteration.elapsedMillis() + &quot; --&gt; &quot; + acumTimeTaken + &quot; (&quot; + remaining + &quot;)&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//System.out.println(&quot;-- &quot; + numIters + &quot; -- ( &quot; + avgTimeTaken + &quot;)&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外值得一提的部分是uct函数的实现，该函数用于判断根节点的children中最有潜力的节点。</p>
<p>具体来说，每个节点的权值被定义经过的总分数的平均值再加上一个小小的随机扰动。</p>
<p>得到可以量化的分值后就可以选择最佳子节点了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SingleTreeNode <span class="title function_">uct</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">SingleTreeNode</span> <span class="variable">selected</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">double</span> <span class="variable">bestValue</span> <span class="operator">=</span> -Double.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (SingleTreeNode child : <span class="built_in">this</span>.children)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">hvVal</span> <span class="operator">=</span> child.totValue;</span><br><span class="line">        <span class="type">double</span> <span class="variable">childValue</span> <span class="operator">=</span>  hvVal / (child.nVisits + <span class="built_in">this</span>.epsilon);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        childValue = Utils.normalise(childValue, bounds[<span class="number">0</span>], bounds[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">uctValue</span> <span class="operator">=</span> childValue +</span><br><span class="line">                Agent.K * Math.sqrt(Math.log(<span class="built_in">this</span>.nVisits + <span class="number">1</span>) / (child.nVisits + <span class="built_in">this</span>.epsilon));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// small sampleRandom numbers: break ties in unexpanded nodes</span></span><br><span class="line">        uctValue = Utils.noise(uctValue, <span class="built_in">this</span>.epsilon, <span class="built_in">this</span>.m_rnd.nextDouble());     <span class="comment">//break ties randomly</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// small sampleRandom numbers: break ties in unexpanded nodes</span></span><br><span class="line">        <span class="keyword">if</span> (uctValue &gt; bestValue) &#123;</span><br><span class="line">            selected = child;</span><br><span class="line">            bestValue = uctValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selected == <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Warning! returning null: &quot;</span> + bestValue + <span class="string">&quot; : &quot;</span> + <span class="built_in">this</span>.children.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> selected;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-结语">3 结语</h2>
<p>在本次作业中，我实现了深度优先搜索，深度限制+Astar,Astar完全版，已经了解了蒙特卡洛算法。</p>
<p>从结果上来看，发现Astar算法的效果最好，而且在不同的地图中，只需要调整一下权值就可以很好的适应不同的地图。</p>
<p>而所给的样例蒙特卡洛算法的效果并不好，可能是因为其实现的比较简单，而且没有考虑到钥匙箱子的交互问题。</p>
<p>通过本次作业的学习，我对搜索算法有了不一样的认识，也对搜索算法的实现有了更深的理解。（debug呜呜呜</p>
<p>以上。</p>
<p>（所有的源码收录于<a href="https://github.com/detect42/HW_AIINTRO">github个人仓库</a>中）</p>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>实验报告</tag>
      </tags>
  </entry>
  <entry>
    <title>急雨-客栈-故事</title>
    <url>/post/cb15d88e.html</url>
    <content><![CDATA[<h2 id="center-急雨-客栈-故事-center"><center> 急雨·客栈·故事 </center></h2>
<font size=4>
<p>阴沉的天降下几粒雨点，狂风呼啸着刮过肃杀的街头，雨滴肆意飞溅的声音在街头猛地炸开。南方的雨向来是任性的也是没有征兆的。</p>
<p>一路小跑着的年轻人，匆匆踏步进入一家不起眼的客栈。</p>
<p>“这鬼天气，真是糟糕透了。”年轻人在客栈内抬头望向灰蒙蒙的天空，焦急地跺着脚。嘶拉嘶拉的雨声连绵不绝，一点也没有要停下的意思。年轻人轻叹一声，转身看向柜台前坐着的掌柜，“您好，能让我在这歇一歇脚吗，这雨——，实在是倒霉透了”。</p>
<p>掌柜是一位面善的老者，年轻时四处打拼希望出人头地不枉此生，但是到头来却觉得不如客栈安逸。“坐坐坐，不要客气。”掌柜指向离柜台最近的一张桌子，“这么突然的暴雨诶，喝酒品茶的熟人怕是不会来了，正闲得慌哩。”  年轻人的视线扫过客栈，藤椅稀错落有致地排列在厅室里，客栈不大，但是布置得几分精致，客栈无人，又让这精致萧条了几分。</p>
<p>“谢谢，不过我也没什么可以聊，相较于他人，我的人生没有波澜起伏，也没有太多的十字路口。要说故事，也许这场雨，这个客栈能算上一个。”掌柜笑了笑，“这就糟糕了，我这门口罗雀的小客栈本身也没有什么故事可谈，诶，要是平日里，可以听到旅者讲述远方的故事，或是听听当地人发发牢骚什么的。哎，你瞧，比如这位——”</p>
<p>披着泛旧的夹克，不太相符的圆顶帽，一位可以说是将如客栈外暴雨般的沧桑写在脸上的中年人轻轻推开客栈门，踱步走了进来，要了碗酒。熟练的绕过层层桌椅走到客栈里最靠窗的位子坐下，并没有说什么别的话。</p>
<p>年轻人正疑惑之时，掌柜边温酒一边继续说道：“对，就是这个人，平日里会讲一些不错的故事，你可以找他聊聊，说不定有一些不错的故事，顺便，我也可以在一旁听一听。”年轻人瞥了一眼窗外的雨，一点也没有要停的迹象，便点了点头，走到中年人对面的藤椅上坐下，“你好，听说你有许多不错的故事，我可以听一听吗？”</p>
<p>年轻人看向中年人时，中年人正凝视着窗外，中年人没有过多的表情，年轻人只能从他深邃的眼睛里看出若隐若现的忧郁。</p>
<p>“故事，哪有什么故事，我不过是一个过路人罢了。”中年人的眼神仍没有从窗外移开。</p>
<p>​       年轻人沉默了片刻，“这碗酒钱我付了，怎么样？”</p>
<p>​       中年人收回目光，端着酒碗喝上一口。</p>
<p>​       “从前，有一个悲剧人物叫<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mi>a</mi><mi>r</mi><mi>r</mi><mi>i</mi><mi>n</mi><mi>g</mi></mrow><annotation encoding="application/x-tex">Earring</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span></span></span></span>，他——”，“停停停，这你都讲了多少遍了。”掌柜倏地凑过来打断了中年人。“咳，过去有这么个传奇人物<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mi>d</mi><mi>x</mi><mi>c</mi><mi>a</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">idxcaicai</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord mathdefault">x</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span></span></span></span>”，“这也是老故事了，那几个传奇人物的故事都大同小异，没什么意思，我说伙计，不要拿它们混新人的酒钱。”</p>
<p>​       青年人笑了笑，似乎是想说什么，但是没有发声。</p>
<p>​       中年人顿了顿，拿起酒碗猛地喝了一半，“故事虽然不多，但新的总还是有的。”说罢，闭上眼，忆了忆。</p>
<p>​       “他叫作<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">detect</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span></span></span></span>，是一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>i</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">oier</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>（信息竞赛er），哦不，曾是个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>i</mi><mi>e</mi><mi>r</mi></mrow><annotation encoding="application/x-tex">oier</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span></span></span></span>。”</p>
<p>​       “喂，等等，你这不会是现编的吧。”掌柜已就近搬来一张藤椅，做了下来。</p>
<p>​       “现编的又怎样，现实是现实，故事是故事，故事始于生活最后高于生活，所以故事才能比生活更有趣。” 对面的年轻人肯定地点了点头。</p>
<p>​       中年人得意的一笑，一口气将碗里剩下的酒喝完，继续讲了下去：</p>
<p>​       “最初，他只是一个在数学上不错，文化课略显蹩脚的普通初中生。在班级号召下，学习着数学竞赛。他也并不是最顶尖或是最用功的一撮。但是在一个四月，他同时取得了数学竞赛和文化课半期考试非常不错的成绩，是因为运气好，还是之前没有尽力，鬼知道呢。”</p>
<p>​       “又是这样的开局，然后呢？希望有点与众不同的东西。”掌柜大笑着打断道。</p>
<p>​       年轻人没有发言，只是安静地听着。</p>
<p>​       “这个节骨眼上的喜讯刺激着他下定决心继续数学竞赛，他的数学老师本就是当地出名的竞赛教练，他的数学竞赛征途本应就此正式展开。但是，命运这个东西，能够预测的话就不能称之命运了。不幸的是，在同一年的秋天，教育部以减压之名强制停办了大部分学科竞赛。虽然被迫告别了数学竞赛，但是他的热情已经被点燃，秉着对计算机的主观上的兴趣和客观上经教育部减压后幸存的信息竞赛，他选择了试试信息竞赛，彼时的他还不知道日后等待着他的会是什么。“</p>
<p>​       中年人顿了顿，吸上一口气调整语调。</p>
<p>​       “经过一学期课余时间的努力，他得到了暑假与高中生一起集训的机会，他以高中竞赛生为目标，没日没夜的追赶着。逐渐，他忘记了最初资质平平的自己，开始接收其他强者的拥抱。白驹过隙般，初中时光就这么走过，他收获了一个二等一个一等，哦，还有一个相对不错足以让他去有着信息竞赛传统的高中的中考成绩。”</p>
<p>​       “他的高中的竞赛体系算比较完备，意味着他有了选择停上文化课全力冲刺竞赛的机会，他看着优秀学长们的一块块总决赛奖牌发愣，有朝一日，这也会是他的命运吗？不过除了难懂的竞赛知识，还有一件让他费解的事，周围起初在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">oi</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">i</span></span></span></span>（信息竞赛）上展露天赋的同学，却一个个选择了退出。在他还没意识到的时候，愿意停课冲刺竞赛的人已然越来越少了。另外值得一提的是一个周末，同学突然遗憾地对他说：</p>
<p>‘<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>e</mi><mi>t</mi><mi>e</mi><mi>c</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">detect</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span></span></span></span>，我可能学不了多久了。’</p>
<p>‘为什么？’</p>
<p>‘我父母还是担心我的文化课成绩，不再支持我继续学下去，我文化课成绩本就不好，也说不过他们。你父母支持你真是幸运。’</p>
<p>忘了说，这位同学叫<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>s</mi><mtext>君</mtext></mrow><annotation encoding="application/x-tex">Rs君</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">s</span><span class="mord cjk_fallback">君</span></span></span></span>，和他一样的人不少。这也不禁让他思考起来，回报和风险，幸运与遗憾总是同时存在。”</p>
<p>“然后呢，他有选择取舍吗？”年轻人似乎被吊起了兴致，开始主动发问。</p>
<p>“多少个夜晚，他独自在偌大却空无一人的操场上踱步，不远处教学楼灯火通明，他的高中同学们此时正上着文化课晚自习，他时而叹气，时而握紧拳头，路过不那么亮的路灯，路过球场，路过单杠，他就这么走啊走，在心里小心翼翼地评估着未来。他会觉得选择了的事不能止于半道，也会突然感觉如履薄冰徒留迷惘。”</p>
<p>中年人说话的间隙，掌柜已然重温了一碗酒，中年人顺手接下。</p>
<p>“一定到高潮了吧” 掌柜有感而问。</p>
<p>中年人笑笑，没有回答。</p>
<p>“他最后还是坐回了曾让他心驰神往的机房，至于原因，谁知道呢。知道的只是从此他的轴迹便和普通高中生彻底分叉开来，没有了周考月考、晚自习、甚至日常课表，取而代之的则是竞赛培训和日复一日的模拟考。令他记忆犹新的是，钟老师操着厚重北方口音，配着抽象的课件，让他明白什么是听不清、看不明、学不懂、以及认真听课的他是多么的愚蠢。他认识到自己的程序时间常数总是莫名其妙地比别人大（雾），并在日后的大大小小比赛中得到有效实践（悲）。”</p>
<p>“当然，信息竞赛也不乏有趣的事。起初，或是因为腼腆或是相互推让，大家都不愿意主动讲题，可是一旦教练宣布讲题奖励奶茶政策后，大家又抢得不可开交。平日里霸榜<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mi>a</mi><mi>n</mi><mi>k</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">rank1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord">1</span></span></span></span>的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>s</mi><mi>y</mi><mi>o</mi></mrow><annotation encoding="application/x-tex">fsyo</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">s</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">o</span></span></span></span>乐此不疲地讲着水题，腼腆的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mi>s</mi><mi>s</mi><mi>s</mi><mi>t</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">wssstc</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">c</span></span></span></span>总是小声嘀咕着奇奇怪怪的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>j</mi></mrow><annotation encoding="application/x-tex">loj</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>题，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>m</mi><mi>h</mi></mrow><annotation encoding="application/x-tex">pmh</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault">m</span><span class="mord mathdefault">h</span></span></span></span>仍维持着高冷的形象，只言片语便讲完一道<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">CF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span></span></span></span>神题。”他沉浸在这样的时光里，每晚压着十点半点校门关闭背着电脑离开学校。他经历了许多，学习新知识的激动，模拟考翻车的遗憾，讲题后收获掌声的喜悦骄傲，以及被考题暴打的无力感。那一年的联赛，虽然他考得烂透了，但他没有抱怨，仍感谢上苍能继续学下去，毕竟机会还未泯灭。”</p>
<p>“时间过得很快，转眼到了高二的寒假，他的联赛成绩虽然不够理想但是足以让他入围省队选拔，只要进了省队，离他梦想中的奖牌便只是一步之遥。”</p>
<p>“你这么说，不会这个时候出了什么事吧。”掌柜问道。</p>
<p>“谁也想不到是，他在的省的传统省选被取消了，取而代之的选拔方式则是题目数量少而怪的冬令营题目，意味着所有人被卷入一场完全不可预知的博弈。”</p>
<p>“是他的省出什么事了吗？”年轻人紧跟着发问。</p>
<p>“无可奉告”</p>
<p>“那他的省选怎么样了”</p>
<p>“你问得太快了。”掌柜对年轻人说。年轻人将抬起的手缓缓放下，“抱歉，请继续吧”。</p>
<p>“他倒是没有过多的不安，自他选择信息竞赛的一刻起，已经做好了最坏的打算。’已经没什么好害怕的了‘他常常这么安慰自己。”</p>
<p>“最后的冬令营考试前，他唯一期望的是最后能安心看着挂着的钟摆结束考试。但是命运并没有给他这个廉价的礼物。他在最后十五分钟猛地发现第一题算法假掉了，慌忙中的补救并没有奏效，这十五分钟可悲地成了他<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mi>I</mi></mrow><annotation encoding="application/x-tex">OI</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span></span></span></span>生涯的倒计时。”</p>
<p>“故事就这么结束了？他就这么退役了？”年轻人显得不可置信。</p>
<p>中年人重新看向窗外，密密麻麻的雨点开始变得稀疏，雨点打在水坑上的涟漪已然清晰可见。中年人又抿了一口酒缓缓地说：“是啊，退役了。”</p>
<p>掌柜缓缓站了起来，“这种人我听得多了也见的多了，不是所有的努力与梦想都有回报，如果你代入他们或许或觉得感伤，但是见得多了，也就不觉得了。医院里有人不幸过世时，年轻的实习者往往会和家属一起落泪，但是经验丰富的医生往往只会微叹一口气。道理是一样的。况且在追求高远目标的途中默默陨落也没什么好同情的，毕竟任何成功和奇迹都是有代价的，而代价早该在出发前就想清楚。不过，伙计，你这故事还是不错的，对得起新人的酒钱。这会儿雨要停了，我得准备接客了，把钱放柜台上就行。”掌柜离开了藤椅。</p>
<p>中年人急着道：“你看故事还没讲完呢，后来他重头学习高中文化课，很快和班级打成一片，下棋乒乓球也不错”。</p>
<p>但是掌柜已然走开了。</p>
<p>噼噼啪啪的雨声消失了，路上行人的身影又多了起来，天空似乎都了亮了些。一缕阳光穿透云层的空隙射进客栈窗户，只听得见雨滴从屋檐规律落下的滴答声。</p>
<p>“我走晚点没有关系，接下来呢？”年轻人忽的说道。</p>
<p>中年人把目光拉了回来，眼角渐渐放松，用着一种柔和的目光看向年轻人。“很少见到对这个故事如此感兴趣的人，不过记住，这也不过是我道听途说的故事罢了，无论有多么吸引人，不要总是听信他人的故事，属于你的选择始终在当下。”</p>
<p>“我当然会选择当下，一路我都是这么过来的，您能继续了吗？”</p>
<p>“后来啊，他很快融入了班级，和正常的高中生一样参加了高考，但冗杂且繁多的文化课并没有给他留下太多印象，他选择记住了同学聚餐，一个个玩笑，以及晚自习溜去打球的紧张与兴奋。”</p>
<p>阴云已然散去，几洼浅浅的积水倒映着明亮的天空，雨后的客栈显得更加朴素而又柔和。</p>
<p>“当然，他的故事并没有结束，他考上了南京大学，再后来……”<br>
<font size=4></p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>概率与期望入门</title>
    <url>/post/5572c508.html</url>
    <content><![CDATA[<h2 id="期望">期望</h2>
<h3 id="性质1：期望的线性关系">性质1：期望的线性关系</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo>+</mo><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>+</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(X+Y)=E(X)+E(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></p>
<p>期望的可加性永远适用，即使<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo separator="true">,</mo><mi>Y</mi></mrow><annotation encoding="application/x-tex">X,Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span></span></span></span>并非独立。</p>
<h2 id="样本期望均值的期望">样本期望均值的期望</h2>
<p>与总期望一致。</p>
<h2 id="期望的乘积关系">期望的乘积关系</h2>
<ul>
<li>对于独立随机变量：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(XY)=E(X)*E(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></msubsup><mi>X</mi><mi>f</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(x)=\sum_{i=1}^m Xf(X)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>Y</mi><mi>g</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(y)=\sum_{j=1}^nYg(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24011em;vertical-align:-0.43581800000000004em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.43581800000000004em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo><mo>∗</mo><mi>E</mi><mo stretchy="false">(</mo><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(X)*E(Y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>拆出来就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>X</mi><mn>1</mn></msub><msub><mi>Y</mi><mn>1</mn></msub><mi>f</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mi>g</mi><mo stretchy="false">(</mo><msub><mi>Y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">X_1Y_1f(X_1)g(Y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，因为变量独立，所欲等于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>X</mi><mn>1</mn></msub><msub><mi>Y</mi><mn>1</mn></msub><mo>∗</mo><mi>h</mi><mo stretchy="false">(</mo><msub><mi>X</mi><mn>1</mn></msub><msub><mi>Y</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X_1Y_1*h(X_1Y_1))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.22222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>X</mi><mi>Y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(XY)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.07847em;">X</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span>。</p>
<h2 id="方差">方差</h2>
<h3 id="定义式">定义式</h3>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mo>∑</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Var(x)=\sum(x-\mu)^2f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
<h3 id="等价式">等价式</h3>
<ol>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><mi>μ</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>μ</mi><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Var(x)=E((x-\mu)^2),\mu=E(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault">μ</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">μ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span></p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mo stretchy="false">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo stretchy="false">)</mo><mo>−</mo><mi>E</mi><mo stretchy="false">(</mo><mi>x</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">Var(x)=E(x^2)-E(x)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
</li>
</ol>
<img src="2.png" width="60%" height="60%">
<h3 id="独立随机变量的可加性">独立随机变量的可加性</h3>
<p>对于独立随机变量 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><mo>…</mo><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_1,x_2,\dots x_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><mo>…</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>V</mi><mi>a</mi><mi>r</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Var(x_1+x_2+\dots x_n)=Var(x_1)+Var(x_2)+\dots +Var(x_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<hr>
<h3 id="条件独立和独立不是等价的概念">条件独立和独立不是等价的概念。</h3>
<hr>
<h2 id="协方差与独立性">协方差与独立性</h2>
<p>协方差的定义是从数字的表示特征出发进行概况的而随机变量独立性的定义更触及本质一些，即：X的取值不会影响Y的条件分布，因此独立性的描述意义要更强。</p>
<img src="3.png" width="60%" height="60%">
<hr>
]]></content>
      <tags>
        <tag>机器学习 概率统计</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/post/2f57a694.html</url>
    <content><![CDATA[<h2 id="正则表达式入门"><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017639890281664">正则表达式入门</a></h2>
<p>视觉上反人类但是好用的tool。</p>
]]></content>
      <tags>
        <tag>tool</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索和演化算法HW1实验报告</title>
    <url>/post/c9d5e149.html</url>
    <content><![CDATA[<h1 id="center-报告题目：pacman-game-center"><center> 报告题目：Pacman Game </center></h1>
<h3 id="center-detect0530-gmail-com-center"><center> <a href="mailto:detect0530@gmail.com">detect0530@gmail.com</a> </center></h3>
<h1 id="1-引言">1 引言</h1>
<p>在个人过去的实践中，搜索算法是低效暴力的代名词，但是通过本课程的学习，从深度优先宽度优先到代价优先，再到A*算法，我才发现搜索算法的强大之处。优秀的启发式函数可以大大提高搜索效率，搜索算法的强大之处在于其可以解决各式各样的问题，比如本次实验中的pacman游戏，可以通过搜索算法来解决。并在一次次优化算法的过程中，我也对搜索算法有了更深的理解。</p>
<h1 id="2-实验内容">2 实验内容</h1>
<h2 id="2-1-task1-dfs-bfs-in-maze-problem">2.1 TASK1 dfs&amp;bfs in Maze Problem</h2>
<h3 id="2-1-1-防止走同样的点">2.1.1 防止走同样的点</h3>
<p>和所有的搜索算法一样，如果遇到了重复的点，那么大可不必再走一遍。</p>
<p>于是在后续所有的程序里，我用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>t</mi><mi>e</mi><mi>d</mi><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">VisitedNode</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span>作为list存储当前的已经走过的状态，如果当前状态已经走过，那么就不再走这个点。</p>
<h3 id="2-1-2-数据结构的选择">2.1.2 数据结构的选择</h3>
<p>在这个实验中，我选择了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>t</mi><mi>a</mi><mi>c</mi><mi>k</mi></mrow><annotation encoding="application/x-tex">Stack</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>作为深度优先搜索的数据结构，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>作为宽度优先搜索的数据结构。</p>
<h3 id="2-1-3-核心代码展示">2.1.3 核心代码展示</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**宽度优先搜索**</span><br><span class="line"></span><br><span class="line">startNode = problem.getStartState()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> problem.isGoalState(startNode):</span><br><span class="line">    <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">Que= util.Queue()</span><br><span class="line">VisitedNode = []</span><br><span class="line">Que.push((startNode, []))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> Que.isEmpty():</span><br><span class="line">    Nownode, actions = Que.pop()</span><br><span class="line">    <span class="keyword">if</span> (Nownode <span class="keyword">not</span> <span class="keyword">in</span> VisitedNode):</span><br><span class="line">        VisitedNode.append(Nownode)</span><br><span class="line">        <span class="keyword">if</span> problem.isGoalState(Nownode):</span><br><span class="line">            <span class="keyword">return</span> actions</span><br><span class="line">        <span class="keyword">for</span> nextNode, nextAction, cost <span class="keyword">in</span> problem.getSuccessors(Nownode):</span><br><span class="line">            newAction = actions + [nextAction]</span><br><span class="line">            Que.push((nextNode, newAction))</span><br><span class="line"></span><br><span class="line">util.raiseNotDefined()</span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-实验结果">2.1.4 实验结果</h3>
<p>我们统一用拓展节点数作为评价指标，下面是实验结果：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>深度优先搜索</th>
<th>宽度优先搜索</th>
</tr>
</thead>
<tbody>
<tr>
<td>bigMaze</td>
<td>390</td>
<td>620</td>
</tr>
</tbody>
</table>
<p>这是在正确路径只有一条的时候，如果有多条路径，可想而知其expandnode会大大增加。</p>
<hr>
<h2 id="2-2-task2-a-search-in-maze-problem">2.2 TASK2 A* Search in Maze Problem</h2>
<h3 id="2-2-1-设计代价函数">2.2.1 设计代价函数</h3>
<p>在这个实验中，我选择了曼哈顿距离作为启发式函数，即<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mn>1</mn><mo>−</mo><mi>x</mi><mn>2</mn><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mn>1</mn><mo>−</mo><mi>y</mi><mn>2</mn><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x1-x2|+|y1-y2|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mord">2</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">2</span><span class="mord">∣</span></span></span></span>。</p>
<p>因为只有一个目标，所以我们的大方向是往<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span>, 故而我们的启发式函数是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>x</mi><mn>1</mn><mo>−</mo><mn>1</mn><mi mathvariant="normal">∣</mi><mo>+</mo><mi mathvariant="normal">∣</mi><mi>y</mi><mn>1</mn><mo>−</mo><mn>1</mn><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|x1-1|+|y1-1|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">x</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">∣</span></span></span></span>。这样能让我们的程序尽可能往目标点靠近。</p>
<p>(尽管在一些时候，迷宫经过设计，不一定走得通的路径，但是我们的启发式函数能够保证我们的程序能够尽可能的往目标点靠近，而不是南辕北辙乱走。)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">myHeuristic</span>(<span class="params">state, problem=<span class="literal">None</span>, Map=<span class="literal">None</span></span>):</span><br><span class="line">    (Goal_x, Goal_y) = problem.goal</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(state[<span class="number">0</span>] - Goal_x) + <span class="built_in">abs</span>(state[<span class="number">1</span>] - Goal_y) + Map[state[<span class="number">0</span>]][state[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-一点优化">2.2.2 一点优化</h3>
<p>对于迷宫问题，一个常见的问题是如何避免走进迷宫的死胡同里。在网格迷宫里，死胡同一定有的特征是最终会到一个三面都是墙的情况。</p>
<p>那么显然，如果我们能预处理判断出那些路是死胡同，那么我们就可以在搜索的时候避免走进死胡同。从而节省大量的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mi>x</mi><mi>p</mi><mi>a</mi><mi>n</mi><mi>d</mi><mi>N</mi><mi>o</mi><mi>d</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">expandNode</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">p</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span></span></span></span>开销。</p>
<ul>
<li>
<h4 id="2-2-2-1-如果判断死胡同">2.2.2.1 如果判断死胡同</h4>
</li>
</ul>
<p>所有三面是墙的点都是不必要访问点，其次，如果上下左右有两面墙，且可以走的两个格子里有一个是不必要访问点，那么这个点也是不必要访问点。</p>
<ul>
<li>
<h4 id="2-2-2-2-预处理死胡同">2.2.2.2 预处理死胡同</h4>
</li>
</ul>
<p>具体地，我们在代码里用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">map</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span></span></span></span> list记录一个格子周围的墙壁数量，如果是3，那么这个点就是死胡同（不必要访问点）。</p>
<p>接着我们进行循环，每一次找map值为2的格子，如果其相邻的格子有不可访问点，那么这个格子也是不可访问点。我们一直执行这个循环直到没有新的不可访问点出现。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Build_Map_With_Block</span>(<span class="params">problem</span>):</span><br><span class="line">    <span class="built_in">map</span> = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.height)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.width)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.height):</span><br><span class="line">            <span class="keyword">if</span> problem.walls[i][j]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># print(i,j)</span></span><br><span class="line">            <span class="keyword">for</span> action <span class="keyword">in</span> [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]:</span><br><span class="line">                x, y = i, j</span><br><span class="line">                dx, dy = Actions.directionToVector(action)</span><br><span class="line">                nextx, nexty = <span class="built_in">int</span>(x + dx), <span class="built_in">int</span>(y + dy)</span><br><span class="line">                <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= problem.walls.width <span class="keyword">or</span> nexty &gt;= problem.walls.height:</span><br><span class="line">                    <span class="built_in">map</span>[i][j] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> problem.walls[nextx][nexty]:</span><br><span class="line">                    <span class="built_in">map</span>[i][j] += <span class="number">1</span></span><br><span class="line">    <span class="built_in">map</span>[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        tot=<span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.width):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.height):</span><br><span class="line">                <span class="keyword">if</span> problem.walls[i][j]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">for</span> action <span class="keyword">in</span> [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]:</span><br><span class="line">                    x, y = i, j</span><br><span class="line">                    dx, dy = Actions.directionToVector(action)</span><br><span class="line">                    nextx, nexty = <span class="built_in">int</span>(x + dx), <span class="built_in">int</span>(y + dy)</span><br><span class="line">                    <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= problem.walls.width <span class="keyword">or</span> nexty &gt;= problem.walls.height:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">map</span>[nextx][nexty] == <span class="number">3</span> <span class="keyword">and</span> <span class="built_in">map</span>[i][j] == <span class="number">2</span>:</span><br><span class="line">                        <span class="built_in">map</span>[i][j] = <span class="number">3</span></span><br><span class="line">                        tot+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> tot == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.height):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">map</span>[i][j] == <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="number">100000</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">map</span>[i][j] == <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">map</span>[i][j] == <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="number">0</span></span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">map</span>[i][j] == <span class="number">0</span>:</span><br><span class="line">                <span class="built_in">map</span>[i][j] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map</span></span><br></pre></td></tr></table></figure>
<p>可以从代码中看出，我讲不必要走的点map值映射为100000，这样在启发式函数中，加上当前位置的map值，如果是死胡同，那么则不会优先选择这个点。</p>
<h3 id="2-2-4-启发式合并框架">2.2.4 启发式合并框架</h3>
<p>其实和宽度优先搜索很相似，只不过在实现中讲<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">queue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>换成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">priorityqueue</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span>，将<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">priority</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>设置为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>+</mo><mi>h</mi><mi>e</mi><mi>u</mi><mi>r</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">cost+heuristic</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69841em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span></span></span></span>。</p>
<h3 id="2-2-5-核心代码展示">2.2.5 核心代码展示</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">aStarSearch</span>(<span class="params">problem, heuristic=nullHeuristic</span>):</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> heuristic != myHeuristic:</span><br><span class="line">       Map = Build(problem)</span><br><span class="line">   <span class="keyword">else</span>:</span><br><span class="line">       Map=Build_Map_With_Block(problem)</span><br><span class="line"></span><br><span class="line">   startNode = problem.getStartState()</span><br><span class="line"></span><br><span class="line">   startcost = heuristic(startNode, problem , Map)</span><br><span class="line">   <span class="keyword">if</span> problem.isGoalState(startNode):</span><br><span class="line">       <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line">   P_Que = util.PriorityQueue()</span><br><span class="line">   VisitedNode = []</span><br><span class="line"></span><br><span class="line">   <span class="built_in">print</span>(startcost)</span><br><span class="line"></span><br><span class="line">   <span class="comment"># item: (node, action, cost)</span></span><br><span class="line">   P_Que.push((startNode, [], <span class="number">0</span>), startcost)</span><br><span class="line">   Show=<span class="number">0</span></span><br><span class="line">   <span class="keyword">while</span> <span class="keyword">not</span> P_Que.isEmpty():</span><br><span class="line">       (currentNode, actions, preCost) = P_Que.pop()</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> Show &lt; preCost + heuristic(currentNode, problem,Map):</span><br><span class="line">           Show = preCost + heuristic(currentNode, problem,Map)</span><br><span class="line">           <span class="built_in">print</span>(<span class="string">&quot;noedepth: &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(Show))</span><br><span class="line">           </span><br><span class="line">       <span class="keyword">if</span> (currentNode <span class="keyword">not</span> <span class="keyword">in</span> VisitedNode):</span><br><span class="line">           VisitedNode.append(currentNode)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> problem.isGoalState(currentNode):</span><br><span class="line">               <span class="keyword">return</span> actions</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> nextNode, nextAction, nextCost <span class="keyword">in</span> problem.getSuccessors(currentNode):</span><br><span class="line">               newAction = actions + [nextAction]</span><br><span class="line">               G_Cost = problem.getCostOfActions(newAction)</span><br><span class="line">               newPriority = G_Cost + heuristic(nextNode, problem,Map)</span><br><span class="line">               P_Que.push((nextNode, newAction, G_Cost), newPriority)</span><br><span class="line"></span><br><span class="line">   util.raiseNotDefined()</span><br></pre></td></tr></table></figure>
<h3 id="2-2-6-实验结果">2.2.6 实验结果</h3>
<p>我们统一用拓展节点数作为评价指标，下面是实验结果：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>A* Search</th>
</tr>
</thead>
<tbody>
<tr>
<td>bigMaze（不加优化）</td>
<td>549</td>
</tr>
<tr>
<td>bigMaze（加优化）</td>
<td>266</td>
</tr>
</tbody>
</table>
<p>可以看到，不加优化的A*算法比宽度优先搜索更加优秀。</p>
<p>而在添加优化后，甚至在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mi>i</mi><mi>g</mi><mi>M</mi><mi>a</mi><mi>z</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">bigMaze</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span></span></span></span>这张只有一条路的地图中比dfs还要优秀得多。</p>
<p>证明程序表现相当不错。</p>
<h2 id="2-3-task3-a-search-in-foodsearch-problem">2.3 TASK3 A* Search in FoodSearch Problem</h2>
<h3 id="2-3-1-问题分析">2.3.1 问题分析</h3>
<p>这是一个相当困难的问题，因为我们的目标是吃到所有的食物，而不是吃到一个食物且要保证最短路径。</p>
<p>我尝试用默认的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi>u</mi><mi>l</mi><mi>l</mi><mi>H</mi><mi>e</mi><mi>u</mi><mi>r</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">nullHeuristic</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span></span></span></span>函数，<strong>但是显然在任何地图中都无法在跑出结果（expandnode根本就不在能跑的数量级上）</strong>。</p>
<p>这意味着我们的启发式函数的设计至关重要。</p>
<p>而如何设计出优秀的启发式函数且满足<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>a</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">admissiable</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">consistant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>的要求，且看接下来的分解。</p>
<h3 id="2-3-2-启发式函数的设计">2.3.2 启发式函数的设计</h3>
<hr>
<ul>
<li>
<h3 id="heuristic-function-1"><strong>Heuristic Function 1</strong></h3>
</li>
</ul>
<p>一种合理的FoodSearch方法是从边缘开始，不断减少由food行成的凸包的直径。</p>
<p>这里的凸包定义为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>v</mi><mi>e</mi><mi>x</mi><mi>h</mi><mi>u</mi><mi>l</mi><mi>l</mi><mo stretchy="false">(</mo><mi>f</mi><mi>o</mi><mi>o</mi><mi>d</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">convexhull(food)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">h</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mclose">)</span></span></span></span>，代表包住所有食物的最小凸多边形。</p>
<p>而凸包的直径定义为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>v</mi><mi>e</mi><mi>x</mi><mi>h</mi><mi>u</mi><mi>l</mi><mi>l</mi><mo stretchy="false">(</mo><mi>f</mi><mi>o</mi><mi>o</mi><mi>d</mi><mo stretchy="false">)</mo></mrow></msub><mi mathvariant="normal">∥</mi><mi>x</mi><mo>−</mo><mi>y</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">max_{x,y\in convexhull(food)}\|x-y\|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord">∥</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∥</span></span></span></span>。（由于是在网格上这里的距离为曼哈顿距离）</p>
<p>也就是说我们希望在搜索的同时能够减少凸包的直径，这是符合直觉的。</p>
<p>同时由于我们随机游走也可能导致凸包直径不变，搜索我们还需要引导其去吃豆子，所有增加一个<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Mindis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span>表示当前状态到最近的豆子的距离。</p>
<p>于是我们的启发式函数设计为：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>v</mi><mi>e</mi><mi>x</mi><mi>h</mi><mi>u</mi><mi>l</mi><mi>l</mi><mo stretchy="false">(</mo><mi>f</mi><mi>o</mi><mi>o</mi><mi>d</mi><mo stretchy="false">)</mo></mrow></msub><mi mathvariant="normal">∥</mi><mi>x</mi><mo>−</mo><mi>y</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">max_{x,y\in convexhull(food)}\|x-y\|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord">∥</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∥</span></span></span></span> + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Mindis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span>。</p>
<ul>
<li><strong>Heuristic Function 1 的最优性验证</strong></li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Admissible</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span>验证：显然，我们至少需要先走到豆子，然后至少走凸包直径那么多点才能吃到所有的豆子，所以启发式函数一定是小于等于实际距离。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Consistent</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>验证：分两种情况：</p>
<ol>
<li>
<p>当前一步没吃到豆子，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Mindis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span>最多减一，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mi>a</mi><msub><mi>x</mi><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>c</mi><mi>o</mi><mi>n</mi><mi>v</mi><mi>e</mi><mi>x</mi><mi>h</mi><mi>u</mi><mi>l</mi><mi>l</mi><mo stretchy="false">(</mo><mi>f</mi><mi>o</mi><mi>o</mi><mi>d</mi><mo stretchy="false">)</mo></mrow></msub><mi mathvariant="normal">∥</mi><mi>x</mi><mo>−</mo><mi>y</mi><mi mathvariant="normal">∥</mi></mrow><annotation encoding="application/x-tex">max_{x,y\in convexhull(food)}\|x-y\|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1052em;vertical-align:-0.3551999999999999em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.34480000000000005em;"><span style="top:-2.5198em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="mpunct mtight">,</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">x</span><span class="mord mathdefault mtight">h</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">d</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3551999999999999em;"><span></span></span></span></span></span></span><span class="mord">∥</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord">∥</span></span></span></span>不变，所以评价函数的差不会大于1。</p>
</li>
<li>
<p>当前吃到了豆子，那么<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Mindis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span>不可能比1再小了，同时二维平面上的三角距离不等式知：凸包直径减少量一定比<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Mindis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span>大，所以评价函数的差不会大于1。</p>
</li>
</ol>
<p>综上所述，这个启发式函数是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">admissible</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">consistant</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>的。</p>
<hr>
<ul>
<li>
<h3 id="heuristic-function-2"><strong>Heuristic Function 2</strong></h3>
</li>
</ul>
<p>另一种合理的FoodSearch方法是我们尝试让所有点与当前位置计算出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>z</mi><mi>e</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">MazeDistance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span></span></span></span>（即迷宫中的最短距离），然后选择其中的最大值作为启发式函数。这种方法引导我们去不断减小这个最大值，直到所有的豆子都被吃掉。</p>
<ul>
<li><strong>Heuristic Function 2 的最优性验证</strong></li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Admissible</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span>验证：显然，吃完所有豆子至少要走<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>M</mi><mi>a</mi><mi>z</mi><mi>e</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">MaxMazeDistance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span></span></span></span>步数</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Consistent</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>验证：走一步<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>x</mi><mi>M</mi><mi>a</mi><mi>z</mi><mi>e</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">MaxMazeDistance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span></span></span></span>最多减少一点，所以评价函数的差不会大于1。</p>
<hr>
<h3 id="heuristic-function-3"><strong>Heuristic Function 3</strong></h3>
<p>最后针对一字排开引导我们去吃的地图，一种思路是我们尽可能吃能吃的。</p>
<p>对应的启发式函数设计：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>s</mi><mo>+</mo><mi>R</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>N</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>F</mi><mi>o</mi><mi>o</mi><mi>d</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">Mindis + RemainNumberFood - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> （Mindis指当前位置到最近的豆子的距离，RemainNumberFood指当前剩余的豆子数量）</p>
<ul>
<li><strong>Heuristic Function 3 的最优性验证</strong></li>
</ul>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>d</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>i</mi><mi>b</mi><mi>l</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Admissible</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">d</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span></span></span></span>验证：显然，完成路径至少要走到豆子，且至少还要走完剩下的豆子-1步才能完成。</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Consistent</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span></span></span></span>验证：分两种情况：</p>
<ol>
<li>没吃到豆子：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Mindis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span>最多减一，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>N</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>F</mi><mi>o</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">RemainNumberFood</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span>不变，所以评价函数的差不会大于1。</li>
<li>吃到了豆子：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>i</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">Mindis</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span></span></span></span>不可能比1再小了，同时<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mi>e</mi><mi>m</mi><mi>a</mi><mi>i</mi><mi>n</mi><mi>N</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>F</mi><mi>o</mi><mi>o</mi><mi>d</mi></mrow><annotation encoding="application/x-tex">RemainNumberFood</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">b</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span></span></span></span>最多减一，所以评价函数的差不会大于1。</li>
</ol>
<hr>
<hr>
<p>所以综上，我们设计了三个启发式函数，为了最优化我们取</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>e</mi><mi>u</mi><mi>r</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>c</mi><mi>F</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>H</mi><mn>1</mn><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>H</mi><mn>2</mn><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>H</mi><mn>3</mn><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">HeuristicFuction() = max(H1(),H2(),H3())
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">1</span><span class="mopen">(</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">2</span><span class="mopen">(</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">3</span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>作为最终的启发式函数。</p>
<hr>
<h3 id="2-3-3-计算heuristic-function的准备工作">2.3.3 计算Heuristic Function的准备工作</h3>
<ul>
<li>
<h3 id="h1">H1</h3>
</li>
</ul>
<p>计算凸包，尽管可以使用更优秀的算法在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的时间复杂度内计算凸包直径，但是在本题中凸包的计算并不是代码瓶颈，故而采用暴力枚举所有food点对进行计算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">H1</span>(<span class="params">state,problem</span>):</span><br><span class="line">    position, foodGrid = state</span><br><span class="line"></span><br><span class="line">    Maxdis = <span class="number">0</span></span><br><span class="line">    Mindis = <span class="number">99999</span></span><br><span class="line">    x1, y1 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    x2, y2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    Sum = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> foodGrid.asList():</span><br><span class="line">        Sum += <span class="built_in">abs</span>(i - position[<span class="number">0</span>]) + <span class="built_in">abs</span>(j - position[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">for</span> k, l <span class="keyword">in</span> foodGrid.asList():</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(i - k) + <span class="built_in">abs</span>(j - l) &gt;= Maxdis):</span><br><span class="line">                x1, y1 = i, j</span><br><span class="line">                x2, y2 = k, l</span><br><span class="line">                Maxdis = <span class="built_in">abs</span>(i - k) + <span class="built_in">abs</span>(j - l)</span><br><span class="line"></span><br><span class="line">    Mindis = <span class="built_in">min</span>(<span class="built_in">abs</span>(x1 - position[<span class="number">0</span>]) + <span class="built_in">abs</span>(y1 - position[<span class="number">1</span>]), <span class="built_in">abs</span>(x2 - position[<span class="number">0</span>]) + <span class="built_in">abs</span>(y2 - position[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> foodGrid.count() == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Maxdis + Mindis</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="h2">H2</h3>
</li>
</ul>
<p>实现了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mi>a</mi><mi>z</mi><mi>e</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">MazeDistance</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span></span></span></span>的计算，这里预先使用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>j</mi><mi>k</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">dijkstra</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span></span></span></span>算法将所有地图点对的最短距离存储在了一个四维数组中，而在查询时可以直接调用数组，从而可以大大加快计算速度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">Dij</span>(<span class="params">S,T,problem</span>):</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot; 计算S位置与T位置的迷宫最短留&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    P_Que = util.PriorityQueue()</span><br><span class="line">    VisitedNode = []</span><br><span class="line">    P_Que.push((S,<span class="number">0</span>) , <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> P_Que.isEmpty():</span><br><span class="line">        Now = P_Que.pop()</span><br><span class="line">        cur, dis = Now[<span class="number">0</span>], Now[<span class="number">1</span>]</span><br><span class="line">     <span class="comment">#   print(cur,&quot;##&quot;,dis)</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">not</span> <span class="keyword">in</span> VisitedNode:</span><br><span class="line">            VisitedNode.append(cur)</span><br><span class="line">            <span class="keyword">if</span> cur == T: <span class="keyword">return</span> dis</span><br><span class="line">            <span class="keyword">for</span> action <span class="keyword">in</span> [Directions.NORTH, Directions.SOUTH, Directions.EAST, Directions.WEST]:</span><br><span class="line">                x, y = cur[<span class="number">0</span>],cur[<span class="number">1</span>]</span><br><span class="line">                dx, dy = Actions.directionToVector(action)</span><br><span class="line">                nextx, nexty = <span class="built_in">int</span>(x + dx), <span class="built_in">int</span>(y + dy)</span><br><span class="line">                <span class="keyword">if</span> nextx &lt; <span class="number">0</span> <span class="keyword">or</span> nexty &lt; <span class="number">0</span> <span class="keyword">or</span> nextx &gt;= problem.walls.width <span class="keyword">or</span> nexty &gt;= problem.walls.height <span class="keyword">or</span> problem.walls[nextx][nexty] <span class="keyword">or</span> VisitedNode.__contains__((nextx,nexty)):</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    P_Que.push(((nextx,nexty),dis+<span class="number">1</span>),dis+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Build</span>(<span class="params">problem</span>):</span><br><span class="line">    A = C = problem.walls.width</span><br><span class="line">    B = D = problem.walls.height</span><br><span class="line">    Map = [[[[(<span class="number">0</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(D)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(C)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(B)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(A)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.width):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.height):</span><br><span class="line">            <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.width):</span><br><span class="line">                <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(problem.walls.height):</span><br><span class="line">                    <span class="keyword">if</span> problem.walls[i][j] <span class="keyword">or</span> problem.walls[k][l]:</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    Map[i][j][k][l] = Dij((i,j),(k,l),problem)</span><br><span class="line">    <span class="keyword">return</span> Map</span><br></pre></td></tr></table></figure>
<ul>
<li>
<h3 id="h3">H3</h3>
</li>
</ul>
<p>没有什么细节，直接调用<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mi>o</mi><mi>o</mi><mi>d</mi><mi>G</mi><mi>r</mi><mi>i</mi><mi>d</mi><mi mathvariant="normal">.</mi><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">foodGrid.count()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">G</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mord">.</span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault">u</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span>即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">H3</span>(<span class="params">state,problem</span>):</span><br><span class="line">    position, foodGrid = state</span><br><span class="line"></span><br><span class="line">    Mindis = <span class="number">99999</span></span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> foodGrid.asList():</span><br><span class="line">        Mindis = <span class="built_in">min</span>(Mindis,<span class="built_in">abs</span>(i - position[<span class="number">0</span>]) + <span class="built_in">abs</span>(j - position[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> foodGrid.count() == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Mindis + foodGrid.count()-<span class="number">1</span></span><br></pre></td></tr></table></figure>
<hr>
<h3 id="2-3-4-核心框架">2.3.4 核心框架</h3>
<p>和TASK2中的A*算法框架相同，只不过将启发式函数换成了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mi>e</mi><mi>u</mi><mi>r</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>c</mi><mi>F</mi><mi>u</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>H</mi><mn>1</mn><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>H</mi><mn>2</mn><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>H</mi><mn>3</mn><mo stretchy="false">(</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">HeuristicFuction() = max(H1(),H2(),H3())</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord mathdefault">e</span><span class="mord mathdefault">u</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">u</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">1</span><span class="mopen">(</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">2</span><span class="mopen">(</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="mord">3</span><span class="mopen">(</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>。</p>
<p>甚至就是调佣的同一个函数，只是改了启发式函数调用的指针而已。</p>
<hr>
<h3 id="2-3-5-实验结果">2.3.5 实验结果</h3>
<p>我们统一用拓展节点数作为评价指标，下面是实验结果：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>A* Search</th>
<th>nullHeuristic</th>
</tr>
</thead>
<tbody>
<tr>
<td>Search</td>
<td>31</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></td>
</tr>
<tr>
<td>smallSearch</td>
<td>307</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∞</mi></mrow><annotation encoding="application/x-tex">\infty</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">∞</span></span></span></span></td>
</tr>
</tbody>
</table>
<p><img src="8.png" alt="Alt text"></p>
<p><img src="9.png" alt=""></p>
<p>可以看到，我们的启发式函数在这两个问题上表现相当优秀。</p>
<p>（吐槽剩下的两个图太大了，这本来就是np问题，地图太大没办法跑也就没法继续评估A*，但是可以看到在两个能跑的问题上，我的A*能跑出相当优秀的结果）</p>
<hr>
<h1 id="3-总结">3 总结</h1>
<p>在本次作业中，我分别实现了深度优先搜索，宽度优先，Astar。</p>
<p>从结果上来看，发现Astar算法的效果最好，而且在不同的地图中，只需要调整一下权值就可以很好的适应不同的地图。</p>
<p>并且通过本次作业的学习，我对搜索算法有了不一样的认识，也对搜索算法的实现有了更深的理解。（debug痛苦呜呜呜</p>
<p>以上。</p>
]]></content>
      <categories>
        <category>实验报告</category>
      </categories>
      <tags>
        <tag>实验报告</tag>
      </tags>
  </entry>
</search>
